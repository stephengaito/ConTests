% A ConTeXt document [master document: contests.tex]

\startchapter[title=Lua Unit Testing]

We make extensive use of ideas in the design of the LunaTest Lua unit 
testing framework which is in turn inspired by the LUnit assertion 
interface. We tailor these ideas for use \emph{inside} \ConTeXt. 

\section[title=Test cases]

\startMkIVCode

\definetyping[LuaTest]
\setuptyping[LuaTest][option=lua]

\let\oldStopLuaTest=\stopLuaTest
\def\stopLuaTest{%
  \oldStopLuaTest%
  \directlua{thirddata.contests.addLuaTest('_typing_')}
}

\def\reportLuaStats{%
  \directlua{thirddata.contests.reportStats('lua')}
}

\stopMkIVCode

We provide local names for both \type{string.format} and \type{tostring}. 
We will make extensive use of both of these functions, in the next 
section, to format the reason each assertion fails. We defined these both 
now since we also make use of them to format the error messages returned 
by \type{runCurLuaTestCase}. 

\startLuaCode
local fmt   = string.format
local toStr = tostring
\stopLuaCode

\startLuaCode

function contests.addLuaTest(bufferName)
  local bufferContents = buffers.getcontent(bufferName):gsub("\13", "\n")
  local suite = tests.curSuite
  local case  = suite.curCase
  case.lua    = case.lua or {}
  table_insert(case.lua, bufferContents)
end

function contests.runCurLuaTestCase(suite, case)
  case.passed = case.passed or true
  local luaChunk = table_concat(case.lua, '\n')
  if not luaChunk:match('^%s*$') then
    local caseStats = tests.stats.lua.cases
    caseStats.attempted = caseStats.attempted + 1  
    luaChunk = [=[
    local assert = thirddata.contests.assert
    ]=]..luaChunk..[=[
    return true
    ]=]
    local luaFunc, errMessage = load(luaChunk)
    if luaFunc then
      local ok, errObj = pcall(luaFunc)
      if ok then
        caseStats.passed = caseStats.passed + 1
        tex.print("\\noindent{\\green PASSED}")
      else
        case.passed  = false
        suite.passed = false
        caseStats.failed = caseStats.failed + 1
        local failure = logFailure(
          "LuaTest FAILED",
          suite.desc,
          case.desc,
          errObj.message,
          toStr(errObj.reason),
          fmt("in file: %s between lines %s and %s",
            case.fileName, toStr(case.startLine), toStr(case.lastLine))
        )
        reportFailure(failure, false)
        table_insert(tests.failures, failure)
      end
    else
      case.passed  = false
      suite.passed = false
      caseStats.failed = caseStats.failed + 1
      local failure = logFailure(
        "LuaTest FAILED TO COMPILE",
        suite.desc,
        case.desc,
        "",
        errMessage,
        fmt("in file: %s between lines %s and %s",
          case.fileName, toStr(case.startLine), toStr(case.lastLine))
      )
      reportFailure(failure, false)
      table_insert(tests.failures, failure)
    end
  end
end

\stopLuaCode

\section[title=Assertions]

We start by defining a helper function to capture the repetitive code in 
one place. Every assertion will contain a condition, a message and some 
reason for failing the assertion. The \type{reportLuaAssertion} function 
captures these three values and builds an assertion result \emph{if} the 
condition is false. If the condition is true, the 
\type{reportLuaAssertion} function quietly does nothing but update the 
test statistics. 

\startLuaCode
function reportLuaAssertion(theCondition, aMessage, theReason)
  local assertionStats = tests.stats.lua.assertions
  assertionStats.attempted = assertionStats.attempted + 1
  --
  -- we do not need to do anything unless theCondition is false!
  if not theCondition then
    local test     = { }
    test.message   = aMessage
    test.reason    = theReason
    test.condition = theCondition
    local info     = debug.getinfo(2,'l')
    test.line      = info.currentline
    assertionStats.failed = assertionStats.failed + 1
    error(test, 0) -- throw an error to be captured by an error_handler
  end
  assertionStats.passed = assertionStats.passed + 1
end
\stopLuaCode

Having defined both the \type{reportLuaAssertion} and the \type{fmt} 
functions, we now work through each assertion in turn. For each assertion, 
we begin by defining the lua code which implements the assertion, and then 
the test cases which verify the assertion is working correctly. Typically 
there will be two test cases for each assertion, we need to test both the 
positive and negative conditions. 

\startTestSuite[assert.throwsError]

In order to test if a lua function throws an error, we need to wrap the 
actual function call (together with its arguments) in a lua \type{pcall}. 
The return value of this \type{pcall} is then checked to see if an error 
was thrown. 

It is critical to point out that since lua passes all parameters by 
\emph{value}, the \type{assert.throwsError} parameters consist of the 
\emph{function} to be tested, any message you want reported if the 
function \emph{does not throw} any errors, as well as (and these are the 
\quote{\type{...}}) any arguments. \emph{If} you pass the \emph{result} of 
calling the function on its arguments as the first parameter of this 
assertion, then any error that this function throws will be thrown 
\emph{before} the assertion can catch the error. 

\startLuaCode
function assert.throwsError(aFunction, aMessage, ...)
  local ok, err = pcall(aFunction, ...)
  if not ok and type(err) == 'table' and err.reason ~= nil then 
    -- this is an expected error which has already been counted...
    -- so reduce the number of failures and attempts...
    local assertions = tests.stats.lua.assertions
    assertions.failed    = assertions.failed    - 1
    assertions.attempted = assertions.attempted - 1
  end
  return reportLuaAssertion(
    not ok,
    aMessage,
    fmt("Expected %s to throw an error.", toStr(aFunction))
  )
end
\stopLuaCode

There are two cases we need to test.

\startTestCase[should succeed if error thrown]

In this first test case, we want to make sure if the tested function 
throws an error then the assertion succeeds.

Note that the function being tested: 

\starttyping[option=lua]
  assert.fail
end
\stoptyping

\noindent does \emph{not} need to accept any arguments. However it is 
important to notice that it is the \emph{function} that is being passed 
into the \type{assert.throwsError} and not the \emph{value} of calling 
this function. The actual function call is delayed and happens 
\emph{inside} the assertion. 

\startLuaTest
  assert.throwsError(assert.fail)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if no error thrown]

In this second test case, we want to make sure the assertion \emph{fails} 
if the tested function \emph{does not} throw an error.

For this test case, we are \emph{using} the \type{assert.throwsError} 
function to \emph{test} itself. This means that we \emph{must} pass the 
assertion function, \type{assert.throwsError} as the first argument. We 
must then pass a message (in this case an empty string), together with the 
argument to the \quote{inner} \type{assert.throwsError} function which is 
the \quote{null-function}: 

\starttyping[option=lua]
  assert.succeed
\stoptyping

\noindent We do this to ensure that the \quote{outer} 
\type{assert.throwsError} function can capture the error that the 
\quote{inner} \type{assert.throwsError} will throw since the most 
\quote{inner} nested function itself throws no error. 

\startLuaTest
  assert.throwsError(assert.throwsError, "", assert.succeed)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.throwsNoError]

The assertion \type{assert.throwsError}, detailed above, asserts that the 
tested function throws an error. We also need the ability to assert that a 
given function \emph{does not} throw an error. That is the purpose of the 
\type{assert.throwsNoError} assertion. Like the \type{assert.throwsError} 
assertion, the \type{assert.throwsNoError} assertion, wraps the function 
call to be tested in a lua \type{pcall}. This means that the 
\type{assert.throwsNoError} assertion's first parameter is the function to 
be tested, followed by any message to be used if the function \emph{does} 
throw an error, followed in turn by any arguments required by the function 
to be tested. 

\startLuaCode
function assert.throwsNoError(aFunction, aMessage, ...)
  local ok, err = pcall(aFunction, ...)
  if not ok and type(err) == 'table' and err.reason ~= nil then
    -- this is an unexpected error which has already been counted...
    -- so reduce the number of failures and attempts...
    local assertions = tests.stats.lua.assertions
    assertions.failed    = assertions.failed    - 1
    assertions.attempted = assertions.attempted - 1
  end
  return reportLuaAssertion(
    ok,
    aMessage,
    fmt("Expected %s not to throw an error (%s).",
      toStr(aFunction), toStr(err))
  )
end
\stopLuaCode

Again we have two cases we need to test.

\startTestCase[should succeed if no error thrown]

In this test case, we pass in a function which throws no error and expect 
the assertion to succeed. 

\startLuaTest
  assert.throwsNoError(assert.succeed)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if an error is thrown]

As above, we use the \type{assert.throwsError} assertion to \emph{test} 
the \type{assert.throwsNoError} function. This means we must pass in the 
\type{assert.throwsNoError} function as the first parameter to the 
\quote{outer} \type{assert.throwsError} function, followed by an (in this 
case) empty message, followed by the function which is going to be tested 
by the \type{assert.throwsNoError} function. Note that the 
\quote{inner-most} function \emph{does} throw an error. 

\startLuaTest
  assert.throwsError(assert.throwsNoError, "", assert.fail)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.fail]

The \type{assert.fail} assertion always fails, and hence stops all further 
testing of a given test case. This can be useful while developing complex 
test cases. The whole test case can be sketched out, but only the 
assertions up to the \type{assert.fail} assertion will be tested. 

\startLuaCode
function assert.fail(aMessage)
  return reportLuaAssertion(
    false,
    aMessage,
    "(Failed)"
  )
end
\stopLuaCode

\startTestCase[should always fail]

There is only one test case, this assertion should always fail.

\startLuaTest
  assert.throwsError(assert.fail, "")
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.succeed]

The \type{assert.succeed} assertion always succeeds.

\startLuaCode
function assert.succeed(aMessage)
  return reportLuaAssertion(
    true,
    aMessage,
    "(Succeed)"
  )
end
\stopLuaCode

\startTestCase[should always succeed]

There is only one test case, this assertion should always succeed. 

\startLuaTest
  assert.throwsNoError(assert.succeed, "")
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isBoolean]

The \type{assert.isBoolean} assertion tests a lua object to confirm that 
it is a boolean. 

\startLuaCode
function assert.isBoolean(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'boolean',
    aMessage,
    fmt("Expected %s to be a boolean.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if an object is a boolean]

The \type{assert.isBoolean} assertion should succeed if an object is a 
boolean. The boolean should be able to be passed in either directly or 
inside a variable reference. 

\startLuaTest
  assert.isBoolean(true)
  assert.isBoolean(false)
  local aBoolean = true
  assert.isBoolean(aBoolean)
  aBoolean = false
  assert.isBoolean(aBoolean)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if an object is not a boolean]

We use the \type{assert.throwsError} assertion to test the failure of the 
\type{assert.isBoolean} assertion. To do this we pass in various different 
lua objects, none of which are booleans. 

\startLuaTest
  assert.throwsError(assert.isBoolean, "", "aString")
  assert.throwsError(assert.isBoolean, "", { "a table" })
  assert.throwsError(assert.isBoolean, "", 42 )
  assert.throwsError(assert.isBoolean, "", function() end)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNotBoolean]

The \type{assert.isNotBoolean} assertion tests a lua object to confirm 
that it is \emph{not} a boolean. 

\startLuaCode
function assert.isNotBoolean(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'boolean',
    aMessage,
    fmt("Expected %s to not be a boolean.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if an object is not a boolean]

We assert directly that various non-boolean objects are not booleans. 

\startLuaTest
  assert.isNotBoolean("aString")
  assert.isNotBoolean({ "a table" })
  assert.isNotBoolean(42 )
  assert.isNotBoolean(function() end)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if an object is a boolean]

We use \type{assert.throwsError} to test the \type{assert.isBoolean} 
assertion, by passing in various booleans both directly and via variable 
references. 

\startLuaTest
  assert.throwsError(assert.isNotBoolean, "", true)
  assert.throwsError(assert.isNotBoolean, "", false)
  local aBoolean = true
  assert.throwsError(assert.isNotBoolean, "", aBoolean)
  aBoolean = false
  assert.throwsError(assert.isNotBoolean, "", aBoolean)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isTrue]

The \type{assert.isTrue} assertion tests a lua object to confirm that it 
is not either \type{false} or \type{nil} (which represents \quote{truth} 
in lua). 

\startLuaCode
function assert.isTrue(aBoolean, aMessage)
  return reportLuaAssertion(
    aBoolean,
    aMessage,
    fmt("Expected true, got %s.", toStr(aBoolean))
  )
end
\stopLuaCode

\startTestCase[should succeed if a boolean is true]

We test various lua objects which are neither \type{false} nor \type{nil}. 

\startLuaTest
  assert.isTrue(true)
  assert.isTrue("aString")
  assert.isTrue({ "aTable" })
  assert.isTrue(42)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if a boolean is false]

We test both \type{false} and \type{nil} to show they are not 
\quote{true}. 

\startLuaTest
  assert.throwsError(assert.isTrue, "", false)
  assert.throwsError(assert.isTrue, "", nil)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isFalse]

The \type{assert.isFalse} assertion tests a lua object to confirm that it 
is either \type{false} or \type{nil}. 

\startLuaCode
function assert.isFalse(aBoolean, aMessage)
  return reportLuaAssertion(
    not aBoolean,
    aMessage,
    fmt("Expected false, got %s.", toStr(aBoolean))
  )
end
\stopLuaCode

\startTestCase[should succeed if a boolean is false]

We test both \type{false} and \type{nil} to show that they are 
\quote{false}. 

\startLuaTest
  assert.isFalse(false)
  assert.isFalse(nil)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if a boolean is true]

We test various objects to show that they are not \quote{false}.

\startLuaTest
  assert.throwsError(assert.isFalse, "", true)
  assert.throwsError(assert.isFalse, "", "aString")
  assert.throwsError(assert.isFalse, "", { "aTable" })
  assert.throwsError(assert.isFalse, "", 42)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNil]

The \type{assert.isNil} assertion tests a lua object to confirm that it is 
\type{nil}. 

\startLuaCode
function assert.isNil(anObj, aMessage)
  return reportLuaAssertion(
    anObj == nil,
    aMessage,
    fmt("Expected nil, got %s.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if an object is nil]

We test \type{nil} to show that it is \type{nil}. 

\startLuaTest
  assert.isNil(nil)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if an object is not nil]

We test various non \type{nil} objects to show that they are not 
\type{nil}. 

\startLuaTest
  assert.throwsError(assert.isNil, "", true)
  assert.throwsError(assert.isNil, "", "aString")
  assert.throwsError(assert.isNil, "", { "aTable" })
  assert.throwsError(assert.isNil, "", 42)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNotNil]

The \type{assert.isNotNil} assertion tests a lua object to confirm that is 
it not \type{nil}. 

\startLuaCode
function assert.isNotNil(anObj, aMessage)
  return reportLuaAssertion(
    anObj ~= nil,
    aMessage,
    fmt("Expected non-nil, got %s.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if an object is not nil]

We test various lua objects which are not \type{nil}.

\startLuaTest
  assert.isNotNil(true)
  assert.isNotNil("aString")
  assert.isNotNil({ "aTable" })
  assert.isNotNil(42)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if an object is nil]

We test \type{nil}.

\startLuaTest
  assert.throwsError(assert.isNotNil, "", nil)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isEqual]

The \type{assert.isEqual} assertion tests two lua objects to confirm that 
they are equal (\type{==}) as far as lua is concerned. 

\startLuaCode
function assert.isEqual(objA, objB, aMessage)
  return reportLuaAssertion(
    objA == objB,
    aMessage,
    fmt("Expected %s to equal %s.",
      toStr(objA), toStr(objB))
  )
end
\stopLuaCode

\startTestCase[should succeed if the two objects are equal]

We test various pairs of objects to show that they are equal. Note that, 
unlike lua strings, lua tables are compared using memory pointers rather 
than recursive comparison. 

\startLuaTest
  assert.isEqual(true, true)
  assert.isEqual("aString", "aString")
  local aTable = { "aTable" }
  assert.isEqual(aTable, aTable)
  assert.isEqual(42, (40+2))
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the two objects are not equal]

We test various pairs of objects to show that they are not equal. 

\startLuaTest
  assert.throwsError(assert.isEqual, "", true, false)
  assert.throwsError(assert.isEqual, "",
    "aString", "anotherString")
  assert.throwsError(assert.isEqual, "",
    { "aTable" }, { "aDifferentTable"})
  assert.throwsError(assert.isEqual, "", 42, 0)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isEqualWithIn]

The \type{assert.isEqualWithIn} assertion only applies to numbers.

\startLuaCode
function assert.isEqualWithIn(numA, numB,
  tolerance, aMessage)
  return reportLuaAssertion(
    type(numA) == 'number' and type(numB) == 'number'
    and math.abs(numA - numB) <= tolerance,
    aMessage,
    fmt("Expected %s to equal %s with tolerance %s.",
      toStr(numA), toStr(numB), toStr(tolerance))
  )
end
\stopLuaCode

\startTestCase[should succeed if numA and numB are within tolerance]

We test various pairs of number all closer than tolerance. 

\startLuaTest
  assert.isEqualWithIn(42, 41, 2)
  assert.isEqualWithIn(42, 41, 1)
  assert.isEqualWithIn(0.5, 0.4, 0.2)
  assert.isEqualWithIn(41, 42, 2)
  assert.isEqualWithIn(0.4, 0.5, 0.2)
  assert.isEqualWithIn(0.4, 0.4, 0.1)
  assert.isEqualWithIn(0.3, 0.3, 0.0)
  assert.isEqualWithIn(-41, -42, 2)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if numA or numB are not numbers]

We confirm that \type{assert.isEqualWithIn} throws an error if either 
\type{numA} nor \type{numB} are \emph{not} numbers.

\startLuaTest
  assert.throwsError(assert.isEqualWithIn, "", "aString", 42, 10)
  assert.throwsError(assert.isEqualWithIn, "", 42, "aString", 10)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if numA and numB are not closer than tolerance]

We confirm that \type{assert.isEqualWithIn} throws an error if \type{numA} 
and \type{numB} are two numbers which are not closer than 
\type{tolerance}. 

\startLuaTest
  assert.throwsError(assert.isEqualWithIn, "", 42, 45, 1)
  assert.throwsError(assert.isEqualWithIn, "", 0.4, 0.9, 0.2)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNotEqual]

The \type{assert.isNotEqual} assertion tests two lua objects to confirm 
that they are not equal (\type{~=}) as far as lua is concerned. 

\startLuaCode
function assert.isNotEqual(objA, objB, aMessage)
  return reportLuaAssertion(
    objA ~= objB,
    aMessage,
    fmt("Expected %s to not equal %s.",
      toStr(objA), toStr(objB))
  )
end
\stopLuaCode

\startTestCase[should succeed if the two objects are not equal]

We test using various pairs of unequal objects.

\startLuaTest
  assert.isNotEqual(42, 41)
  assert.isNotEqual("aString", "anotherString")
  assert.isNotEqual({ "aTable" }, { "aDifferentTable"})
  assert.isNotEqual(42, "aString")
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the two objects are equal]

We test using various pairs of equal objects.

\startLuaTest
  assert.throwsError(assert.isNotEqual, "", 42, 42)
  assert.throwsError(assert.isNotEqual, "", "aString", "aString")
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNotEqualWithIn]

The \type{assert.isNotEqualWithIn} assertion confirms that two objects are 
either neither numbers, or they are further apart then the given 
\type{tolerance}. 

\startLuaCode
function assert.isNotEqualWithIn(numA, numB, tolerance, aMessage)
  return reportLuaAssertion(
    type(numA) ~= 'number' or type(numB) ~= 'number'
    or tolerance < math.abs(numA - numB), 
    aMessage,
    fmt("Expected %s to not equal %s with tolerance %s.",
      toStr(numA), toStr(numB), toStr(tolerance))
  )
end
\stopLuaCode

\startTestCase[should succeed if either object is not a number]

We test using various pairs of objects of which at least one is not a 
number. 

\startLuaTest
  assert.isNotEqualWithIn("aString", "aString", 10)
  assert.isNotEqualWithIn("aString", 42, 10)
\stopLuaTest
\stopTestCase

\startTestCase[should succeed if the two numbers are far apart]

We test using two numbers which are further than \type{tolerance} apart. 

\startLuaTest
  assert.isNotEqualWithIn(42, 45, 2)
  assert.isNotEqualWithIn(-42, -45, 2)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the two numbers are with in tolerance]

We test using two numbers which are closer than \type{tolerance}. 

\startLuaTest
  assert.throwsError(assert.isNotEqualWithIn, "", 42, 41, 2)
  assert.throwsError(assert.isNotEqualWithIn, "", -41, -42, 2)
  assert.throwsError(assert.isNotEqualWithIn, "", 0.5, 0.4, 0.3)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNumber]

The \type{assert.isNumber} assertion confirms that the lua object is a 
number. 

\startLuaCode
function assert.isNumber(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'number',
    aMessage,
    fmt("Expected %s to be a number.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object is a number]

We test using various numbers.

\startLuaTest
  assert.isNumber(42)
  assert.isNumber(4.2)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is not a number]

We test using various objects which are not numbers. 

\startLuaTest
  assert.throwsError(assert.isNumber, "", "aString")
  assert.throwsError(assert.isNumber, "", { "aTable" })
  assert.throwsError(assert.isNumber, "", function() end)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isGT]

The \type{assert.isGT} assertion confirms that \type{objA} is greater than 
\type{objB}. 

\startLuaCode
function assert.isGT(objA, objB, aMessage)
  return reportLuaAssertion(
    objA > objB,
    aMessage,
    fmt("Expected %s > %s.", toStr(objA), toStr(objB))
  )
end
\stopLuaCode

\startTestCase[when both objects are numbers]

We test various pairs of objects which are both numbers.

We start by considering pairs for which \type{objA} is greater than 
\type{objB}. 

\startLuaTest
  assert.isGT(42, 41)
  assert.isGT(0.3, 0.2)
  assert.isGT(5, -3)
\stopLuaTest

We now consider pairs for which \type{objA} is less than or equal to 
\type{objB}. 

\startLuaTest
  assert.throwsError(assert.isGT, "", 41, 42)
  assert.throwsError(assert.isGT, "", 42, 42)
  assert.throwsError(assert.isGT, "", 0.4, 0.9)
\stopLuaTest
\stopTestCase

\startTestCase[when both objects are strings]

We test various pairs of strings.

We start by considering pairs for which \type{objA} is lexically greater 
than \type{objB}. 

\startLuaTest
  assert.isGT("aString02", "aString01")
  assert.isGT("222", "211")
\stopLuaTest

We now consider pairs for which \type{objA} is lexically less than or 
equal to \type{objB}. 

\startLuaTest
  assert.throwsError(assert.isGT, "", "aString", "aString")
  assert.throwsError(assert.isGT, "", "211", "222")
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isGTE]

The \type{assert.isGTE} assertion confirms that \type{objA} is greater 
than or equal to \type{objB}. 

\startLuaCode
function assert.isGTE(objA, objB, aMessage)
  return reportLuaAssertion(
    objA >= objB,
    aMessage,
    fmt("Expected %s >= %s.", toStr(objA), toStr(objB))
  )
end
\stopLuaCode

\startTestCase[when both objects are numbers]

We consider the case when both objects are numbers.

We start by considering the case when \type{objA} is greater than or equal 
to \type{objB}. 

\startLuaTest
  assert.isGTE(42, 42)
  assert.isGTE(43, 42)
  assert.isGTE(0.3, 0.3)
  assert.isGTE(0.3, 0.2)
  assert.isGTE(0.3, -0.2)
\stopLuaTest

Now we consider the case when \type{objA} is less than \type{objB}. 

\startLuaTest
  assert.throwsError(assert.isGTE, "", 42, 43)
  assert.throwsError(assert.isGTE, "", 0.2, 0.3)
  assert.throwsError(assert.isGTE, "", -0.2, 0.3)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isLT]

The \type{assert.isLT} assertion confirms that \type{objA} is less than 
\type{objB}. 

\startLuaCode
function assert.isLT(objA, objB, aMessage)
  return reportLuaAssertion(
    objA < objB,
    aMessage,
    fmt("Expected %s < %s.", toStr(objA), toStr(objB))
  )
end
\stopLuaCode

\startTestCase[when both objects are numbers]

We consider the case when both objects are numbers.

We test various pairs of numbers for which \type{objA} is less than 
\type{objB}. 

\startLuaTest
  assert.isLT(42, 45)
  assert.isLT(0.2, 0.3)
  assert.isLT(42, 42.5)
  assert.isLT(-42, 42)
\stopLuaTest

Now we test various pairs of numbers for which \type{objA} is greater than 
or equal to \type{objB}. 

\startLuaTest
  assert.throwsError(assert.isLT, "", 45, 42)
  assert.throwsError(assert.isLT, "", 42, 42)
  assert.throwsError(assert.isLT, "", 0.3, 0.2)
  assert.throwsError(assert.isLT, "", 0.3, 0.3)
\stopLuaTest
\stopTestCase

\startTestCase[when both objects are strings]

We consider the case when both objects are strings. 

We start by testing various pairs of strings where \type{objA} is 
lexically less than \type{objB}. 

\startLuaTest
  assert.isLT("aStringA", "aStringB")
  assert.isLT("211", "222")
\stopLuaTest

Now we considers pairs where \type{objA} is lexically greater than or 
equal to \type{objB}. 

\startLuaTest
  assert.throwsError(assert.isLT, "", "aString", "aString")
  assert.throwsError(assert.isLT, "", "aStringB", "aStringA")
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isLTE]

The \type{assert.isLTE} assertion confirms that type{objA} is less than or 
equal to \type{objB}. 

\startLuaCode
function assert.isLTE(objA, objB, aMessage)
  return reportLuaAssertion(
    objA <= objB,
    aMessage,
    fmt("Expected %s <= %s.", toStr(objA), toStr(objB))
  )
end
\stopLuaCode


\startTestCase[when both objects are numbers]

We consider the case when both objects are numbers. 

We start by testing various pairs where \type{objA} is less than or equal 
to \type{objB}. 

\startLuaTest
  assert.isLTE(42, 42)
  assert.isLTE(41, 42)
  assert.isLTE(0.3, 0.3)
  assert.isLTE(0.2, 0.3)
\stopLuaTest

Now we consider pairs where \type{objA} is greater than \type{objB}. 

\startLuaTest
  assert.throwsError(assert.isLTE, "", 43, 42)
  assert.throwsError(assert.isLTE, "", 0.3, 0.2)
\stopLuaTest
\stopTestCase

\startTestCase[when both objects are strings]

We consider the case when both objects are strings.

We start by testing various pairs where \type{objA} is lexically less than 
or equal to \type{objB}. 

\startLuaTest
  assert.isLTE("aString", "aString")
  assert.isLTE("aStringA", "aStringB")
\stopLuaTest

Now we consider pairs where \type{objA} is lexically greater than 
\type{objB}. 

\startLuaTest
  assert.throwsError(assert.isLTE, "", "aStringB", "aStringA")
\stopLuaTest

\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNotNumber]

The \type{assert.isNotNumber} assertions confirms that a lua object is not 
a number. 

\startLuaCode
function assert.isNotNumber(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'number',
    aMessage,
    fmt("Expected %s to be a number.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object is not a number]

We test using various objects which are not numbers. 

\startLuaTest
  assert.isNotNumber("aString")
  assert.isNotNumber({ "aTable" })
  assert.isNotNumber(function() end)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is a number]

We test using various numbers.

\startLuaTest
  assert.throwsError(assert.isNotNumber, "", 42)
  assert.throwsError(assert.isNotNumber, "", 4.2)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isString]

The \type{assert.isString} assertion confirms that the object is a string. 

\startLuaCode
function assert.isString(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'string',
    aMessage,
    fmt("Expected [%s] to be a string.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object is a string]

We test using various strings.

\startLuaTest
  assert.isString("aString")
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is not a string]

We test using various objects which are not strings. 

\startLuaTest
  assert.throwsError(assert.isString, "", 42)
  assert.throwsError(assert.isString, "", { "aTable" })
  assert.throwsError(assert.isString, "", function() end)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.matches]

The \type{assert.matches} assertion confirms that the object is both a 
string and that it matches the given pattern, using lua's pattern matching 
tools. 

\startLuaCode
function assert.matches(anObj, aPattern, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'string' and type(aPattern) == 'string' 
    and anObj:match(aPattern),
    aMessage,
    fmt("Expected [%s] to match [%s].",
      toStr(anObj), toStr(aPattern))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object matches the pattern]

We use various strings which match the provided patterns. 

\startLuaTest
  assert.matches("this is a test", "test", "pat:test")
  assert.matches("this is a test", "[ ]*", "pat:[ ]*")
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is not a string]

We test using objects which are not strings.

\startLuaTest
  assert.throwsError(assert.matches, "", 42, "[ ]*")
  assert.throwsError(assert.matches, "",
    "this is a test", 42)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the string does not match the pattern]

We test using a string which does not match the pattern.

\startLuaTest
  assert.throwsError(assert.matches, "", 
    "this is a test", "  ") -- does not have two spaces
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.doesNotMatch]

The \type{assert.doesNotMatch} assertion confirms that one of the object 
or pattern are not strings, or that the object does not match the pattern. 

\startLuaCode
function assert.doesNotMatch(anObj, aPattern, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'string' or type(aPattern) ~= 'string' 
    or not anObj:match(aPattern),
    aMessage,
    fmt("Expected [%s] to not match [%s].",
      toStr(anObj), toStr(aPattern))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object does not match the pattern]

We use various strings which do not match the associated pattern. 

\startLuaTest
  assert.doesNotMatch("this is a test", "  ") -- two spaces
  assert.doesNotMatch("this is a test", "something")
  assert.doesNotMatch("this is a test", "^ ")
\stopLuaTest
\stopTestCase

\startTestCase[should succeed if either the object or pattern are not strings]

We consider the case where either the object or pattern are not strings. 

\startLuaTest
  assert.doesNotMatch(42, "[ ]")
  assert.doesNotMatch("this is a test", 42)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the string does match the pattern]

We consider the case where the string does match the pattern.

\startLuaTest
  assert.throwsError(assert.doesNotMatch, "", "this is a test", "test")
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.length]

The \type{assert.length} assertion confirms that the string or array have 
the specified length. 

\startLuaCode
function assert.length(anObj, aLength, aMessage)
  return reportLuaAssertion(
    #anObj == aLength,
    aMessage,
    fmt("Expected %s to have length %s.",
      toStr(anObj), toStr(aMessage))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object's length is correct]

We consider the case where the string or array have the specified length. 

\startLuaTest
  assert.length("this", 4)
  assert.length({ "1", "2"}, 2)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object does not have the correct length]

We consider the case where the string, array or object do not have the 
specified length. 

\startLuaTest
  assert.throwsError(assert.length, "", "this", 3)
  assert.throwsError(assert.length, "", { "1", "2" }, 5)
  assert.throwsError(assert.length, "", 42, 2)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNotLength]

The \type{assert.isNotLength} assertion confirms that the object does not 
have the specified length. 

\startLuaCode
function assert.isNotLength(anObj, aLength, aMessage)
  return reportLuaAssertion(
    #anObj ~= aLength,
    aMessage,
    fmt("Expected %s to not have length %s.",
      toStr(anObj), toStr(aMessage))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object does not have the correct length]

We consider the case where the string or array does not have the specified 
length.

\startLuaTest
  assert.isNotLength("this", 2)
  assert.isNotLength({ "1", "2" }, 1)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object has the correct length]

We consider the case where the string or array has the specified length. 

\startLuaTest
  assert.throwsError(assert.isNotLength, "", "this", 4)
  assert.throwsError(assert.isNotLength, "", { "1", "2" }, 2)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is not a string or array]

We consider objects which are not strings or arrays.

\startLuaTest
  assert.throwsError(assert.isNotLength, "", 42, 2)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNotString]

The \type{assert.isNotString} assertion confirms that the object is not a 
string. 

\startLuaCode
function assert.isNotString(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'string',
    aMessage,
    fmt("Expected [%s] to not be a string.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object is not a string]

We consider various objects which are not strings.

\startLuaTest
  assert.isNotString(42)
  assert.isNotString({ "aTable" })
  assert.isNotString(function() end)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is a string]

We consider various strings.

\startLuaTest
  assert.throwsError(assert.isNotString, "", "aString")
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isTable]

The \type{assert.isTable} assertion confirms that the object is a lua 
table. 

\startLuaCode
function assert.isTable(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'table',
    aMessage,
    fmt("Expected %s to be a table.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object is a table]

We consider various lua tables.

\startLuaTest
  assert.isTable({ })
  assert.isTable({ "1", "2" })
  assert.isTable({ one = "one", two = "two" })
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is not a table]

We consider various objects which are not tables. 

\startLuaTest
  assert.throwsError(assert.isTable, "", "aString")
  assert.throwsError(assert.isTable, "", 42)
  assert.throwsError(assert.isTable, "", function() end)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.hasKey]

The \type{assert.hasKey} assertion confirms that the given table has the 
key provided. 

\startLuaCode
function assert.hasKey(anObj, aKey, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'table' and anObj[aKey] ~= nil,
    aMessage,
    fmt("Expected %s to have the key %s.",
      toStr(anObj), toStr(aKey))
  )
end
\stopLuaCode

\startTestCase[should succeed if the table has the key]

We consider various tables and key combinations.

\startLuaTest
  assert.hasKey({ oneKey = "oneValue" }, "oneKey")
  assert.hasKey({ "1", "2" }, 1)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the table does not have the key]

We consider keys which are not contained in the given table. 

\startLuaTest
  assert.throwsError(assert.hasKey, "",
    { oneKey = "oneValue" }, "twoKey")
  assert.throwsError(assert.hasKey, "",
    { "1", "2" }, 10)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is not a table]

We consider objects which are not tables.

\startLuaTest
  assert.throwsError(assert.hasKey, "", 42, 1)
  assert.throwsError(assert.hasKey, "", "aString", 2)
  assert.throwsError(assert.hasKey, "", function() end, 3)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.doesNotHaveKey]

The \type{assert.doesNotHaveKey} assertion confirms that either the object 
is not a table, or that the table does not have the key. 

\startLuaCode
function assert.doesNotHaveKey(anObj, aKey, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'table' and anObj[aKey] == nil,
    aMessage,
    fmt("Expected %s to not have the key %s.",
      toStr(anObj), toStr(aKey))
  )
end
\stopLuaCode

\startTestCase[should succeed if the table does not have the key]

We consider keys which are not contained in the given lua table.

\startLuaTest
  assert.doesNotHaveKey({ oneKey = "oneValue" }, "twoKey")
  assert.doesNotHaveKey({ "1", "2" }, 10)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the table has the key]

We consider keys which are contained in the given lua table.

\startLuaTest
  assert.throwsError(assert.doesNotHaveKey, "",
    { oneKey = "oneValue" }, "oneKey")
  assert.throwsError(assert.doesNotHaveKey, "",
    { "1", "2" }, 1)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is not a table]

We consider objects which are not lua tables.

\startLuaTest
  assert.throwsError(assert.doesNotHaveKey, "", 42, 2)
  assert.throwsError(assert.doesNotHaveKey, "", "aString", 2)
  assert.throwsError(assert.doesNotHaveKey, "",
    function() end, 2)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNotTable]

The \type{assert.isNotTable} assertion confirms that the object is not a 
lua table. 

\startLuaCode
function assert.isNotTable(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'table',
    aMessage,
    fmt("Expected %s to not be a table.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object is not a table]

We consider various objects which are not lua tables.

\startLuaTest
  assert.isNotTable(42)
  assert.isNotTable("aString")
  assert.isNotTable(function() end)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is a table]

We consider various tables.

\startLuaTest
  assert.throwsError(assert.isNotTable, "", { "1", "2" })
  assert.throwsError(assert.isNotTable, "", { oneKey = "oneValue" })
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isFunction]

The \type{assert.isFunction} assertion confirms that an object is a lua 
function. 

\startLuaCode
function assert.isFunction(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'function',
    aMessage,
    fmt("Expected %s to be a function.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object is a funciton]

We test a lua function.

\startLuaTest
  assert.isFunction(function() end)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is not a function]

We test various objects which are not lua functions.

\startLuaTest
  assert.throwsError(assert.isFunction, "", 42)
  assert.throwsError(assert.isFunction, "", "aString")
  assert.throwsError(assert.isFunction, "", { "aTable" })
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNotFunction]

The \type{assert.isNotFunciton} assertion confirms that an object is not a 
lua function. 

\startLuaCode
function assert.isNotFunction(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'function',
    aMessage,
    fmt("Expected %s to not be a function.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object is not a function]

We test various objects which are not lua functions.

\startLuaTest
  assert.isNotFunction(42)
  assert.isNotFunction("aString")
  assert.isNotFunction({ "aTable" })
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is a function]

We test a function.

\startLuaTest
  assert.throwsError(assert.isNotFunction, "", function() end)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.hasMetaTable]

The \type{assert.hasMetaTable} assertion confirms that a lua object has an 
associated meta-table. In lua meta-tables act as object classes, providing 
class level methods for any object with a given meta-table. 

\startLuaCode
function assert.hasMetaTable(anObj, aMessage)
  return reportLuaAssertion(
    getmetatable(anObj) ~= nil,
    aMessage,
    fmt("Expected %s to have a meta table.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object has a meta-table]

Since strings have meta-tables, we test this assertion with strings.

\startLuaTest
  assert.hasMetaTable("aString")
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object does not have a meta-table]

Since integers do not have meta-tables, we test the failure of this 
assertion with integers. 

\startLuaTest
  assert.throwsError(assert.hasMetaTable, "", 42)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.metaTableEquals]

The \type{assert.metaTableEquals} assertion confirms that an object has a 
given meta-table. 

\startLuaCode
function assert.metaTableEqual(anObj, aMetaTable, aMessage)
  return reportLuaAssertion(
    getmetatable(anObj) == aMetaTable,
    aMessage,
    fmt("Expected %s to have the meta table %s.",
      toStr(anObj), toStr(aMetaTable))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object's meta-table is that provided]

Since strings have meta-tables, we get the meta-table and test a string 
with that meta-table. 

\startLuaTest
  local aMetaTable = getmetatable("aString")
  assert.metaTableEqual("aString", aMetaTable)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object's meta-table is not provided]

Since any table can be made into a meta-table for some object, we will 
test with strings and a simple table. 

\startLuaTest
  assert.throwsError(assert.metaTableEqual, "",
    "aString", { "aTable" })
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.metaTableNotEqual]

The \type{assert.metaTableNotEqual} assertion confirms that an object's 
meta-table is not equal to the one provided. 

\startLuaCode
function assert.metaTableNotEqual(anObj, aMetaTable, aMessage)
  return reportLuaAssertion(
    getmetatable(anObj) ~= aMetaTable,
    aMessage,
    fmt("Expected %s to not have the meta-table %s.",
      toStr(anObj), toStr(aMetaTable))
  )
end
\stopLuaCode

\startTestCase[should succeed if the objects's meta-table is not the one provided]

We test with a string and a simple table.

\startLuaTest
  assert.metaTableNotEqual("aString", { "aTable" })
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object's meta-table is that provided]

We will test with a string's meta-table.

\startLuaTest
  local aMetaTable = getmetatable("aString")
  assert.throwsError(assert.metaTableNotEqual, "",
    "aString", aMetaTable)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.doesNotHaveMetaTable]

The \type{assert.doesNotHaveMetaTable} assertion confirms that an object 
does not have a meta-table. 

\startLuaCode
function assert.doesNotHaveMetaTable(anObj, aMessage)
  return reportLuaAssertion(
    getmetatable(anObj) == nil,
    aMessage,
    fmt("Expected %s to not have a meta table.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object does not have a meta-table]

Since integer's do not have meta-tables, we test with an integer.

\startLuaTest
  assert.doesNotHaveMetaTable(42)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object has a meta-table]

We use a string to test the failure of this assertion. 

\startLuaTest
  assert.throwsError(assert.doesNotHaveMetaTable, "", "aString")
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isThread]

The \type{assert.isThread} assertion confirms that the object is a lua 
thread. 

\startLuaCode
function assert.isThread(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'thread',
    aMessage,
    fmt("Expected %s to be a thread.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object is a thread]

We build a thread and test it. Note that the \type{coroutine.create} 
creates but does not start a thread on a particular lua function. 

\startLuaTest
  assert.isThread(coroutine.create(function() end))
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is not a thread]

We test various objects which are not threads.

\startLuaTest
  assert.throwsError(assert.isThread, "", 42)
  assert.throwsError(assert.isThread, "", "aString")
  assert.throwsError(assert.isThread, "", { "aTable" })
  assert.throwsError(assert.isThread, "", function() end)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNotThread]

The \type{assert.isNotThread} assertion confirms that an object is not a 
thread. 

\startLuaCode
function assert.isNotThread(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'thread',
    aMessage,
    fmt("Expected %s to not be a thread.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object is not a thread]

We test using various objects that are not threads. 

\startLuaTest
  assert.isNotThread(42)
  assert.isNotThread("aString")
  assert.isNotThread({ "aTable" })
  assert.isNotThread(function() end)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is a thread]

We build a thread and test it.

\startLuaTest
  assert.throwsError(assert.isNotThread, "",
    coroutine.create(function() end))
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isUserData]

The \type{assert.isUserData} assertion confirms an object is a lua 
\quote{userData} object. Note that typically lua \quote{userData} objects 
are opaque handles to non-lua objects. 

\startLuaCode
function assert.isUserData(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'userdata',
    aMessage,
    fmt("Expected %s to be user data.", toStr(anObj))
  )
end
\stopLuaCode

Note that at the moment we do not provide any \quote{successful} tests for 
the \type{assert.isUserData} assertion, since we would need to compile and 
link an shared library written in some non-lua language such as ANSI-C. 

\startTestCase[should fail if the object is not a userData]

We test various objects which are not \quote{userData}.

\startLuaTest
  assert.throwsError(assert.isUserData, "", 42)
  assert.throwsError(assert.isUserData, "", "aString")
  assert.throwsError(assert.isUserData, "", { "aTable" })
  assert.throwsError(assert.isUserData, "", function() end)
\stopLuaTest
\stopTestCase

\stopTestSuite

\godown[2ex]
The \type{assert.isNotUserData} assertion confirms that an object is not a 
lua \quote{userData}. 

\startTestSuite[assert.isNotUserData]

\startLuaCode
function assert.isNotUserData(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'userdata',
    aMessage,
    fmt("Expected %s to not be user data.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object is not userData]

We test various objects which are not \quote{userData}.

\startLuaTest
  assert.isNotUserData(42)
  assert.isNotUserData("aString")
  assert.isNotUserData({ "aTable" })
  assert.isNotUserData(function() end)
\stopLuaTest
\stopTestCase

\godown[2ex]
Note that at the moment we do not provide any \quote{failure} tests for 
the \type{assert.isNotUserData} assertion, since we would need to compile 
and link an shared library written in some non-lua language such as 
ANSI-C. 

\stopTestSuite

\section{Test case results}

\reportLuaStats

\reportFailures

\stopchapter