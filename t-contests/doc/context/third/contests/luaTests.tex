% A ConTeXt document [master document: contests.tex]

\startchapter[title=Lua Unit Testing]

We make extensive use of ideas in the design of the LunaTest Lua unit 
testing framework which is in turn inspired by the LUnit assertion 
interface. We tailor these ideas for use \emph{inside} \ConTeXt. 

\section[title=Test cases]

\startMkIVCode

\definetyping[LuaTest]
\setuptyping[LuaTest][option=lua]

\let\oldStopLuaTest=\stopLuaTest
\def\stopLuaTest{%
  \oldStopLuaTest%
  \directlua{thirddata.contests.addLuaTest('_typing_')}
}

\stopMkIVCode

\startLuaCode

function contests.addLuaTest(bufferName)
  local bufferContents = buffers.getcontent(bufferName):gsub("\13", "\n")
  local suite = tests.curSuite
  local case  = suite.curCase
  case.lua    = case.lua or {}
  table_insert(case.lua, bufferContents)
end

function contests.runCurLuaTestCase()
  local suite    = tests.curSuite
  local case     = suite.curCase
  local luaChunk = table_concat(case.lua, '\n')
  if not luaChunk:match('^%s*$') then
    luaChunk = [=[
    local assert = thirddata.contests.assert
    ]=]..luaChunk
    -- consider using PCall here
    local luaFunc, errMessage = load(luaChunk)
    if luaFunc then
      --local result = luaFunc()
    end
  end
end

\stopLuaCode

\section[title=Assertions]

We start by defining a helper function to capture the repetitive code in 
one place. Every assertion will contain a condition, a message and some 
reason for failing the assertion. The \type{reportLuaAssertion} function 
captures these three values and builds an assertion result \emph{if} the 
condition is false. If the condition is true, the 
\type{reportLuaAssertion} function quietly does nothing but update the 
test statistics. 

\startLuaCode
function reportLuaAssertion(theCondition, aMessage, theReason)
  -- we do not need to do anything unless theCondition if false!
  if not theCondition then
    local test     = { }
    test.message   = aMessage
    test.reason    = theReason
    test.condition = theCondition
    local info     = debug.getinfo(2,'l')
    test.line      = info.currentline
    error(test, 0) -- throw an error to be captured by an error_handler
  end
end
\stopLuaCode

Since all of the assertions will use the standard lua \type{string.format} 
function to format the various reasons using information specific to each 
assertion, we make \type{string.format} local with a shorter name. For 
efficiency we also make the lua global \type{tostring} a local with the 
shorter name \type{toStr}. 

\startLuaCode
local fmt   = string.format
local toStr = tostring
\stopLuaCode

Having defined both the \type{reportLuaAssertion} and the \type{fmt} 
functions, we now work through each assertion in turn. For each assertion, 
we begin by defining the lua code which implements the assertion, and then 
the test cases which verify the assertion is working correctly. Typically 
there will be two test cases for each assertion, we need to test both the 
positive and negative conditions. 

\startTestSuite[assert.throwsError]

In order to test if a lua function throws an error, we need to wrap the 
actual function call (together with its arguments) in a lua \type{pcall}. 
The return value of this \type{pcall} is then checked to see if an error 
was thrown. 

It is critical to point out that since lua passes all parameters by 
\emph{value}, the \type{assert.throwsError} parameters consist of the 
\emph{function} to be tested, any message you want reported if the 
function \emph{does not throw} any errors, as well as (and these are the 
\quote{\type{...}}) any arguments. \emph{If} you pass the \emph{result} of 
calling the function on its arguments as the first parameter of this 
assertion, then any error that this function throws will be thrown 
\emph{before} the assertion can catch the error. 

\startLuaCode
function assert.throwsError(aFunction, aMessage, ...)
  local ok, err = pcall(aFunction, ...)
  return reportLuaAssertion(
    not ok,
    aMessage,
    fmt("Expected %s to throw an error.", toStr(aFunction))
  )
end
\stopLuaCode

There are two cases we need to test.

\startTestCase[should succeed if error thrown]

In this first test case, we want to make sure if the tested function 
throws an error then the assertion succeeds.

Note that the function being tested: 

\starttyping[option=lua]
function()
  error("this 'inner' function throws an error!")
end
\stoptyping

\noindent does \emph{not} accept any arguments. However it is important to 
notice that it is the \emph{function} that is being passed into the 
\type{assert.throwsError} and not the \emph{value} of calling this 
function. The actual function call is delayed and happens \emph{inside} 
the assertion. 

\startLuaTest
  assert.throwsError(function()
    error("this 'inner' function throws an error!")
  end)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if no error thrown]

In this second test case, we want to make sure the assertion \emph{fails} 
if the tested function \emph{does not} throw an error.

For this test case, we are \emph{using} the \type{assert.throwsError} 
function to \emph{test} itself. This means that we \emph{must} pass the 
assertion function, \type{assert.throwsError} as the first argument. We 
must then pass a message (in this case an empty string), together with the 
argument to the \quote{inner} \type{assert.throwsError} function which is 
the \quote{null-function}: 

\starttyping[option=lua]
function() end
\stoptyping

\noindent We do this to ensure that the \quote{outer} 
\type{assert.throwsError} function can capture the error that the 
\quote{inner} \type{assert.throwsError} will throw since the most 
\quote{inner} nested function itself throws no error. 

\startLuaTest
  assert.throwsError(assert.throwsError, "", function() end)
\stopLuaTest
\stopTestCase

\stopTestSuite


\startTestSuite[assert.throwsNoError]

The assertion \type{assert.throwsError}, detailed above, asserts that the 
tested function throws an error. We also need the ability to assert that a 
given function \emph{does not} throw an error. That is the purpose of the 
\type{assert.throwsNoError} assertion. Like the \type{assert.throwsError} 
assertion, the \type{assert.throwsNoError} assertion, wraps the function 
call to be tested in a lua \type{pcall}. This means that the 
\type{assert.throwsNoError} assertion's first parameter is the function to 
be tested, followed by any message to be used if the function \emph{does} 
throw an error, followed in turn by any arguments required by the function 
to be tested. 

\startLuaCode
function assert.throwsNoError(aFunction, aMessage, ...)
  local ok, err = pcall(aFunction, ...)
  return reportLuaAssertion(
    ok,
    aMessage,
    fmt("Expected %s not to throw an error (%s).",
      toStr(aFunction), toStr(err))
  )
end
\stopLuaCode

Again we have two cases we need to test.

\startTestCase[should succeed if no error thrown]

In this test case, we pass in a function which throws no error and expect 
the assertion to succeed. 

\startLuaTest
  assert.throwsNoError(function() end)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if an error is thrown]

As above, we use the \type{assert.throwsError} assertion to \emph{test} 
the \type{assert.throwsNoError} function. This means we must pass in the 
\type{assert.throwsNoError} function as the first parameter to the 
\quote{outer} \type{assert.throwsError} function, followed by an (in this 
case) empty message, followed by the function which is going to be tested 
by the \type{assert.throwsNoError} function. Note that the 
\quote{inner-most} function \emph{does} throw an error. 

\startLuaTest
  assert.throwsError(assert.throwsNoError, "", function()
    error("this 'inner-most' function throws an error!")
  )
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.fail]

The \type{assert.fail} assertion always fails, and hence stops all further 
testing of a given test case. This can be useful while developing complex 
test cases. The whole test case can be sketched out, but only the 
assertions up to the \type{assert.fail} assertion will be tested. 

\startLuaCode
function assert.fail(aMessage)
  return reportLuaAssertion(
    false,
    aMessage,
    "(Failed)"
  )
end
\stopLuaCode

\startTestCase[should always fail]

There is only one test case, this assertion should always fail.

\startLuaTest
  assert.throwsError(assert.fail, "")
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isBoolean]

The \type{assert.isBoolean} assertion tests an lua object to confirm that 
it is a boolean. 

\startLuaCode
function assert.isBoolean(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'boolean',
    aMessage,
    fmt("Expected %s to be a boolean.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if an object is a boolean]

The \type{assert.isBoolean} assertion should succeed if an object is a 
boolean. The boolean should be able to be passed in either directly or 
inside a variable reference. 

\startLuaTest
  assert.isBoolean(true)
  assert.isBoolean(false)
  local aBoolean = true
  assert.isBoolean(aBoolean)
  aBoolean = false
  assert.isBoolean(aBoolean)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if an object is not a boolean]

We use the \type{assert.throwsError} assertion to test the failure of the 
\type{assert.isBoolean} assertion. To do this we pass in various different 
lua objects, none of which are booleans. 

\startLuaTest
  assert.throwsError(assert.isBoolean, "", "aString")
  assert.throwsError(assert.isBoolean, "", { "a table" })
  assert.throwsError(assert.isBoolean, "", 10 )
  assert.throwsError(assert.isBoolean, "", function() end)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNotBoolean]

The \type{assert.isNotBoolean} assertion tests a lua object to confirm 
that it is \emph{not} a boolean. 

\startLuaCode
function assert.isNotBoolean(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'boolean',
    aMessage,
    fmt("Expected %s to not be a boolean.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if an object is not a boolean]

We assert directly that various non-boolean objects are not booleans. 

\startLuaTest
  assert.isBoolean("aString")
  assert.isBoolean({ "a table" })
  assert.isBoolean(10 )
  assert.isBoolean(function() end)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if an object is a boolean]

We use \type{assert.throwsError} to test the \type{assert.isBoolean} 
assertion, by passing in various booleans both directly and via variable 
references. 

\startLuaTest
  assert.throwsError(assert.isBoolean, "", true)
  assert.throwsError(assert.isBoolean, "", false)
  local aBoolean = true
  assert.throwsError(assert.isBoolean, "", aBoolean)
  aBoolean = false
  assert.throwsError(assert.isBoolean, "", aBoolean)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isTrue]

\startLuaCode
function assert.isTrue(aBoolean, aMessage)
  return reportLuaAssertion(
    aBoolean,
    aMessage,
    fmt("Expected true, got %s.", toStr(aBoolean))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isFalse]

\startLuaCode
function assert.isFalse(aBoolean, aMessage)
  return reportLuaAssertion(
    not aBoolean,
    aMessage,
    fmt("Expected false, got %s.", toStr(aBoolean))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNil]

\startLuaCode
function assert.isNil(anObj, aMessage)
  return reportLuaAssertion(
    anObj == nil,
    aMessage,
    fmt("Expected nil, got %s.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNotNil]

\startLuaCode
function assert.isNotNil(anObj, aMessage)
  return reportLuaAssertion(
    anObj ~= nil,
    aMessage,
    fmt("Expected non-nil, got %s.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isEqual]

\startLuaCode
function assert.isEqual(anObj, expected, aMessage)
  return reportLuaAssertion(
    anObj == expected,
    aMessage,
    fmt("Expected %s to equal %s.",
      toStr(expected), toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isEqualWithIn]

\startLuaCode
function assert.isEqualWithIn(anObj, expected,
  tolerance, aMessage)
  return reportLuaAssertion(
    true, --????,
    aMessage,
    fmt("Expected %s to equal %s with tolerance %s.",
      toStr(anObj), toStr(expected), toStr(tolerance))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[ssert_isNotEqual]

\startLuaCode
function assert.isNotEqual(anObj, expected, aMessage)
  return reportLuaAssertion(
    anObj ~= expected,
    aMessage,
    fmt("Expected %s to not equal %s.",
      toStr(expected), toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNotEqualWithIn]
\startLuaCode
function assert.isNotEqualWithIn(anObj, expected,
  tolerance, aMessage)
  return reportLuaAssertion(
    true, --????,
    aMessage,
    fmt("Expected %s to not equal %s with tolerance %s.",
      toStr(anObj), toStr(expected), toStr(tolerance))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNumber]

\startLuaCode
function assert.isNumber(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'number',
    aMessage,
    fmt("Expected %s to be a number.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isGT]

\startLuaCode
function assert.isGT(objA, objB, aMessage)
  return reportLuaAssertion(
    objA > objB,
    aMessage,
    fmt("Expected %s > %s.", toStr(objA), toStr(objB))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isGTE]

\startLuaCode
function assert.isGTE(objA, objB, aMessage)
  return reportLuaAssertion(
    objA >= objB,
    aMessage,
    fmt("Expected %s >= %s.", toStr(objA), toStr(objB))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isLT]

\startLuaCode
function assert.isLT(objA, objB, aMessage)
  return reportLuaAssertion(
    objA < objB,
    aMessage,
    fmt("Expected %s < %s.", toStr(objA), toStr(objB))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isLTE]

\startLuaCode
function assert.isLTE(objA, objB, aMessage)
  return reportLuaAssertion(
    objA <= objB,
    aMessage,
    fmt("Expected %s <= %s.", toStr(objA), toStr(objB))
  )
end
\stopLuaCode


\stopTestSuite

\startTestSuite[assert.isNotNumber]

\startLuaCode
function assert.isNotNumber(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'number',
    aMessage,
    fmt("Expected %s to be a number.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isString]

\startLuaCode
function assert.isString(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'string',
    aMessage,
    fmt("Expected [%s] to be a string.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.matches]

\startLuaCode
function assert.matches(anObj, aPattern, aMessage)
  return reportLuaAssertion(
    anObj:matches(aPattern),
    aMessage,
    ftm("Expected [%s] to match [%s].",
      toStr(anObj), toStr(aPattern))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.doesNotMatch]

\startLuaCode
function assert.doesNotMatch(anObj, aPattern, aMessage)
  return reportLuaAssertion(
    not anObj:matches(aPattern),
    aMessage,
    fmt("Expected [%s] to not match [%s].",
      toStr(anObj), toStr(aPattern))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.length]

\startLuaCode
function assert.length(anObj, aLength, aMessage)
  return reportLuaAssertion(
    #anObj == aLength,
    aMessage,
    fmt("Expected %s to have length %s.",
      toStr(anObj), toStr(aMessage))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNotLength]

\startLuaCode
function assert.isNotLength(anObj, aLength, aMessage)
  return reportLuaAssertion(
    #anObj ~= aLength,
    aMessage,
    fmt("Expected %s to not have length %s.",
      toStr(anObj), toStr(aMessage))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNotString]

\startLuaCode
function assert.isNotString(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'string',
    aMessage,
    fmt("Expected [%s] to not be a string.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isTable]

\startLuaCode
function assert.isTable(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'table',
    aMessage,
    fmt("Expected %s to be a table.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.hasKey]

\startLuaCode
function assert.hasKey(anObj, aKey, aMessage)
  return reportLuaAssertion(
    anObj[aKey] ~= nil,
    aMessage,
    fmt("Expected %s to have the key %s.",
      toStr(anObj), toStr(aKey))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.doesNotHaveKey]

\startLuaCode
function assert.doesNotHaveKey(anObj, aKey, aMessage)
  return reportLuaAssertion(
    anObj[aKey] == nil,
    aMessage,
    fmt("Expected %s to not have the key %s.",
      toStr(anObj), toStr(aKey))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNotTable]

\startLuaCode
function assert.isNotTable(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'table',
    aMessage,
    fmt("Expected %s to not be a table.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isFunction]

\startLuaCode
function assert.isFunction(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'function',
    aMessage,
    fmt("Expected %s to be a function.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNotFunction]

\startLuaCode
function assert.isNotFunction(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'function',
    aMessage,
    fmt("Expected %s to not be a function.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isUserData]

\startLuaCode
function assert.isUserData(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'userdata',
    aMessage,
    fmt("Expected %s to be user data.", toStr(anObj))
  )
end
\stopLuaCode
\stopTestSuite

\startTestSuite[assert.isNotUserData]

\startLuaCode
function assert.isNotUserData(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'userdata',
    aMessage,
    fmt("Expected %s to not be user data.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.hasMetaTable]

\startLuaCode
function assert.hasMetaTable(anObj, aMessage)
  return reportLuaAssertion(
    getMetaTable(anObj) ~= nil,
    aMessage,
    fmt("Expected %s to have a meta table.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.metaTableEquals]

\startLuaCode
function assert.metaTableEqual(anObj, aMetaTable, aMessage)
  return reportLuaAssertion(
    getMetaTable(anObj) == aMetaTable,
    aMessage,
    fmt("Expected %s to have the meta table %s.",
      toStr(anObj), toStr(aMetaTable))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.metaTableNotEqual]

\startLuaCode
function assert.metaTableNotEqual(anObj, aMetaTable, aMessage)
  return reportLuaAssertion(
    getMetaTable(anObj) ~= aMetaTable,
    aMessage,
    fmt("Expected %s to not have the meta table %s.",
      toStr(anObj), toStr(aMetaTable))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.doesNotHaveMetaTable]

\startLuaCode
function assert.hasMetaTable(anObj, aMessage)
  return reportLuaAssertion(
    getMetaTable(anObj) == nil,
    aMessage,
    fmt("Expected %s to not have a meta table.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isThread]

\startLuaCode
function assert.isThread(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'thread',
    aMessage,
    fmt("Expected %s to be a thread.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNotThread]

\startLuaCode
function assert.isNotThread(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'thread',
    aMessage,
    fmt("Expected %s to not be a thread.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\stopchapter