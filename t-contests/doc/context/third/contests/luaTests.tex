% A ConTeXt document [master document: contests.tex]

\startchapter[title=Lua Unit Testing]

We make extensive use of ideas in the design of the LunaTest Lua unit 
testing framework which is in turn inspired by the LUnit assertion 
interface. We tailor these ideas for use \emph{inside} \ConTeXt. 

\section[title=Test cases]

% temporarily include this in the main document
% until the actual module files stabilize
\definetyping[LuaTest]
\setuptyping[LuaTest][option=lua]

\startMkIVCode

\definetyping[LuaTest]
\setuptyping[LuaTest][option=lua]

\let\oldStopLuaTest=\stopLuaTest
\def\stopLuaTest{%
  \oldStopLuaTest%
  \directlua{thirddata.contests.addLuaTest('_typing_')}
}

\stopMkIVCode

\startLuaCode

function contests.addLuaTest(bufferName)
  local bufferContents = buffers.getcontent(bufferName):gsub("\13", "\n")
  local suite = tests.curSuite
  local case  = suite.curCase
  case.lua    = case.lua or {}
  table_insert(case.lua, bufferContents)
end

function contests.runCurLuaTestCase()
  local suite    = tests.curSuite
  local case     = suite.curCase
  local luaChunk = table_concat(case.lua, '\n')
  if not luaChunk:match('^%s*$') then
    -- consider using PCall here
    local luaFunc, errMessage = load(luaChunk)
    if luaFunc then
      local result = luaFunc()
    end
  end
end

\stopLuaCode

\section[title=Assertions]

\startLuaCode

local fmt = string.format

function reportLuaAssertion(theCondition, aMessage, theReason)
  -- we do not need to do anything unless theCondition if false!
  if not theCondition then
    local test     = { }
    test.message   = aMessage
    test.reason    = theReason
    test.condition = theCondition
    local info     = debug.getinfo(2,'l')
    test.line      = info.currentline
    error(test, 0) -- throw an error to be captured by an error_handler
  end
end

\stopLuaCode

\startTestSuite[assert_throwsError]

\startLuaCode
function contests.assert_throwsError(aFunction, aMessage, ...)
  local ok, err = pcall(aFunction, ...)
  return reportLuaAssertion(
    ok,
    aMessage,
    fmt("Expected %s to throw an error.", TS(aFunction), TS(err))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_throwsNoError]

\startLuaCode
function contests.assert_throwsNoError(aFunction, aMessage, ...)
  local ok, err = pcall(aFunction, ...)
  return reportLuaAssertion(
    not ok,
    aMessage,
    fmt("Expected %s not to throw an error (%s).", TS(aFunction), TS(err))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_fail]

\startLuaCode
function contests.assert_fail(aMessage)
  return reportLuaAssertion(
    false,
    aMessage,
    "(Failed)"
  )
end
\stopLuaCode

\startTestCase[should fail]

\startLuaTest
  something
\stopLuaTest

\stopTestCase
\stopTestSuite

\startTestSuite[assert_isBoolean]

\startLuaCode
function contests.assert_isBoolean(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'boolean',
    aMessage,
    fmt("Expected %s to be a boolean.", TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isNotBoolean]

\startLuaCode
function contests.assert_isNotBoolean(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'boolean',
    aMessage,
    fmt("Expected %s to not be a boolean.", TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isTrue]

\startLuaCode
function contests.assert_isTrue(aBoolean, aMessage)
  return reportLuaAssertion(
    aBoolean,
    aMessage,
    fmt("Expected true, got %s.", TS(aBoolean))
  )
end
\stopLuaCode

\startTestCase[should succeed]

\startLuaTest
  something else
\stopLuaTest

\stopTestCase
\stopTestSuite

\startTestSuite[assert_isFalse]

\startLuaCode
function contests.assert_isFalse(aBoolean, aMessage)
  return reportLuaAssertion(
    not aBoolean,
    aMessage,
    fmt("Expected false, got %s.", TS(aBoolean))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isNil]

\startLuaCode
function contests.assert_isNil(anObj, aMessage)
  return reportLuaAssertion(
    anObj == nil,
    aMessage,
    fmt("Expected nil, got %s.", TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isNotNil]

\startLuaCode
function contests.assert_isNotNil(anObj, aMessage)
  return reportLuaAssertion(
    anObj ~= nil,
    aMessage,
    fmt("Expected non-nil, got %s.", TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isEqual]

\startLuaCode
function contests.assert_isEqual(anObj, expected, aMessage)
  return reportLuaAssertion(
    anObj == expected,
    aMessage,
    fmt("Expected %s to equal %s.", TS(expected), TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isEqualWithIn]

\startLuaCode
function contests.assert_isEqualWithIn(anObj, expected, tolerance, aMessage)
  return reportLuaAssertion(
    ????,
    aMessage,
    fmt("Expected %s to equal %s with tolerance %s.",
      TS(anObj), TS(expected), TS(tolerance))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[ssert_isNotEqual]

\startLuaCode
function contests.assert_isNotEqual(anObj, expected, aMessage)
  return reportLuaAssertion(
    anObj ~= expected,
    aMessage,
    fmt("Expected %s to not equal %s.", TS(expected), TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isNotEqualWithIn]
\startLuaCode
function contests.assert_isNotEqualWithIn(anObj, expected, tolerance, aMessage)
  return reportLuaAssertion(
    ????,
    aMessage,
    fmt("Expected %s to not equal %s with tolerance %s.",
      TS(anObj), TS(expected), TS(tolerance))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isNumber]

\startLuaCode
function contests.assert_isNumber(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'number',
    aMessage,
    fmt("Expected %s to be a number.", TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isGT]

\startLuaCode
function contests.assert_isGT(objA, objB, aMessage)
  return reportLuaAssertion(
    objA > objB,
    aMessage,
    fmt("Expected %s > %s.", TS(objA), TS(objB))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isGTE]

\startLuaCode
function contests.assert_isGTE(objA, objB, aMessage)
  return reportLuaAssertion(
    objA >= objB,
    aMessage,
    fmt("Expected %s >= %s.", TS(objA), TS(objB))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isLT]

\startLuaCode
function contests.assert_isLT(objA, objB, aMessage)
  return reportLuaAssertion(
    objA < objB,
    aMessage,
    fmt("Expected %s < %s.", TS(objA), TS(objB))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isLTE]

\startLuaCode
function contests.assert_isLTE(objA, objB, aMessage)
  return reportLuaAssertion(
    objA <= objB,
    aMessage,
    fmt("Expected %s <= %s.", TS(objA), TS(objB))
  )
end
\stopLuaCode


\stopTestSuite

\startTestSuite[assert_isNotNumber]

\startLuaCode
function contests.assert_isNotNumber(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'number',
    aMessage,
    fmt("Expected %s to be a number.", TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isString]

\startLuaCode
function contests.assert_isString(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'string',
    aMessage,
    fmt("Expected [%s] to be a string.", TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_matches]

\startLuaCode
function contests.assert_matches(anObj, aPattern, aMessage)
  return reportLuaAssertion(
    anObj:matches(aPattern),
    aMessage,
    ftm("Expected [%s] to match [%s].", TS(anObj), TS(aPattern))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_doesNotMatch]

\startLuaCode
function contests.assert_doesNotMatch(anObj, aPattern, aMessage)
  return reportLuaAssertion(
    not anObj:matches(aPattern),
    aMessage,
    fmt("Expected [%s] to not match [%s].", TS(anObj), TS(aPattern))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_length]

\startLuaCode
function contests.assert_length(anObj, aLength, aMessage)
  return reportLuaAssertion(
    #anObj == aLength,
    aMessage,
    fmt("Expected %s to have length %s.", TS(anObj), TS(aMessage))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isNotLength]

\startLuaCode
function contests.assert_isNotLength(anObj, aLength, aMessage)
  return reportLuaAssertion(
    #anObj ~= aLength,
    aMessage,
    fmt("Expected %s to not have length %s.", TS(anObj), TS(aMessage))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isNotString]

\startLuaCode
function contests.assert_isNotString(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'string',
    aMessage,
    fmt("Expected [%s] to not be a string.", TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isTable]

\startLuaCode
function contests.assert_isTable(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'table',
    aMessage,
    fmt("Expected %s to be a table.", TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_hasKey]

\startLuaCode
function contests.assert_hasKey(anObj, aKey, aMessage)
  return reportLuaAssertion(
    anObj[aKey] ~= nil,
    aMessage,
    fmt("Expected %s to have the key %s.", TS(anObj), TS(aKey))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_doesNotHaveKey]

\startLuaCode
function contests.assert_doesNotHaveKey(anObj, aKey, aMessage)
  return reportLuaAssertion(
    anObj[aKey] == nil,
    aMessage,
    fmt("Expected %s to not have the key %s.", TS(anObj), TS(aKey))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isNotTable]

\startLuaCode
function contests.assert_isNotTable(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'table',
    aMessage,
    fmt("Expected %s to not be a table.", TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isFunction]

\startLuaCode
function contests.assert_isFunction(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'function',
    aMessage,
    fmt("Expected %s to be a function.", TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isNotFunction]

\startLuaCode
function contests.assert_isNotFunction(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'function',
    aMessage,
    fmt("Expected %s to not be a function.", TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isUserData]

\startLuaCode
function contests.assert_isUserData(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'userdata',
    aMessage,
    fmt("Expected %s to be user data.", TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isNotUserData]

\startLuaCode
function contests.assert_isNotUserData(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'userdata',
    aMessage,
    fmt("Expected %s to not be user data.", TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_hasMetaTable]

\startLuaCode
function contests.assert_hasMetaTable(anObj, aMessage)
  return reportLuaAssertion(
    getMetaTable(anObj) ~= nil,
    aMessage,
    fmt("Expected %s to have a meta table.", TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_metaTableEquals]

\startLuaCode
function contests.assert_metaTableEqual(anObj, aMetaTable, aMessage)
  return reportLuaAssertion(
    getMetaTable(anObj) == aMetaTable,
    aMessage,
    fmt("Expected %s to have the meta table %s.", TS(anObj), TS(aMetaTable))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_metaTableNotEqual]

\startLuaCode
function contests.assert_metaTableNotEqual(anObj, aMetaTable, aMessage)
  return reportLuaAssertion(
    getMetaTable(anObj) ~= aMetaTable,
    aMessage,
    fmt("Expected %s to not have the meta table %s.", TS(anObj), TS(aMetaTable))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_doesNotHaveMetaTable]

\startLuaCode
function contests.assert_hasMetaTable(anObj, aMessage)
  return reportLuaAssertion(
    getMetaTable(anObj) == nil,
    aMessage,
    fmt("Expected %s to not have a meta table.", TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isThread]

\startLuaCode
function contests.assert_isThread(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'thread',
    aMessage,
    fmt("Expected %s to be a thread.", TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert_isNotThread]

\startLuaCode
function contests.assert_isNotThread(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'thread',
    aMessage,
    fmt("Expected %s to not be a thread.", TS(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\stopchapter