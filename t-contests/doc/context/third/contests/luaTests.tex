% A ConTeXt document [master document: contests.tex]

\startchapter[title=Lua Unit Testing]

We make extensive use of ideas in the design of the LunaTest Lua unit 
testing framework which is in turn inspired by the LUnit assertion 
interface. We tailor these ideas for use \emph{inside} \ConTeXt. 

\section[title=Test cases]

\startMkIVCode

\definetyping[LuaTest]
\setuptyping[LuaTest][option=lua]

\let\oldStopLuaTest=\stopLuaTest
\def\stopLuaTest{%
  \oldStopLuaTest%
  \directlua{thirddata.contests.addLuaTest('_typing_')}
}

\stopMkIVCode

\startLuaCode

function contests.addLuaTest(bufferName)
  local bufferContents = buffers.getcontent(bufferName):gsub("\13", "\n")
  local suite = tests.curSuite
  local case  = suite.curCase
  case.lua    = case.lua or {}
  table_insert(case.lua, bufferContents)
end

function contests.runCurLuaTestCase()
  local suite    = tests.curSuite
  local case     = suite.curCase
  local luaChunk = table_concat(case.lua, '\n')
  if not luaChunk:match('^%s*$') then
    luaChunk = [=[
    local assert = thirddata.contests.assert
    ]=]..luaChunk
    -- consider using PCall here
    local luaFunc, errMessage = load(luaChunk)
    if luaFunc then
      --local result = luaFunc()
    end
  end
end

\stopLuaCode

\section[title=Assertions]

We start by defining a helper function to capture the repetitive code in 
one place. Every assertion will contain a condition, a message and some 
reason for failing the assertion. The \type{reportLuaAssertion} function 
captures these three values and builds an assertion result \emph{if} the 
condition is false. If the condition is true, the 
\type{reportLuaAssertion} function quietly does nothing but update the 
test statistics. 

\startLuaCode
function reportLuaAssertion(theCondition, aMessage, theReason)
  -- we do not need to do anything unless theCondition if false!
  if not theCondition then
    local test     = { }
    test.message   = aMessage
    test.reason    = theReason
    test.condition = theCondition
    local info     = debug.getinfo(2,'l')
    test.line      = info.currentline
    error(test, 0) -- throw an error to be captured by an error_handler
  end
end
\stopLuaCode

Since all of the assertions will use the standard lua \type{string.format} 
function to format the various reasons using information specific to each 
assertion, we make \type{string.format} local with a shorter name. For 
efficiency we also make the lua global \type{tostring} a local with the 
shorter name \type{toStr}. 

\startLuaCode
local fmt   = string.format
local toStr = tostring
\stopLuaCode

Having defined both the \type{reportLuaAssertion} and the \type{fmt} 
functions, we now work through each assertion in turn. For each assertion, 
we begin by defining the lua code which implements the assertion, and then 
the test cases which verify the assertion is working correctly. Typically 
there will be two test cases for each assertion, we need to test both the 
positive and negative conditions. 

\startTestSuite[assert.throwsError]

In order to test if a lua function throws an error, we need to wrap the 
actual function call (together with its arguments) in a lua \type{pcall}. 
The return value of this \type{pcall} is then checked to see if an error 
was thrown. 

It is critical to point out that since lua passes all parameters by 
\emph{value}, the \type{assert.throwsError} parameters consist of the 
\emph{function} to be tested, any message you want reported if the 
function \emph{does not throw} any errors, as well as (and these are the 
\quote{\type{...}}) any arguments. \emph{If} you pass the \emph{result} of 
calling the function on its arguments as the first parameter of this 
assertion, then any error that this function throws will be thrown 
\emph{before} the assertion can catch the error. 

\startLuaCode
function assert.throwsError(aFunction, aMessage, ...)
  local ok, err = pcall(aFunction, ...)
  return reportLuaAssertion(
    not ok,
    aMessage,
    fmt("Expected %s to throw an error.", toStr(aFunction))
  )
end
\stopLuaCode

There are two cases we need to test.

\startTestCase[should succeed if error thrown]

In this first test case, we want to make sure if the tested function 
throws an error then the assertion succeeds.

Note that the function being tested: 

\starttyping[option=lua]
function()
  error("this 'inner' function throws an error!")
end
\stoptyping

\noindent does \emph{not} accept any arguments. However it is important to 
notice that it is the \emph{function} that is being passed into the 
\type{assert.throwsError} and not the \emph{value} of calling this 
function. The actual function call is delayed and happens \emph{inside} 
the assertion. 

\startLuaTest
  assert.throwsError(function()
    error("this 'inner' function throws an error!")
  end)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if no error thrown]

In this second test case, we want to make sure the assertion \emph{fails} 
if the tested function \emph{does not} throw an error.

For this test case, we are \emph{using} the \type{assert.throwsError} 
function to \emph{test} itself. This means that we \emph{must} pass the 
assertion function, \type{assert.throwsError} as the first argument. We 
must then pass a message (in this case an empty string), together with the 
argument to the \quote{inner} \type{assert.throwsError} function which is 
the \quote{null-function}: 

\starttyping[option=lua]
function() end
\stoptyping

\noindent We do this to ensure that the \quote{outer} 
\type{assert.throwsError} function can capture the error that the 
\quote{inner} \type{assert.throwsError} will throw since the most 
\quote{inner} nested function itself throws no error. 

\startLuaTest
  assert.throwsError(assert.throwsError, "", function() end)
\stopLuaTest
\stopTestCase

\stopTestSuite


\startTestSuite[assert.throwsNoError]

The assertion \type{assert.throwsError}, detailed above, asserts that the 
tested function throws an error. We also need the ability to assert that a 
given function \emph{does not} throw an error. That is the purpose of the 
\type{assert.throwsNoError} assertion. Like the \type{assert.throwsError} 
assertion, the \type{assert.throwsNoError} assertion, wraps the function 
call to be tested in a lua \type{pcall}. This means that the 
\type{assert.throwsNoError} assertion's first parameter is the function to 
be tested, followed by any message to be used if the function \emph{does} 
throw an error, followed in turn by any arguments required by the function 
to be tested. 

\startLuaCode
function assert.throwsNoError(aFunction, aMessage, ...)
  local ok, err = pcall(aFunction, ...)
  return reportLuaAssertion(
    ok,
    aMessage,
    fmt("Expected %s not to throw an error (%s).",
      toStr(aFunction), toStr(err))
  )
end
\stopLuaCode

Again we have two cases we need to test.

\startTestCase[should succeed if no error thrown]

In this test case, we pass in a function which throws no error and expect 
the assertion to succeed. 

\startLuaTest
  assert.throwsNoError(function() end)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if an error is thrown]

As above, we use the \type{assert.throwsError} assertion to \emph{test} 
the \type{assert.throwsNoError} function. This means we must pass in the 
\type{assert.throwsNoError} function as the first parameter to the 
\quote{outer} \type{assert.throwsError} function, followed by an (in this 
case) empty message, followed by the function which is going to be tested 
by the \type{assert.throwsNoError} function. Note that the 
\quote{inner-most} function \emph{does} throw an error. 

\startLuaTest
  assert.throwsError(assert.throwsNoError, "", function()
    error("this 'inner-most' function throws an error!")
  )
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.fail]

The \type{assert.fail} assertion always fails, and hence stops all further 
testing of a given test case. This can be useful while developing complex 
test cases. The whole test case can be sketched out, but only the 
assertions up to the \type{assert.fail} assertion will be tested. 

\startLuaCode
function assert.fail(aMessage)
  return reportLuaAssertion(
    false,
    aMessage,
    "(Failed)"
  )
end
\stopLuaCode

\startTestCase[should always fail]

There is only one test case, this assertion should always fail.

\startLuaTest
  assert.throwsError(assert.fail, "")
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isBoolean]

The \type{assert.isBoolean} assertion tests a lua object to confirm that 
it is a boolean. 

\startLuaCode
function assert.isBoolean(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'boolean',
    aMessage,
    fmt("Expected %s to be a boolean.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if an object is a boolean]

The \type{assert.isBoolean} assertion should succeed if an object is a 
boolean. The boolean should be able to be passed in either directly or 
inside a variable reference. 

\startLuaTest
  assert.isBoolean(true)
  assert.isBoolean(false)
  local aBoolean = true
  assert.isBoolean(aBoolean)
  aBoolean = false
  assert.isBoolean(aBoolean)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if an object is not a boolean]

We use the \type{assert.throwsError} assertion to test the failure of the 
\type{assert.isBoolean} assertion. To do this we pass in various different 
lua objects, none of which are booleans. 

\startLuaTest
  assert.throwsError(assert.isBoolean, "", "aString")
  assert.throwsError(assert.isBoolean, "", { "a table" })
  assert.throwsError(assert.isBoolean, "", 42 )
  assert.throwsError(assert.isBoolean, "", function() end)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNotBoolean]

The \type{assert.isNotBoolean} assertion tests a lua object to confirm 
that it is \emph{not} a boolean. 

\startLuaCode
function assert.isNotBoolean(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'boolean',
    aMessage,
    fmt("Expected %s to not be a boolean.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if an object is not a boolean]

We assert directly that various non-boolean objects are not booleans. 

\startLuaTest
  assert.isNotBoolean("aString")
  assert.isNotBoolean({ "a table" })
  assert.isNotBoolean(42 )
  assert.isNotBoolean(function() end)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if an object is a boolean]

We use \type{assert.throwsError} to test the \type{assert.isBoolean} 
assertion, by passing in various booleans both directly and via variable 
references. 

\startLuaTest
  assert.throwsError(assert.isNotBoolean, "", true)
  assert.throwsError(assert.isNotBoolean, "", false)
  local aBoolean = true
  assert.throwsError(assert.isNotBoolean, "", aBoolean)
  aBoolean = false
  assert.throwsError(assert.isNotBoolean, "", aBoolean)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isTrue]

The \type{assert.isTrue} assertion tests a lua object to confirm that it 
is not either \type{false} or \type{nil} (which represents \quote{truth} 
in lua). 

\startLuaCode
function assert.isTrue(aBoolean, aMessage)
  return reportLuaAssertion(
    aBoolean,
    aMessage,
    fmt("Expected true, got %s.", toStr(aBoolean))
  )
end
\stopLuaCode

\startTestCase[should succeed if a boolean is true]

We test various lua objects which are neither \type{false} nor \type{nil}. 

\startLuaTest
  assert.isTrue(true)
  assert.isTrue("aString")
  assert.isTrue({ "aTable" })
  assert.isTrue(42)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if a boolean is false]

We test both \type{false} and \type{nil} to show they are not 
\quote{true}. 

\startLuaTest
  assert.throwsError(assert.isTrue, "", false)
  assert.throwsError(assert.isTrue, "", nil)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isFalse]

The \type{assert.isFalse} assertion tests a lua object to confirm that it 
is either \type{false} or \type{nil}. 

\startLuaCode
function assert.isFalse(aBoolean, aMessage)
  return reportLuaAssertion(
    not aBoolean,
    aMessage,
    fmt("Expected false, got %s.", toStr(aBoolean))
  )
end
\stopLuaCode

\startTestCase[should succeed if a boolean is false]

We test both \type{false} and \type{nil} to show that they are 
\quote{false}. 

\startLuaTest
  assert.isFalse(false)
  assert.isFalse(nil)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if a boolean is true]

We test various objects to show that they are not \quote{false}.

\startLuaTest
  assert.throwsError(assert.isFalse, "", true)
  assert.throwsError(assert.isFalse, "", "aString")
  assert.throwsError(assert.isFalse, "", { "aTable" })
  assert.throwsError(assert.isFalse, "", 42)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNil]

The \type{assert.isNil} assertion tests a lua object to confirm that it is 
\type{nil}. 

\startLuaCode
function assert.isNil(anObj, aMessage)
  return reportLuaAssertion(
    anObj == nil,
    aMessage,
    fmt("Expected nil, got %s.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if an object is nil]

We test \type{nil} to show that it is \type{nil}. 

\startLuaTest
  assert.isNil(nil)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if an object is not nil]

We test various non \type{nil} objects to show that they are not 
\type{nil}. 

\startLuaTest
  assert.throwsError(assert.isNil, "", true)
  assert.throwsError(assert.isNil, "", "aString")
  assert.throwsError(assert.isNil, "", { "aTable" })
  assert.throwsError(assert.isNil, "", 42)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNotNil]

The \type{assert.isNotNil} assertion tests a lua object to confirm that is 
it not \type{nil}. 

\startLuaCode
function assert.isNotNil(anObj, aMessage)
  return reportLuaAssertion(
    anObj ~= nil,
    aMessage,
    fmt("Expected non-nil, got %s.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if an object is not nil]

We test various lua objects which are not \type{nil}.

\startLuaTest
  assert.isNotNil(true)
  assert.isNotNil("aString")
  assert.isNotNil({ "aTable" })
  assert.isNotNil(42)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if an object is nil]

We test \type{nil}.

\startLuaTest
  assert.throwsError(assert.isNotNil, "", nil)
\stopLuaTest
\stopTestSuite

\startTestSuite[assert.isEqual]

The \type{assert.isEqual} assertion tests two lua objects to confirm that 
they are equal (\type{==}) as far as lua is concerned. 

\startLuaCode
function assert.isEqual(objA, objB, aMessage)
  return reportLuaAssertion(
    objA == objB,
    aMessage,
    fmt("Expected %s to equal %s.",
      toStr(objA), toStr(objB))
  )
end
\stopLuaCode

\startTestCase[should succeed if the two objects are equal]

We test various pairs of objects to show that they are equal.

\startLuaTest
  assert.isEqual(true, true)
  assert.isEqual("aString", "aString")
  assert.isEqual({ "aTable" }, { "aTable" })
  assert.isEqual(42, (40+2))
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the two objects are not equal]

We test various pairs of objects to show that they are not equal. 

\startLuaTest
  assert.throwsError(assert.isEqual, "", true, false)
  assert.throwsError(assert.isEqual, "",
    "aString", "anotherString")
  assert.throwsError(assert.isEqual, "",
    { "aTable" }, { "aDifferentTable"})
  assert.throwsError(assert.isEqual, "", 42, 0)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isEqualWithIn]

The \type{assert.isEqualWithIn} assertion only applies to numbers.

\startLuaCode
function assert.isEqualWithIn(numA, numB,
  tolerance, aMessage)
  return reportLuaAssertion(
    type(numA) == 'number' and type(numB) == 'number'
    and math.abs(numA - numB) <= tolerance,
    aMessage,
    fmt("Expected %s to equal %s with tolerance %s.",
      toStr(numA), toStr(numB), toStr(tolerance))
  )
end
\stopLuaCode

\startTestCase[should succeed if numA and numB are within tolerance]

We test various pairs of number all closer than tolerance. 

\startLuaTest
  assert.isEqualWithIn(42, 41, 2)
  assert.isEqualWithIn(42, 41, 1)
  assert.isEqualWithIn(0.5, 0.4, 0.2)
  assert.isEqualWithIn(41, 42, 2)
  assert.isEqualWithIn(0.4, 0.5, 0.2)
  assert.isEqualWithIn(0.4, 0.4, 0.1)
  assert.isEqualWithIn(0.3, 0.3, 0.0)
  assert.isEqualWithIn(-41, -42, 2)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if numA or numB are not numbers]

We confirm that \type{assert.isEqualWithIn} throws an error if either 
\type{numA} nor \type{numB} are \emph{not} numbers.

\startLuaTest
  assert.throwsError(assert.isEqualWithIn, "", "aString", 42, 10)
  assert.throwsError(assert.isEqualWithIn, "", 42, "aString", 10)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if numA and numB are not closer than tolerance]

We confirm that \type{assert.isEqualWithIn} throws an error if \type{numA} 
and \type{numB} are two numbers which are not closer than 
\type{tolerance}. 

\startLuaTest
  assert.throwsError(assert.isEqualWithIn, "", 42, 45, 1)
  assert.throwsError(assert.isEqualWithIn, "", 0.4, 0.9, 0.2)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert_isNotEqual]

The \type{assert.isNotEqual} assertion tests two lua objects to confirm 
that they are not equal (\type{~=}) as far as lua is concerned. 

\startLuaCode
function assert.isNotEqual(objA, objB, aMessage)
  return reportLuaAssertion(
    objA ~= objB,
    aMessage,
    fmt("Expected %s to not equal %s.",
      toStr(objA), toStr(objB))
  )
end
\stopLuaCode

\startTestCase[should succeed if the two objects are not equal]

We test using various pairs of unequal objects.

\startLuaTest
  assert.isNotEqual(42, 41)
  assert.isNotEqual("aString", "anotherString")
  assert.isNotEqual({ "aTable" }, { "aDifferentTable"})
  assert.isNotEqual(42, "aString")
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the two objects are equal]

We test using various pairs of equal objects.

\startLuaTest
  assert.throwsError(assert.isNotEqual, "", 42, 42)
  assert.throwsError(assert.isNotEqual, "", "aString", "aString")
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNotEqualWithIn]

The \type{assert.isNotEqualWithIn} assertion confirms that two objects are 
either neither numbers, or they are further apart then the given 
\type{tolerance}. 

\startLuaCode
function assert.isNotEqualWithIn(numA, numB, tolerance, aMessage)
  return reportLuaAssertion(
    type(numA) ~= 'number' or type(numB) ~= 'number'
    or tolerance < math.abs(numA - numB), 
    aMessage,
    fmt("Expected %s to not equal %s with tolerance %s.",
      toStr(numA), toStr(numB), toStr(tolerance))
  )
end
\stopLuaCode

\startTestCase[should succeed if either object is not a number]

We test using various pairs of objects of which at least one is not a 
number. 

\startLuaTest
  assert.isNotEqualWithIn("aString", "aString", 10)
  assert.isNotEqualWithIn("aString", 42, 10)
\stopLuaTest
\stopTestCase

\startTestCase[should succeed if the two numbers are far apart]

We test using two numbers which are further than \type{tolerance} apart. 

\startLuaTest
  assert.isNotEqualWithIn(42, 45, 2)
  assert.isNotEqualWithIn(-42, -45, 2)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the two numbers are with in tolerance]

We test using two numbers which are closer than \type{tolerance}. 

\startLuaTest
  assert.throwsError(assert.isNotEqualWithIn, "", 42, 41, 2)
  assert.throwsError(assert.isNotEqualWithIn, "", -41, -42, 2)
  assert.throwsError(assert.isNotEqualWithIn, "", 0.5, 0.4, 0.3)
\stopLuaTest
\stopTestSuite

\startTestSuite[assert.isNumber]

The \type{assert.isNumber} assertion confirms that the lua object is a 
number. 

\startLuaCode
function assert.isNumber(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'number',
    aMessage,
    fmt("Expected %s to be a number.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object is a number]

We test using various numbers.

\startLuaTest
  assert.isNumber(42)
  assert.isNumber(4.2)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is not a number]

We test using various objects which are not numbers. 

\startLuaTest
  assert.throwsError(assert.isNumber, "", "aString")
  assert.throwsError(assert.isNumber, "", { "aTable" })
  assert.throwsError(assert.isNumber, "", function() end)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isGT]

The \type{assert.isGT} assertion confirms that \type{objA} is greater than 
\type{objB}. 

\startLuaCode
function assert.isGT(objA, objB, aMessage)
  return reportLuaAssertion(
    objA > objB,
    aMessage,
    fmt("Expected %s > %s.", toStr(objA), toStr(objB))
  )
end
\stopLuaCode

\startTestCase[when both objects are numbers]

We test various pairs of objects which are both numbers.

We start by considering pairs for which \type{objA} is greater than 
\type{objB}. 

\startLuaTest
  assert.isGT(42, 41)
  assert.isGT(0.3, 0.2)
  assert.isGt(5, -3)
\stopLuaTest

We now consider pairs for which \type{objA} is less than or equal to 
\type{objB}. 

\startLuaTest
  assert.throwsError(assert.isGT, "", 41, 42)
  assert.throwsError(assert.isGT, "", 42, 42)
  assert.throwsError(assert.isGT, "", 0.4, 0.9)
\stopLuaTest
\stopTestCase

\startTestCase[when both objects are strings]

We test various pairs of strings.

We start by considering pairs for which \type{objA} is lexically greater 
than \type{objB}. 

\startLuaTest
  assert.isGT("aString02", "aString01")
  assert.isGT("222", "211")
\stopLuaTest

We now consider pairs for which \type{objA} is lexically less than or 
equal to \type{objB}. 

\startLuaTest
  assert.throwsError(assert.isGT, "", "aString", "aString")
  assert.throwsError(assert.isGT, "", "211", "222")
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isGTE]

The \type{assert.isGTE} assertion confirms that \type{objA} is greater 
than or equal to \type{objB}. 

\startLuaCode
function assert.isGTE(objA, objB, aMessage)
  return reportLuaAssertion(
    objA >= objB,
    aMessage,
    fmt("Expected %s >= %s.", toStr(objA), toStr(objB))
  )
end
\stopLuaCode

\startTestCase[when both objects are numbers]

We consider the case when both objects are numbers.

We start by considering the case when \type{objA} is greater than or equal 
to \type{objB}. 

\startLuaTest
  assert.isGTE(42, 42)
  assert.isGTE(43, 42)
  assert.isGTE(0.3, 0.3)
  assert.isGTE(0.3, 0.2)
  assert.isGTE(0.3, -0.2)
\stopLuaTest

Now we consider the case when \type{objA} is less than \type{objB}. 

\startLuaTest
  assert.throwsError(assert.isGTE, "", 42, 43)
  assert.throwsError(assert.isGTE, "", 0.2, 0.3)
  assert.throwsError(assert.isGTE, "", -0.2, 0.3)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isLT]

The \type{assert.isLT} assertion confirms that \type{objA} is less than 
\type{objB}. 

\startLuaCode
function assert.isLT(objA, objB, aMessage)
  return reportLuaAssertion(
    objA < objB,
    aMessage,
    fmt("Expected %s < %s.", toStr(objA), toStr(objB))
  )
end
\stopLuaCode

\startTestCase[when both objects are numbers]

We consider the case when both objects are numbers.

We test various pairs of numbers for which \type{objA} is less than 
\type{objB}. 

\startLuaTest
  assert.isLT(42, 45)
  assert.isLT(0.2, 0.3)
  assert.isLT(42, 42.5)
  assert.isLT(-42, 42)
\stopLuaTest

Now we test various pairs of numbers for which \type{objA} is greater than 
or equal to \type{objB}. 

\startLuaTest
  assert.throwsError(assert.isLT, "", 45, 42)
  assert.throwsError(assert.isLT, "", 42, 42)
  assert.throwsError(assert.isLT, "", 0.3, 0.2)
  assert.throwsError(assert.isLT, "", 0.3, 0.3)
\stopLuaTest
\stopTestCase

\startTestCase[when both objects are strings]

We consider the case when both objects are strings. 

We start by testing various pairs of strings where \type{objA} is 
lexically less than \type{objB}. 

\startLuaTest
  assert.isLT("aStringA", "aStringB")
  assert.isLT("211", "222")
\stopLuaTest

Now we considers pairs where \type{objA} is lexically greater than or 
equal to \type{objB}. 

\startLuaTest
  assert.throwsError(assert.isLT, "", "aString", "aString")
  assert.throwsError(assert.isLT, "", "aStringB", "aStringA")
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isLTE]

The \type{assert.isLTE} assertion confirms that type{objA} is less than or 
equal to \type{objB}. 

\startLuaCode
function assert.isLTE(objA, objB, aMessage)
  return reportLuaAssertion(
    objA <= objB,
    aMessage,
    fmt("Expected %s <= %s.", toStr(objA), toStr(objB))
  )
end
\stopLuaCode


\startTestCase[when both objects are numbers]

We consider the case when both objects are numbers. 

We start by testing various pairs where \type{objA} is less than or equal 
to \type{objB}. 

\startLuaTest
  assert.isLTE(42, 42)
  assert.isLTE(41, 42)
  assert.isLTE(0.3, 0.3)
  assert.isLTE(0.2, 0.3)
\stopLuaTest

Now we consider pairs where \type{objA} is greater than \type{objB}. 

\startLuaTest
  assert.throwsError(assert.isLTE, "", 43, 42)
  assert.throwsError(assert.isLTE, "", 0.3, 0.2)
\stopLuaTest
\stopTestCase

\startTestCase[when both objects are strings]

We consider the case when both objects are strings.

We start by testing various pairs where \type{objA} is lexically less than 
or equal to \type{objB}. 

\startLuaTest
  assert.isLTE("aString", "aString")
  assert.isLTE("aStringA", "aStringB")
\stopLuaTest

Now we consider pairs where \type{objA} is lexically greater than 
\type{objB}. 

\startLuaTest
  assert.throwsError(assert.isLTE, "", "aStringB", "aStringA")
\stopLuaTest

\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNotNumber]

The \type{assert.isNotNumber} assertions confirms that a lua object is not 
a number. 

\startLuaCode
function assert.isNotNumber(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'number',
    aMessage,
    fmt("Expected %s to be a number.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object is not a number]

We test using various objects which are not numbers. 

\startLuaTest
  assert.isNotNumber("aString")
  assert.isNotNumber({ "aTable" })
  assert.isNotNumber(function() end)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is a number]

We test using various numbers.

\startLuaTest
  assert.throwsError(assert.isNotNumber, "", 42)
  assert.throwsError(assert.isNotNumber, "", 4.2)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isString]

The \type{assert.isString} assertion confirms that the object is a string. 

\startLuaCode
function assert.isString(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'string',
    aMessage,
    fmt("Expected [%s] to be a string.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeeed if the object is a string]

We test using various strings.

\startLuaTest
  assert.isString("aString")
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is not a string]

We test using various objects which are not strings. 

\startLuaTest
  assert.throwsError(assert.isString, "", 42)
  assert.throwsError(assert.isString, "", { "aTable" })
  assert.throwsError(assert.isString, "", function() end)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.matches]

The \type{assert.matches} assertion confirms that the object is both a 
string and that it matches the given pattern, using lua's pattern matching 
tools. 

\startLuaCode
function assert.matches(anObj, aPattern, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'string' and type(aPattern) == 'string' 
    and anObj:matches(aPattern),
    aMessage,
    ftm("Expected [%s] to match [%s].",
      toStr(anObj), toStr(aPattern))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object matches the pattern]

We use various strings which match the provided patterns. 

\startLuaTest
  assert.matches("this is a test", "test")
  assert.matches("this is a test", "[ ]*")
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is not a string]

We test using objects which are not strings.

\startLuaTest
  assert.throwsError(assert.matches, "", 42, "[ ]*")
  assert.throwsError(assert.matches, "",
    "this is a test", 42)
\stopLuaTest
\stopTestCase

\startTestCase[should faile if the string does not match the pattern]

We test using a string which does not match the pattern.

\startLuaTest
  assert.throwsError(assert.matches, "", 
    "this is a test", "  ") -- does not have two spaces
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.doesNotMatch]

The \type{assert.doesNotMatch} assertion confirms that one of the object 
or pattern are not strings, or that the object does not match the pattern. 

\startLuaCode
function assert.doesNotMatch(anObj, aPattern, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'string' or type(aPattern) ~= 'string' 
    or not anObj:matches(aPattern),
    aMessage,
    fmt("Expected [%s] to not match [%s].",
      toStr(anObj), toStr(aPattern))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object does not match the pattern]

We use various strings which do not match the associated pattern. 

\startLuaTest
  assert.doesNotMatch("this is a test", "  ") -- two spaces
  assert.doesNotMatch("this is a test", "something")
  assert.doesNotMatch("this is a test", "^ ")
\stopLuaTest
\stopTestCase

\startTestCase[should fail if either the object or pattern are not strings]

We consider the case where either the object or pattern are not strings. 

\startLuaTest
  assert.throwsError(assert.doesNotMatch, "", 42, "[ ]")
  assert.throwsError(assert.doesNotMatch, "",
    "this is a test", 42)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the string does not match the pattern]

We consider the case where the string does match the pattern.

\startLuaTest
  assert.throwsError(assert.doesNotMatch, "", "this is a test", "test")
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.length]

The \type{assert.length} assertion confirms that the string or array have 
the specified length. 

\startLuaCode
function assert.length(anObj, aLength, aMessage)
  return reportLuaAssertion(
    #anObj == aLength,
    aMessage,
    fmt("Expected %s to have length %s.",
      toStr(anObj), toStr(aMessage))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object's length is correct]

We consider the case where the string or array have the specified length. 

\startLuaTest
  assert.length("this", 4)
  assert.length({ "1", "2"}, 2)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object does not have the correct length]

We consider the case where the string, array or object do not have the 
specified length. 

\startLuaTest
  assert.throwsError(assert.length, "", "this", 3)
  assert.throwsError(assert.length, "", { "1", "2" }, 5)
  assert.throwsError(assert.length, "", 42, 2)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNotLength]

The \type{assert.isNotLength} assertion confirms that the object does not 
have the specified length. 

\startLuaCode
function assert.isNotLength(anObj, aLength, aMessage)
  return reportLuaAssertion(
    #anObj ~= aLength,
    aMessage,
    fmt("Expected %s to not have length %s.",
      toStr(anObj), toStr(aMessage))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object does not have the correct length]

We consider the case where the string or array does not have the specified 
length.

\startLuaTest
  assert.isNotLength("this", 2)
  assert.isNotLength({ "1", "2" }, 1)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object has the correct length]

We consider the case where the string or array has the specified length. 

\startLuaTest
  assert.throwsError(assert.isNotLength, "", "this", 4)
  assert.throwsError(assert.isNotLength, "", { "1", "2" }, 2)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is not a string or array]

We consider objects which are not strings or arrays.

\startLuaTest
  assert.throwsError(assert.isNotLength, "", 42, 2)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNotString]

The \type{assert.isNotString} assertion confirms that the object is not a 
string. 

\startLuaCode
function assert.isNotString(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'string',
    aMessage,
    fmt("Expected [%s] to not be a string.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object is not a string]

We consider various objects which are not strings.

\startLuaTest
  assert.isNotString(42)
  assert.isNotString({ "aTable" })
  assert.isNotString(function() end)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is a string]

We consider various strings.

\startLuaTest
  assert.throwsError(assert.isNotString, "", "aString")
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isTable]

The \type{assert.isTable} assertion confirms that the object is a lua 
table. 

\startLuaCode
function assert.isTable(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'table',
    aMessage,
    fmt("Expected %s to be a table.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object is a table]

We consider various lua tables.

\startLuaTest
  assert.isTable({ })
  assert.isTable({ "1", "2" })
  assert.isTable({ one = "one", two = "two" })
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is not a table]

We consider various objects which are not tables. 

\startLuaTest
  assert.throwsError(assert.isTable, "", "aString")
  assert.throwsError(assert.isTable, "", 42)
  assert.throwsError(assert.isTable, "", function() end)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.hasKey]

The \type{assert.hasKey} assertion confirms that the given table has the 
key provided. 

\startLuaCode
function assert.hasKey(anObj, aKey, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'table' and anObj[aKey] ~= nil,
    aMessage,
    fmt("Expected %s to have the key %s.",
      toStr(anObj), toStr(aKey))
  )
end
\stopLuaCode

\startTestCase[should succeed if the table has the key]

We consider various tables and key combinations.

\startLuaTest
  assert.hasKey({ oneKey = "oneValue" }, "oneKey"})
  assert.hasKey({ "1", "2" }, 1)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the table does not have the key]

We consider keys which are not contained in the given table. 

\startLuaTest
  assert.throwsError(assert.hasKey, "",
    { oneKey = "oneValue" }, "twoKey")
  assert.throwsError(assert.hasKey, "",
    { "1", "2" }, 10)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is not a table]

We consider objects which are not tables.

\startLuaTest
  assert.throwsError(assert.hasKey, "", 42, 1)
  assert.throwsError(assert.hasKey, "", "aString", 2)
  assert.throwsError(assert.hasKey, "", function() end, 3)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.doesNotHaveKey]

The \type{assert.doesNotHaveKey} assertion confirms that either the object 
is not a table, or that the table does not have the key. 

\startLuaCode
function assert.doesNotHaveKey(anObj, aKey, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'table' and anObj[aKey] == nil,
    aMessage,
    fmt("Expected %s to not have the key %s.",
      toStr(anObj), toStr(aKey))
  )
end
\stopLuaCode

\startTestCase[should succeed if the table does not have the key]

We consider keys which are not contained in the given lua table.

\startLuaTest
  assert.doesNotHaveKey({ oneKey = "oneValue" }, "twoKey")
  assert.doesNotHaveKey({ "1", "2" }, 10)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the table has the key]

We consider keys which are contained in the given lua table.

\startLuaTest
  assert.throwsError(assert.doesNotHaveKey, "",
    { oneKey = "oneValue" }, "oneKey")
  assert.throwsError(assert.doesNotHaveKey, "",
    { "1", "2" }, 1)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is not a table]

We consider objects which are not lua tables.

\startLuaTest
  assert.throwsError(assert.doesNotHaveKey, "", 42, 2)
  assert.throwsError(assert.doesNotHaveKey, "", "aString", 2)
  assert.throwsError(assert.doesNotHaveKey, "",
    function() end, 2)
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isNotTable]

The \type{assert.isNotTable} assertion confirms that the object is not a 
lua table. 

\startLuaCode
function assert.isNotTable(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'table',
    aMessage,
    fmt("Expected %s to not be a table.", toStr(anObj))
  )
end
\stopLuaCode

\startTestCase[should succeed if the object is not a table]

We consider various objects which are not lua tables.

\startLuaTest
  assert.isNotTable(42)
  assert.isNotTable("aString")
  assert.isNotTable(function() end)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if the object is a table]

We consider various tables.

\startLuaTest
  assert.throwsError(assert.isNotTable, "", { "1", "2" })
  assert.throwsError(assert.isNotTable, "", { oneKey = "oneValue" })
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[assert.isFunction]

\startLuaCode
function assert.isFunction(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'function',
    aMessage,
    fmt("Expected %s to be a function.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNotFunction]

\startLuaCode
function assert.isNotFunction(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'function',
    aMessage,
    fmt("Expected %s to not be a function.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isUserData]

\startLuaCode
function assert.isUserData(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'userdata',
    aMessage,
    fmt("Expected %s to be user data.", toStr(anObj))
  )
end
\stopLuaCode
\stopTestSuite

\startTestSuite[assert.isNotUserData]

\startLuaCode
function assert.isNotUserData(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'userdata',
    aMessage,
    fmt("Expected %s to not be user data.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.hasMetaTable]

\startLuaCode
function assert.hasMetaTable(anObj, aMessage)
  return reportLuaAssertion(
    getMetaTable(anObj) ~= nil,
    aMessage,
    fmt("Expected %s to have a meta table.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.metaTableEquals]

\startLuaCode
function assert.metaTableEqual(anObj, aMetaTable, aMessage)
  return reportLuaAssertion(
    getMetaTable(anObj) == aMetaTable,
    aMessage,
    fmt("Expected %s to have the meta table %s.",
      toStr(anObj), toStr(aMetaTable))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.metaTableNotEqual]

\startLuaCode
function assert.metaTableNotEqual(anObj, aMetaTable, aMessage)
  return reportLuaAssertion(
    getMetaTable(anObj) ~= aMetaTable,
    aMessage,
    fmt("Expected %s to not have the meta table %s.",
      toStr(anObj), toStr(aMetaTable))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.doesNotHaveMetaTable]

\startLuaCode
function assert.hasMetaTable(anObj, aMessage)
  return reportLuaAssertion(
    getMetaTable(anObj) == nil,
    aMessage,
    fmt("Expected %s to not have a meta table.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isThread]

\startLuaCode
function assert.isThread(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'thread',
    aMessage,
    fmt("Expected %s to be a thread.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNotThread]

\startLuaCode
function assert.isNotThread(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'thread',
    aMessage,
    fmt("Expected %s to not be a thread.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\stopchapter