% A ConTeXt document [master document: contestoStr.tex]

\startchapter[title=Lua Unit Testing]

We make extensive use of ideas in the design of the LunaTest Lua unit 
testing framework which is in turn inspired by the LUnit assertion 
interface. We tailor these ideas for use \emph{inside} \ConTeXt. 

\section[title=Test cases]

% temporarily include this in the main document
% until the actual module files stabilize
%\definetyping[LuaTest]
%\setuptyping[LuaTest][option=lua]

\startMkIVCode

\definetyping[LuaTest]
\setuptyping[LuaTest][option=lua]

\let\oldStopLuaTest=\stopLuaTest
\def\stopLuaTest{%
  \oldStopLuaTest%
  \directlua{thirddata.contests.addLuaTest('_typing_')}
}

\stopMkIVCode

\startLuaCode

function contests.addLuaTest(bufferName)
  local bufferContents = buffers.getcontent(bufferName):gsub("\13", "\n")
  local suite = tests.curSuite
  local case  = suite.curCase
  case.lua    = case.lua or {}
  table_insert(case.lua, bufferContents)
end

function contests.runCurLuaTestCase()
  local suite    = tests.curSuite
  local case     = suite.curCase
  local luaChunk = table_concat(case.lua, '\n')
  if not luaChunk:match('^%s*$') then
    luaChunk = [=[
    local assert = thirddata.contests.assert
    ]=]..luaChunk
    -- consider using PCall here
    local luaFunc, errMessage = load(luaChunk)
    if luaFunc then
      --local result = luaFunc()
    end
  end
end

\stopLuaCode

\section[title=Assertions]

We start by defining a helper function to capture the repetitive code in 
one place. Every assertion will contain a condition, a message and some 
reason for failing the assertion. The \type{reportLuaAssertion} function 
captures these three values and builds an assertion result \emph{if} the 
condition is false. If the condition is true, the 
\type{reportLuaAssertion} function quietly does nothing but update the 
test statistics. 

\startLuaCode
function reportLuaAssertion(theCondition, aMessage, theReason)
  -- we do not need to do anything unless theCondition if false!
  if not theCondition then
    local test     = { }
    test.message   = aMessage
    test.reason    = theReason
    test.condition = theCondition
    local info     = debug.getinfo(2,'l')
    test.line      = info.currentline
    error(test, 0) -- throw an error to be captured by an error_handler
  end
end
\stopLuaCode

Since all of the assertions will use the standard lua \type{string.format} 
function to format the various reasons using information specific to each 
assertion, we make \type{string.format} local with a shorter name. For 
efficiency we also make the lua global \type{tostring} a local with the 
shorter name \type{toStr}. 

\startLuaCode
local fmt   = string.format
local toStr = tostring
\stopLuaCode

Having defined both the \type{reportLuaAssertion} and the \type{fmt} 
functions, we now work through each assertion in turn. For each assertion, 
we begin by defining the lua code which implementoStr the assertion, and then 
the test cases which verify the assertion is working correctly. Typically 
there will be two test cases for each assertion, we need to test both the 
positive and negative conditions. 

\startTestSuite[assert.throwsError]

In order to test if a lua function throws an error, we need to wrap the 
actual function call (together with itoStr argumentoStr) in a lua \type{pcall}. 
The return value of this \type{pcall} is then checked to see if an error 
was thrown. 

\startLuaCode
function assert.throwsError(aFunction, aMessage, ...)
  local ok, err = pcall(aFunction, ...)
  return reportLuaAssertion(
    not ok,
    aMessage,
    fmt("Expected %s to throw an error.", toStr(aFunction))
  )
end
\stopLuaCode

There are two cases we need to test.

\startTestCase[should succeed if error thrown]

In this first test case, we want to make sure if the tested function 
throws an error then the assertion succeeds. 

\startLuaTest
  assert.throwsError(function()
    error('this should throw an error!')
  end)
\stopLuaTest
\stopTestCase

\startTestCase[should fail if no error thrown]

In this second test case, we want to make sure the assertion \emph{fails} 
if the tested function \emph{does not} throw an error.

\startLuaTest
  assert.throwsError(assert.throwsError, "", function() end)
\stopLuaTest
\stopTestCase

\stopTestSuite


\startTestSuite[assert.throwsNoError]

\startLuaCode
function assert.throwsNoError(aFunction, aMessage, ...)
  local ok, err = pcall(aFunction, ...)
  return reportLuaAssertion(
    ok,
    aMessage,
    fmt("Expected %s not to throw an error (%s).",
      toStr(aFunction), toStr(err))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.fail]

\startLuaCode
function assert.fail(aMessage)
  return reportLuaAssertion(
    false,
    aMessage,
    "(Failed)"
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isBoolean]

\startLuaCode
function assert.isBoolean(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'boolean',
    aMessage,
    fmt("Expected %s to be a boolean.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNotBoolean]

\startLuaCode
function assert.isNotBoolean(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'boolean',
    aMessage,
    fmt("Expected %s to not be a boolean.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isTrue]

\startLuaCode
function assert.isTrue(aBoolean, aMessage)
  return reportLuaAssertion(
    aBoolean,
    aMessage,
    fmt("Expected true, got %s.", toStr(aBoolean))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isFalse]

\startLuaCode
function assert.isFalse(aBoolean, aMessage)
  return reportLuaAssertion(
    not aBoolean,
    aMessage,
    fmt("Expected false, got %s.", toStr(aBoolean))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNil]

\startLuaCode
function assert.isNil(anObj, aMessage)
  return reportLuaAssertion(
    anObj == nil,
    aMessage,
    fmt("Expected nil, got %s.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNotNil]

\startLuaCode
function assert.isNotNil(anObj, aMessage)
  return reportLuaAssertion(
    anObj ~= nil,
    aMessage,
    fmt("Expected non-nil, got %s.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isEqual]

\startLuaCode
function assert.isEqual(anObj, expected, aMessage)
  return reportLuaAssertion(
    anObj == expected,
    aMessage,
    fmt("Expected %s to equal %s.",
      toStr(expected), toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isEqualWithIn]

\startLuaCode
function assert.isEqualWithIn(anObj, expected,
  tolerance, aMessage)
  return reportLuaAssertion(
    true, --????,
    aMessage,
    fmt("Expected %s to equal %s with tolerance %s.",
      toStr(anObj), toStr(expected), toStr(tolerance))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[ssert_isNotEqual]

\startLuaCode
function assert.isNotEqual(anObj, expected, aMessage)
  return reportLuaAssertion(
    anObj ~= expected,
    aMessage,
    fmt("Expected %s to not equal %s.",
      toStr(expected), toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNotEqualWithIn]
\startLuaCode
function assert.isNotEqualWithIn(anObj, expected,
  tolerance, aMessage)
  return reportLuaAssertion(
    true, --????,
    aMessage,
    fmt("Expected %s to not equal %s with tolerance %s.",
      toStr(anObj), toStr(expected), toStr(tolerance))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNumber]

\startLuaCode
function assert.isNumber(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'number',
    aMessage,
    fmt("Expected %s to be a number.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isGT]

\startLuaCode
function assert.isGT(objA, objB, aMessage)
  return reportLuaAssertion(
    objA > objB,
    aMessage,
    fmt("Expected %s > %s.", toStr(objA), toStr(objB))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isGTE]

\startLuaCode
function assert.isGTE(objA, objB, aMessage)
  return reportLuaAssertion(
    objA >= objB,
    aMessage,
    fmt("Expected %s >= %s.", toStr(objA), toStr(objB))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isLT]

\startLuaCode
function assert.isLT(objA, objB, aMessage)
  return reportLuaAssertion(
    objA < objB,
    aMessage,
    fmt("Expected %s < %s.", toStr(objA), toStr(objB))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isLTE]

\startLuaCode
function assert.isLTE(objA, objB, aMessage)
  return reportLuaAssertion(
    objA <= objB,
    aMessage,
    fmt("Expected %s <= %s.", toStr(objA), toStr(objB))
  )
end
\stopLuaCode


\stopTestSuite

\startTestSuite[assert.isNotNumber]

\startLuaCode
function assert.isNotNumber(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'number',
    aMessage,
    fmt("Expected %s to be a number.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isString]

\startLuaCode
function assert.isString(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'string',
    aMessage,
    fmt("Expected [%s] to be a string.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.matches]

\startLuaCode
function assert.matches(anObj, aPattern, aMessage)
  return reportLuaAssertion(
    anObj:matches(aPattern),
    aMessage,
    ftm("Expected [%s] to match [%s].",
      toStr(anObj), toStr(aPattern))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.doesNotMatch]

\startLuaCode
function assert.doesNotMatch(anObj, aPattern, aMessage)
  return reportLuaAssertion(
    not anObj:matches(aPattern),
    aMessage,
    fmt("Expected [%s] to not match [%s].",
      toStr(anObj), toStr(aPattern))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.length]

\startLuaCode
function assert.length(anObj, aLength, aMessage)
  return reportLuaAssertion(
    #anObj == aLength,
    aMessage,
    fmt("Expected %s to have length %s.",
      toStr(anObj), toStr(aMessage))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNotLength]

\startLuaCode
function assert.isNotLength(anObj, aLength, aMessage)
  return reportLuaAssertion(
    #anObj ~= aLength,
    aMessage,
    fmt("Expected %s to not have length %s.",
      toStr(anObj), toStr(aMessage))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNotoStrtring]

\startLuaCode
function assert.isNotoStrtring(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'string',
    aMessage,
    fmt("Expected [%s] to not be a string.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isTable]

\startLuaCode
function assert.isTable(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'table',
    aMessage,
    fmt("Expected %s to be a table.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.hasKey]

\startLuaCode
function assert.hasKey(anObj, aKey, aMessage)
  return reportLuaAssertion(
    anObj[aKey] ~= nil,
    aMessage,
    fmt("Expected %s to have the key %s.",
      toStr(anObj), toStr(aKey))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.doesNotHaveKey]

\startLuaCode
function assert.doesNotHaveKey(anObj, aKey, aMessage)
  return reportLuaAssertion(
    anObj[aKey] == nil,
    aMessage,
    fmt("Expected %s to not have the key %s.",
      toStr(anObj), toStr(aKey))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNotTable]

\startLuaCode
function assert.isNotTable(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'table',
    aMessage,
    fmt("Expected %s to not be a table.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isFunction]

\startLuaCode
function assert.isFunction(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'function',
    aMessage,
    fmt("Expected %s to be a function.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNotFunction]

\startLuaCode
function assert.isNotFunction(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'function',
    aMessage,
    fmt("Expected %s to not be a function.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isUserData]

\startLuaCode
function assert.isUserData(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'userdata',
    aMessage,
    fmt("Expected %s to be user data.", toStr(anObj))
  )
end
\stopLuaCode
\stopTestSuite

\startTestSuite[assert.isNotUserData]

\startLuaCode
function assert.isNotUserData(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'userdata',
    aMessage,
    fmt("Expected %s to not be user data.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.hasMetaTable]

\startLuaCode
function assert.hasMetaTable(anObj, aMessage)
  return reportLuaAssertion(
    getMetaTable(anObj) ~= nil,
    aMessage,
    fmt("Expected %s to have a meta table.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.metaTableEquals]

\startLuaCode
function assert.metaTableEqual(anObj, aMetaTable, aMessage)
  return reportLuaAssertion(
    getMetaTable(anObj) == aMetaTable,
    aMessage,
    fmt("Expected %s to have the meta table %s.",
      toStr(anObj), toStr(aMetaTable))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.metaTableNotEqual]

\startLuaCode
function assert.metaTableNotEqual(anObj, aMetaTable, aMessage)
  return reportLuaAssertion(
    getMetaTable(anObj) ~= aMetaTable,
    aMessage,
    fmt("Expected %s to not have the meta table %s.",
      toStr(anObj), toStr(aMetaTable))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.doesNotHaveMetaTable]

\startLuaCode
function assert.hasMetaTable(anObj, aMessage)
  return reportLuaAssertion(
    getMetaTable(anObj) == nil,
    aMessage,
    fmt("Expected %s to not have a meta table.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isThread]

\startLuaCode
function assert.isThread(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) == 'thread',
    aMessage,
    fmt("Expected %s to be a thread.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assert.isNotThread]

\startLuaCode
function assert.isNotThread(anObj, aMessage)
  return reportLuaAssertion(
    type(anObj) ~= 'thread',
    aMessage,
    fmt("Expected %s to not be a thread.", toStr(anObj))
  )
end
\stopLuaCode

\stopTestSuite

\stopchapter