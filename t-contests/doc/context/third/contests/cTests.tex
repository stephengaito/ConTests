% A ConTeXt document [master document: contests.tex]

\chapter[title=C Unit Testing]

We will eventually include a collection of C unit tests.

\startMkIVCode
\definetyping[CTest]
\setuptyping[CTest][option=cpp]

\let\oldStopCTest=\stopCTest
\def\stopCTest{%
  \oldStopCTest%
  \directlua{thirddata.contests.addCTest('_typing_')}
}

\def\setCTestStage#1#2{%
  \directlua{%
    thirddata.contests.setCTestStage('#1', '#2')
  }
}

\def\CTestsMethodSetup{%
  \setCTestStage{Methods}{Setup}
}

\def\CTestsMethodTeardown{%
  \setCTestStage{Methods}{Teardown}
}

\def\CTestsSetup{%
  \setCTestStage{Global}{Setup}
}

\def\CTestsTeardown{%
  \setCTestStage{Global}{Teardown}
}

\def\CTestSuiteSetup{%
  \setCTestStage{TestSuite}{Setup}
}

\def\CTestSuiteTeardown{%
  \setCTestStage{TestSuite}{Teardown}
}

\def\setCTestStream#1{%
  \directlua{
    thirddata.contests.setCTestStream('#1')
  }
}

\def\addCTestInclude#1{%
  \directlua{
    thirddata.contests.addCTestInclude('#1')
  }
}

\def\addCTestLibDir#1{%
  \directlua{
    thirddata.contests.addCTestLibDir('#1')
  }
}

\def\addCTestLib#1{%
  \directlua{
    thirddata.contests.addCTestLib('#1')
  }
}

\def\createCTestFile#1#2#3{%
  \directlua{
    thirddata.contests.createCTestFile('#1', '#2', '#3')
  }
}

\def\addCTestTargets#1{%
  \directlua{
    thirddata.contests.addCTestTargets('#1')
  }
}
\stopMkIVCode

\startLuaCode
local function addCTest(bufferName)
  local bufferContents = buffers.getcontent(bufferName):gsub("\13", "\n")
  local methods        = setDefs(tests, 'methods')
  local suite          = setDefs(tests, 'curSuite')
  local case           = setDefs(suite, 'curCase')
  local cTests         = setDefs(case, 'cTests')
  local curStage       = tests.stage:lower()
  if curStage:find('global') then
    if curStage:find('up') then
      local setup      = setDefs(tests, 'setup')
      cTests           = setDefs(setup, 'cTests')
    elseif curStage:find('down') then
      local teardown   = setDefs(tests, 'teardown')
      cTests           = setDefs(teardown, 'cTests')
    end
  elseif curStage:find('suite') then
    if curStage:find('up') then
      local setup      = setDefs(suite, 'setup')
      cTests           = setDefs(setup, 'cTests')
    elseif curStage:find('down') then
      local teardown   = setDefs(suite, 'teardown')
      cTests           = setDefs(teardown, 'cTests')
    end
  elseif curStage:find('method') then
    if curStage:find('up') then
      local setup      = setDefs(methods, 'setup')
      cTests           = setDefs(setup, 'cTests')
    elseif curStage:find('down') then
      local teardown   = setDefs(methods, 'teardown')
      cTests           = setDefs(teardown, 'cTests')
    end
  end
  tests.stage          = ''
  local cTestStream    = setDefs(tests, 'curCTestStream', 'default')
  cTestStream          = setDefs(cTests, cTestStream)
  tInsert(cTestStream, bufferContents)
end

contests.addCTest = addCTest

local function setCTestStage(suiteCase, setupTeardown)
  tests.stage = suiteCase..'-'..setupTeardown
end

contests.setCTestStage = setCTestStage

local function setCTestStream(aCodeStream)
  if type(aCodeStream) ~= 'string'
    or #aCodeStream < 1 then
    aCodeStream = 'default'
  end
  tests.curCTestStream = aCodeStream
end

contests.setCTestStream = setCTestStream

local function addCTestInclude(anInclude)
  local cIncludes        = setDefs(tests, 'cIncludes')
  local cTestStream      = setDefs(tests, 'curCTestStream', 'default')
  cTestStream            = setDefs(cIncludes, cTestStream)
  tInsert(cTestStream, anInclude)
end

contests.addCTestInclude = addCTestInclude

local function addCTestLibDir(aLibDir)
  local cLibDirs        = setDefs(tests, 'cLibDirs')
  local cTestStream     = setDefs(tests, 'curCTestStream', 'default')
  cTestStream           = setDefs(cLibDirs, cTestStream)
  tInsert(cTestStream, aLibDir)
end

contests.addCTestLibDir = addCTestLibDir

local function addCTestLib(aLib)
  local cLibs          = setDefs(tests, 'cLibs')
  local cTestStream    = setDefs(tests, 'curCTestStream', 'default')
  cTestStream          = setDefs(cLibs, cTestStream)
  tInsert(cTestStream, aLib)
end

contests.addCTestLib = addCTestLib

local function createCTestFile(aCodeStream, aFilePath, aFileHeader)
  if not build.buildDir then
    texio.write('\nERROR: document directory NOT yet defined\n')
    texio.write('       NOT creating code file ['..aFilePath..']\n\n')
    return
  end

  if type(aFilePath) ~= 'string'
    or #aFilePath < 1 then
    texio.write('\nERROR: no file name provided for cTests\n\n')
    return
  end

  build.testTargets = build.testTargets or { }
  local aTestExec = aFilePath:gsub('%..+$','')
  tInsert(build.testTargets, aTestExec)

  aFilePath = build.buildDir .. '/build/' .. aFilePath
  local outFile = io.open(aFilePath, 'w')
  if not outFile then
    return
  end

  texio.write('creating CTest file: ['..aFilePath..']\n')

  if type(aFileHeader) == 'string'
    and 0 < #aFileHeader then
    outFile:write(aFileHeader)
    outFile:write('\n\n')
  end

  tests.suites = tests.suites or { }

  if type(aCodeStream) ~= 'string'
    or #aCodeStream < 1 then
    aCodeStream = 'default'
  end

  outFile:write('#include <t-contests.h>\n')
  outFile:write('\n\n')

  outFile:write('//-------------------------------------------------------\n')
  local cIncludes = setDefs(tests, 'cIncludes')

  cIncludes[aCodeStream] = cIncludes[aCodeStream] or { }

  for i, anInclude in ipairs(cIncludes[aCodeStream]) do
    outFile:write('#include '..anInclude..'\n')
  end
  outFile:write('\n\n')

  tests.methods = tests.methods or { }
  local methods = tests.methods
  methods.setup = methods.setup or { }
  local mSetup  = methods.setup
  mSetup.cTests = mSetup.cTests or { }
  msCTests      = mSetup.cTests

  --msCTests[aCodeStream] = msCTests[aCodeStream] or { }

  if msCTests and
    msCTests[aCodeStream] then
    outFile:write('  // CTests methods setup\n')
    local setupCode = tConcat(msCTests[aCodeStream],'\n')
    setupCode       = litProgs.splitString(setupCode)
    outFile:write('  '..tConcat(setupCode, '\n  '))
    outFile:write('\n\n')
  end
  outFile:write('\n\n')

  outFile:write('//-------------------------------------------------------\n')
  outFile:write('int main(){\n\n')
  outFile:write('  lua_State *lstate = luaL_newstate();\n')
  outFile:write('  luaL_openlibs(lstate);\n\n')

  outFile:write('  if luaL_dofile(lstate, CONTESTS_STARTUP) {\n')
  outFile:write('    fprintf(stderr, "Could not load cTests\\n");\n')
  outFile:write('    fprintf(stderr, "%s\\n", lua_tostring(lstate, 1));\n')
  outFile:write('    exit(-1);\n')
  outFile:write('  }\n\n')

  tests.setup = tests.setup or { }
  if tests.setup.cTests and
    tests.setup.cTests[aCodeStream] then
    outFile:write('  // CTests setup\n')
    local setupCode = tConcat(tests.setup.cTests[aCodeStream],'\n')
    setupCode       = litProgs.splitString(setupCode)
    outFile:write('  '..tConcat(setupCode, '\n  '))
    outFile:write('\n\n')
  end

  for i, aTestSuite in ipairs(tests.suites) do
    aTestSuite.cases = aTestSuite.cases or { }
    local suiteCaseBuf = { }

    for j, aTestCase in ipairs(aTestSuite.cases) do
      local cTests     = setDefs(aTestCase, 'cTests')
      if aTestCase.desc and
        aTestCase.fileName and
        aTestCase.startLine and
        aTestCase.lastLine and
        cTests[aCodeStream] then
        tInsert(suiteCaseBuf, '    for (size_t i = 0; i < 1; i++) {\n\n')
        tInsert(suiteCaseBuf, '      StartTestCase(\n')
        tInsert(suiteCaseBuf, '        "'..aTestCase.desc..'",\n')
        tInsert(suiteCaseBuf, '        "'..aTestCase.fileName..'",\n')
        tInsert(suiteCaseBuf, '        '..toStr(aTestCase.startLine)..',\n')
        tInsert(suiteCaseBuf, '        '..toStr(aTestCase.lastLine)..'\n')
        tInsert(suiteCaseBuf, '      );\n\n  ')
        local cTestsCode = tConcat(cTests[aCodeStream], '\n')
        cTestsCode       = litProgs.splitString(cTestsCode)
        tInsert(suiteCaseBuf, '    '..tConcat(cTestsCode, '\n      '))
        tInsert(suiteCaseBuf, '\n\n      StopTestCase();\n\n')
        tInsert(suiteCaseBuf, '    }\n\n')
      elseif (not aTestCase.desc or
        not aTestCase.fileName or
        not aTestCase.startLine or
        not aTestCase.lastLine) and
        cTests[aCodeStream] then
        texio.write("\nERROR missing \\startTestCase\n")
        texio.write("near:\n")
        texio.write(tConcat(cTests[aCodeStream], '\n'))
        texio.write('\n')
      end
    end

    if aTestSuite.desc and (0 < #suiteCaseBuf) then
      outFile:write('  //-------------------------------------------------------\n')
      outFile:write('  for (size_t i = 0; i < 1; i++) {\n\n')
      outFile:write('    StartTestSuite(\n')
      outFile:write('      "'..aTestSuite.desc..'"\n')
      outFile:write('    );\n\n')

      aTestSuite.setup = aTestSuite.setup or { }
      if aTestSuite.setup.cTests and
        aTestSuite.setup.cTests[aCodeStream] then
        outFile:write('    // TestSuite setup\n')
        local setupCode = tConcat(aTestSuite.setup.cTests[aCodeStream],'\n  ')
        setupCode = litProgs.splitString(setupCode, '\n')
        outFile:write('    '..tConcat(setupCode, '\n    '))
        outFile:write('\n\n')
      end

      outFile:write(tConcat(suiteCaseBuf))

      aTestSuite.teardown = aTestSuite.teardown or { }
      if aTestSuite.teardown.cTests and
        aTestSuite.teardown.cTests[aCodeStream] then
        outFile:write('    // TestSuite teardown\n')
        local teardownCode = tConcat(aTestSuite.teardown.cTests[aCodeStream],'\n  ')
        teardownCode = litProgs.splitString(teardownCode, '\n')
        outFile:write('    '..tConcat(teardownCode, '\n    '))
        outFile:write('\n\n')
      end

      outFile:write('\n    StopTestSuite();\n\n')
      outFile:write('  }\n\n')
    elseif not aTestSuite.desc and (0 < #suiteCaseBuf) then
      texio.write("\nERROR missing \\startTestSuite\n")
      texio.write("near:\n")
      texio.write(tConcat(suiteCaseBuf, '\n'))
      texio.write('\n')
    end
  end

  tests.teardown = tests.teardown or { }
  if tests.teardown.cTests and
    tests.teardown.cTests[aCodeStream] then
    outFile:write('  // CTests teardown\n')
    local teardownCode =tConcat(tests.teardown.cTests[aCodeStream],'\n  ')
    teardownCode = litProgs.splitString(teardownCode, '\n')
    outFile:write('  '..tConcat(teardownCode, '\n  '))
    outFile:write('\n\n')
  end

  outFile:write('\n  fprintf(stdout, "\\n");\n\n')

  outFile:write('\n  lua_getglobal(lstate, "getNumFailures");\n')
  outFile:write(  '  lua_errorCall(0,1);\n')
  outFile:write(  '  int numFailures = lua_tointeger(lstate, -1);\n')
  outFile:write(  '  lua_pop(lstate, 1);\n\n')

  outFile:write(  '  if (0 < numFailures) {\n')
  outFile:write(  '    fprintf(stdout, "FAILURES FOUND: %u\\n",\n')
  outFile:write(  '      numFailures\n')
  outFile:write(  '    );\n')
  outFile:write(  '  }\n')

  outFile:write('\n  return numFailures;\n')
  outFile:write('}\n')

  outFile:close()
end

contests.createCTestFile = createCTestFile

local function addCTestTargets(aCodeStream)
  litProgs.setCodeStream('Lmsfile', aCodeStream)
  litProgs.markCodeOrigin('Lmsfile')
  local lmsfile = {}
  tInsert(lmsfile, "require 'lms.contests'\n")
  tInsert(lmsfile, "contests.targets{")
  tInsert(lmsfile, "  testExecs = {")
  for i, aTestExec in ipairs(build.testTargets) do
    tInsert(lmsfile, "    '"..aTestExec.."',")
  end
  tInsert(lmsfile, "  },")
  tInsert(lmsfile, "  mainDoc = '"..build.mainDoc.."',")
  tInsert(lmsfile, "  docFiles = {")
  for i, aSubDoc in ipairs(build.subDocs) do
    tInsert(lmsfile, "    '"..aSubDoc.."',")
  end
  tInsert(lmsfile, "  },")
  tInsert(lmsfile, "  srcFiles = {")
  for i, aSrcFile in ipairs(build.srcTargets) do
    tInsert(lmsfile, "    '"..aSrcFile.."',")
  end
  tInsert(lmsfile, "  },")
  tInsert(lmsfile, "  testLibDirs = {")
  if tests.cLibDirs and tests.cLibDirs[aCodeStream] then
    for i, aLibDir in ipairs(tests.cLibDirs[aCodeStream]) do
      tInsert(lmsfile, "    '"..aLibDir.."',")
    end
  end
  tInsert(lmsfile, "  },")
  tInsert(lmsfile, "  testLibs = {")
  if tests.cLibs and tests.cLibs[aCodeStream] then
    for i, aLib in ipairs(tests.cLibs[aCodeStream]) do
      tInsert(lmsfile, "    '"..aLib.."',")
    end
  end
  tInsert(lmsfile, "  },")
  tInsert(lmsfile, "  buildDir  = 'build',")
  tInsert(lmsfile, "  docDir    = '"..build.docDir.."',")
  tInsert(lmsfile, "  moduleDir = '"..build.contextModuleDir.."',")
  tInsert(lmsfile, "}")
  litProgs.setPrepend('Lmsfile', aCodeStream, true)
  litProgs.addCode.default('Lmsfile', tConcat(lmsfile, '\n'))
end

contests.addCTestTargets = addCTestTargets
\stopLuaCode

\startCHeader
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <unistd.h>
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

#ifndef FALSE
#define FALSE 0
#endif

#ifndef TRUE
#define TRUE 1
#endif

#ifndef NULL
#define NULL 0
#endif

#define lua_errorCall(numArgs, numRtn)                     \
{                                                          \
  int pResult = lua_pcall(lstate, (numArgs), (numRtn), 0); \
  if (pResult) {                                           \
    fprintf(stderr,                                        \
      "LUA error (%d) in file %s at line %d\n",            \
      pResult, __FILE__, __LINE__                          \
    );                                                     \
    fprintf(stderr, "%s\n", lua_tostring(lstate, -1));     \
    lua_pop(lstate, 1);                                    \
  }                                                        \
}

#define lua_fileCall(numArgs, numRtn)            \
  lua_pushstring(lstate, __FILE__);              \
  lua_pushunsigned(lstate, __LINE__);            \
  lua_errorCall((numArgs)+2, numRtn)

#define StartTestSuite(aDesc)              \
  lua_getglobal(lstate, "startTestSuite"); \
  lua_pushstring(lstate, (aDesc));         \
  lua_fileCall(1, 0)

#define StopTestSuite()                   \
  lua_getglobal(lstate, "stopTestSuite"); \
  lua_fileCall(0, 0)

#define StartTestCase(aDesc, aFileName, startLine, lastLine) \
  lua_getglobal(lstate, "startTestCase");                    \
  lua_pushstring(lstate, (aDesc));                           \
  lua_pushstring(lstate, (aFileName));                       \
  lua_pushunsigned(lstate, (startLine));                     \
  lua_pushunsigned(lstate, (lastLine));                      \
  lua_fileCall(4, 0)

#define SkipTestCase()                   \
  lua_getglobal(lstate, "skipTestCase"); \
  lua_fileCall(0, 0)

#define StopTestCase()                   \
  lua_getglobal(lstate, "stopTestCase"); \
  lua_fileCall(0, 0)

#define lua_CTestCall(numArgs, shouldStop)       \
  lua_pushstring(lstate, __FILE__);              \
  lua_pushunsigned(lstate, __LINE__);            \
  lua_fileCall((numArgs)+2, 1);                  \
  {                                              \
    int theCondition = lua_toboolean(lstate, 1); \
    lua_pop(lstate, 1);                          \
    if (shouldStop & (!theCondition)) break;     \
  }
\stopCHeader

\setLuaCodeStream{cTests}
\startLuaCode
-- This is the lua code associated with the t-contests-cTests

local cTests  = { }
local tInsert = table.insert
local tRemove = table.remove
local tSort   = table.sort
local sFmt    = string.format
local toStr   = tostring

function setDefs(varVal, selector, defVal)
  if not defVal then defVal = { } end
  varVal[selector] = varVal[selector] or defVal
  return varVal[selector]
end

function startTestSuite(aDesc, testFileName, testFileLine)
  cTests.curSuite = { }
  local curSuite  = cTests.curSuite
  curSuite.desc   = aDesc
  curSuite.passed = true
  io.stdout:write("\n-------------------------------------\n")
  io.stdout:write(sFmt("TS: %s\n", aDesc))
end

function stopTestSuite(testFileName, testFileLine)
  cTests.suites = cTests.suites or { }
  if cTests.curSuite then
    tInsert(cTests.suites, cTests.curSuite)
  end
  cTests.curSuite = { }
end

function startTestCase(
  aDesc, srcFileName, srcStartLine, srcLastLine,
  testFileName, testFileLine)
  local curSuite    = setDefs(cTests, 'curSuite')
  curSuite.curCase  = { }
  local curCase     = curSuite.curCase
  curCase.desc      = aDesc
  curCase.fileName  = srcFileName
  curCase.startLine = srcStartLine
  curCase.lastLine  = srcLastLine
  curCase.passed    = true
  io.stdout:write(sFmt("  TC: %s\n", aDesc))
end

function skipTestCase(testFileName, testFileLine)
  io.stdout:write("    SKIPPED\n")
end

function stopTestCase(testFileName, testFileLine)
  local curSuite  = setDefs(cTests, 'curSuite')
  curSuite.cases  = curSuite.cases or { }
  if curSuite.curCase then
    tInsert(curSuite.cases, curSuite.curCase)
  end
  curSuite.curCase = { }
end
\stopLuaCode

\section[title=Assertions]

\startLuaCode
local function compareKeyValues(a, b)
  return (a[1] < b[1])
end

local function prettyPrint(anObj, indent)
  local result = ""
  indent = indent or ""
  if type(anObj) == 'nil' then
    result = 'nil'
  elseif type(anObj) == 'boolean' then
    if anObj then result = 'true' else result = 'false' end
  elseif type(anObj) == 'number' then
    result = toStr(anObj)
  elseif type(anObj) == 'string' then
    result = '"'..anObj..'"'
  elseif type(anObj) == 'function' then
    result = toStr(anObj)
  elseif type(anObj) == 'userdata' then
    result = toStr(anObj)
  elseif type(anObj) == 'thread' then
    result = toStr(anObj)
  elseif type(anObj) == 'table' then
    local origIndent = indent
    indent = indent..'  '
    result = '{\n'
    for i, aValue in ipairs(anObj) do
      result = result..indent..prettyPrint(aValue, indent)..',\n'
    end
    local theKeyValues = { }
    for aKey, aValue in pairs(anObj) do
      if type(aKey) ~= 'number' or aKey < 1 or #anObj < aKey then
        tInsert(theKeyValues,
          { prettyPrint(aKey), aKey, prettyPrint(aValue, indent) })
      end
    end
    tSort(theKeyValues, compareKeyValues)
    for i, aKeyValue in ipairs(theKeyValues) do
      result = result..indent..'['..aKeyValue[1]..'] = '..aKeyValue[3]..',\n'
    end
    result = result..origIndent..'}'
  else
    result = 'UNKNOWN TYPE: ['..toStr(anObj)..']'
  end
  return result
end

local function logFailure(reason, suiteDesc, caseDesc,
                          testMsg, errMsg, fileInfo)
  local failure = {}
  failure.reason    = reason
  failure.suiteDesc = suiteDesc
  failure.caseDesc  = caseDesc
  failure.testMsg   = testMsg
  failure.errMsg    = errMsg
  failure.fileInfo  = fileInfo
  io.stdout:write(sFmt('    %s\n', reason))
  if 0 < #testMsg then
    io.stdout:write(sFmt('    %s\n', testMsg))
  end
  io.stdout:write(sFmt('    %s\n', errMsg))
  io.stdout:write(sFmt('    %s\n', fileInfo))
  io.stdout:write('\n\n')
  return failure
end

function reportCAssertion(
  theCondition, aMessage, theReason,
  testFileName, testFileLine)
  local curSuite     = setDefs(cTests, 'curSuite')
  local curCase      = setDefs(curSuite, 'curCase')
  curCase.shouldFail = curCase.shouldFail or { }
  
  if 0 < #curCase.shouldFail then
    -- we are wrapped in a shouldFail
    --
    local shouldFail   = tRemove(curCase.shouldFail)
    local innerMessage = aMessage
    local innerReason  = theReason
    theReason          = nil
    theCondition       = not theCondition
  
    if theReason == nil
      and innerMessage ~= nil
      and shouldFail.messagePattern ~= nil
      and type(shouldFail.messagePattern) == 'string'
      and 0 < #shouldFail.messagePattern then
      if innerMessage:match(shouldFail.messagePattern) then
        -- do nothing
      else
        theReason = sFmt('Expected inner message [%s] to match [%s]',
          innerMessage, shouldFail.messagePattern)
        theCondition = false
      end
    end

    if theReason == nil
      and innerReason ~= nil
      and shouldFail.reasonPattern ~= nil
      and type(shouldFail.reasonPattern) == 'string'
      and 0 < #shouldFail.reasonPattern then
      if innerReason:match(shouldFail.reasonPattern) then
        -- do nothing
      else
        theReason = sFmt('Expected inner failure reason [%s] to match [%s]',
          innerReason, shouldFail.reasonPattern)
        theCondition = false
      end
    end
    
    if theReason == nil then
      theReason = sFmt('Expected inner assertion [%s] to fail',
        innerMessage)
    end
    aMessage = shouldFail.message
    
    return reportCAssertion(
      theCondition,
      aMessage,
      theReason,
      testFileName,
      testFileLine
    )
  end
  -- there are no more wrapping shouldFails
  -- so report the resulting condition
  --
  if theCondition then
    -- record stats
  else
    curSuite.passed = false
    curCase.passed  = false
    local failure = logFailure(
      'CTest FAILED',
      curSuite.desc,
      curCase.desc,
      aMessage,
      theReason,
      sFmt('in file: %s between lines %s and %s',
        curCase.fileName,
        toStr(curCase.startLine),
        toStr(curCase.lastLine)
      )
    )
    cTests.failures = cTests.failures or { }
    tInsert(cTests.failures, failure)
    cTests.numFailures = #cTests.failures
  end
  return theCondition
end

function getNumFailures()
  cTests.numFailures = cTests.numFailures or 0
  return cTests.numFailures
end
\stopLuaCode

\CTestsSetup\
\startCTest
  // this is the CTest setup
\stopCTest

\startTestSuite[assertShouldFail environment]

\CTestSuiteSetup\
\startCTest
  // this is the assertShouldFail testSuite setup
\stopCTest

\startCHeader
#define StartAssertShouldFail(messagePattern, reasonPattern, aMessage) \
  lua_getglobal(lstate, "startCShouldFail");                           \
  lua_pushstring(lstate, (messagePattern));                            \
  lua_pushstring(lstate, (reasonPattern));                             \
  lua_pushstring(lstate, (aMessage));                                  \
  lua_fileCall(3, 0)

#define StopAssertShouldFail()              \
  lua_getglobal(lstate, "stopCShouldFail"); \
  lua_fileCall(0, 0)
\stopCHeader

\startLuaCode
function startCShouldFail(
  messagePattern, reasonPattern, aMessage,
  testFileName, testFileLine)
  local curSuite     = setDefs(cTests, 'curSuite')
  local curCase      = setDefs(curSuite, 'curCase')
  local curShouldFail   = { }
  curShouldFail.messagePattern = messagePattern
  curShouldFail.reasonPattern  = reasonPattern
  curShouldFail.message        = aMessage
  
  curCase.shouldFail = curCase.shouldFail or { }
  tInsert(curCase.shouldFail, curShouldFail)
end

function stopCShouldFail(testFileName, testFileLine)
  -- do nothing at the moment
end
\stopLuaCode

\startTestCase[should succeed if an inner assertion fails]

\startCTest
StartAssertShouldFail("Inner message", "Failed","Outer message");
  AssertFailMsg("Inner message");
StopAssertShouldFail();
\stopCTest
\stopTestCase

\startTestCase[should fail if an inner assertion does not fail]

\startCTest
StartAssertShouldFail(
  "Inner message","Expected inner","Outer message");
  StartAssertShouldFail("","","Inner message");
    AssertSucceedMsg("no flies on us.");
  StopAssertShouldFail();
StopAssertShouldFail();
\stopCTest
\stopTestCase

\startTestCase[should fail if inner assertion fails with wrong message or reason]

\startCTest
StartAssertShouldFail("First outer message","","First outermost message");
StartAssertShouldFail("wrong","","First outer message");
  AssertFailMsg("First inner message");
StopAssertShouldFail();
StopAssertShouldFail();

StartAssertShouldFail("Second outer message","","Second outermost message");
StartAssertShouldFail("","wrong","Second outer message");
  AssertFailMsg("Second inner message");
StopAssertShouldFail();
StopAssertShouldFail();
\stopCTest
\stopTestCase

\CTestSuiteTeardown\
\startCTest
  // this is the assertShouldFail testSuite teardown
\stopCTest

\stopTestSuite

\startTestSuite[assertFail]

\startCHeader
#define AssertFailMsg(aMessage)              \
  lua_getglobal(lstate, "reportCAssertion"); \
  lua_pushboolean(lstate, FALSE);            \
  lua_pushstring(lstate, (aMessage));        \
  lua_pushstring(lstate, "Failed");          \
  lua_CTestCall(3, TRUE)
  
#define AssertFail() \
  AssertFailMsg("")
\stopCHeader

\startTestCase[assertFail should always fail]

\startCTest
  StartAssertShouldFail(".*", ".*", "outerMessage");
    AssertFail();
  StopAssertShouldFail();
\stopCTest

\stopTestCase

\stopTestSuite

\startTestSuite[assertSucceed]

\startCHeader
#define AssertSucceedMsg(aMessage)           \
  lua_getglobal(lstate, "reportCAssertion"); \
  lua_pushboolean(lstate, TRUE);             \
  lua_pushstring(lstate, (aMessage));        \
  lua_pushstring(lstate, "Succeeded");       \
  lua_CTestCall(3, FALSE)

#define AssertSucceed() \
  AssertSucceedMsg("")
\stopCHeader

\startTestCase[should always succeed]

\startCTest
  AssertSucceed();
\stopCTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertIntTrue]

\startCHeader
#define AssertIntTrueMsg(anInt, aMessage, sStop) \
  lua_getglobal(lstate, "reportCAssertion");     \
  lua_pushboolean(lstate, (anInt));              \
  lua_pushstring(lstate, (aMessage));            \
  lua_pushfstring(lstate,                        \
      "Expected %d to be TRUE.",                 \
      (anInt)                                    \
    );                                           \
  lua_CTestCall(3, sStop)

#define AssertIntTrueStop(anInt)    \
  AssertIntTrueMsg(anInt, "", TRUE)

#define AssertIntTrue(anInt)         \
  AssertIntTrueMsg(anInt, "", FALSE)
\stopCHeader

\startTestCase[should succeed if true]
\startCTest
  AssertIntTrue(TRUE);
\stopCTest
\stopTestCase

\startTestCase[should fail if false]
\startCTest
StartAssertShouldFail("","","");
  AssertIntTrue(FALSE);
StopAssertShouldFail();
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertIntFalse]

\startCHeader
#define AssertIntFalseMsg(anInt, aMessage, sStop) \
  lua_getglobal(lstate, "reportCAssertion");      \
  lua_pushboolean(lstate, !(anInt));              \
  lua_pushstring(lstate, (aMessage));             \
  lua_pushfstring(lstate,                         \
      "Expected %d to be FALSE.",                 \
      (anInt)                                     \
    );                                            \
  lua_CTestCall(3, sStop)

#define AssertIntFalseStop(anInt)    \
  AssertIntFalseMsg(anInt, "", TRUE)

#define AssertIntFalse(anInt)         \
  AssertIntFalseMsg(anInt, "", FALSE)
\stopCHeader

\startTestCase[should succeed if false]
\startCTest
  AssertIntFalse(FALSE);
\stopCTest
\stopTestCase

\startTestCase[should fail if true]
\startCTest
StartAssertShouldFail("","","");
  AssertIntFalse(TRUE);
StopAssertShouldFail();
StartAssertShouldFail("","","");
  AssertIntFalse(42);
StopAssertShouldFail();
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertIntZero]

\startCHeader
#define AssertIntZeroMsg(anInt, aMessage, sStop) \
  lua_getglobal(lstate, "reportCAssertion");     \
  lua_pushboolean(lstate, (anInt) == 0);         \
  lua_pushstring(lstate, (aMessage));            \
  lua_pushfstring(lstate,                        \
      "Expected %d to be ZERO.",                 \
      (anInt)                                    \
    );                                           \
  lua_CTestCall(3, sStop)

#define AssertIntZeroStop(anInt)    \
  AssertIntZeroMsg(anInt, "", TRUE)

#define AssertIntZero(anInt)         \
  AssertIntZeroMsg(anInt, "", FALSE)
\stopCHeader

\startTestCase[should succeed if zero]
\startCTest
  AssertIntZero(0);
\stopCTest
\stopTestCase

\startTestCase[should fail if not zero]
\startCTest
StartAssertShouldFail("","","");
  AssertIntZero(1);
StopAssertShouldFail();
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertIntNotZero]

\startCHeader
#define AssertIntNotZeroMsg(anInt, aMessage, sStop) \
  lua_getglobal(lstate, "reportCAssertion");     \
  lua_pushboolean(lstate, (anInt) != 0);              \
  lua_pushstring(lstate, (aMessage));            \
  lua_pushfstring(lstate,                        \
      "Expected %d NOT to be ZERO.",             \
      (anInt)                                    \
    );                                           \
  lua_CTestCall(3, sStop)

#define AssertIntNotZeroStop(anInt) \
  AssertIntNotZeroMsg(anInt, "", TRUE)

#define AssertIntNotZero(anInt)     \
  AssertIntNotZeroMsg(anInt, "", FALSE)
\stopCHeader

\startTestCase[should succeed if not zero]
\startCTest
  AssertIntNotZero(1);
\stopCTest
\stopTestCase

\startTestCase[should fail if zero]
\startCTest
StartAssertShouldFail("","","");
  AssertIntNotZero(0);
StopAssertShouldFail();
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertIntEquals]

\startCHeader
#define AssertIntEqualsMsg(intA, intB, aMessage, sStop) \
  lua_getglobal(lstate, "reportCAssertion");            \
  lua_pushboolean(lstate, (intA) == (intB));            \
  lua_pushstring(lstate, (aMessage));                   \
  lua_pushfstring(lstate,                               \
      "Expected %d to be equal to %d.",                 \
      (intA),                                           \
      (intB)                                            \
    );                                                  \
  lua_CTestCall(3, sStop)

#define AssertIntEqualsStop(intA, intB)    \
  AssertIntEqualsMsg(intA, intB, "", TRUE)

#define AssertIntEquals(intA, intB)         \
  AssertIntEqualsMsg(intA, intB, "", FALSE)
\stopCHeader

\startTestCase[should succeed if two integers are equal]
\startCTest
  AssertIntEquals(42, 42);
\stopCTest
\stopTestCase

\startTestCase[should fail if two integers are not equal]
\startCTest
StartAssertShouldFail("","","");
  AssertIntEquals(3,42);
StopAssertShouldFail();
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertIntNotEquals]

\startCHeader
#define AssertIntNotEqualsMsg(intA, intB, aMessage, sStop) \
  lua_getglobal(lstate, "reportCAssertion");               \
  lua_pushboolean(lstate, (intA) != (intB));               \
  lua_pushstring(lstate, (aMessage));                      \
  lua_pushfstring(lstate,                                  \
      "Expected %d not to be equal to %d.",                \
      (intA),                                              \
      (intB)                                               \
    );                                                     \
  lua_CTestCall(3, sStop)

#define AssertIntNotEqualsStop(intA, intB)    \
  AssertIntNotEqualsMsg(intA, intB, "", TRUE)

#define AssertIntNotEquals(intA, intB)         \
  AssertIntNotEqualsMsg(intA, intB, "", FALSE)
\stopCHeader

\startTestCase[should succeed if two integers are not equal]
\startCTest
  AssertIntNotEquals(3,42);
\stopCTest
\stopTestCase

\startTestCase[should fail if two integers are equal]
\startCTest
StartAssertShouldFail("","","");
  AssertIntNotEquals(42,42);
StopAssertShouldFail();
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertPrtNull]

\startCHeader
#define AssertPtrNullMsg(aPtr, aMessage, sStop) \
  lua_getglobal(lstate, "reportCAssertion");    \
  lua_pushboolean(lstate, (aPtr) == (NULL));    \
  lua_pushstring(lstate, (aMessage));           \
  lua_pushfstring(lstate,                       \
      "Expected %p to be NULL.",                \
      (aPtr)                                    \
    );                                          \
  lua_CTestCall(3, sStop)

#define AssertPtrNullStop(aPtr)    \
  AssertPtrNullMsg(aPtr, "", TRUE)

#define AssertPtrNull(aPtr)         \
  AssertPtrNullMsg(aPtr, "", FALSE)
\stopCHeader

\startTestCase[should succeed if pointer is NULL]
\startCTest
  AssertPtrNull(NULL);
\stopCTest
\stopTestCase

\startTestCase[should fail if pointer is not NULL]
\startCTest
StartAssertShouldFail("","","");
  AssertPtrNull("this is a pointer which is not null");
StopAssertShouldFail();
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertPtrNotNull]

\startCHeader
#define AssertPtrNotNullMsg(aPtr, aMessage, sStop) \
  lua_getglobal(lstate, "reportCAssertion");       \
  lua_pushboolean(lstate, (aPtr) != (NULL));       \
  lua_pushstring(lstate, (aMessage));              \
  lua_pushfstring(lstate,                          \
      "Expected %p not to be NULL.",               \
      (aPtr)                                       \
    );                                             \
  lua_CTestCall(3, sStop)

#define AssertPtrNotNull(aPtr)        \
  AssertPtrNotNullMsg(aPtr, "", TRUE)

#define AssertPtrNotNullCont(aPtr)     \
  AssertPtrNotNullMsg(aPtr, "", FALSE)
\stopCHeader

\startTestCase[should succeed if a pointer is not NULL]
\startCTest
  AssertPtrNotNull("this is another pointer which is not null");
\stopCTest
\stopTestCase

\startTestCase[should fail if a pointer is NULL]
\startCTest
StartAssertShouldFail("","","");
  AssertPtrNotNull(NULL);
StopAssertShouldFail();
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertPtrEquals]

\startCHeader
#define AssertPtrEqualsMsg(ptrA, ptrB, aMessage, sStop) \
  lua_getglobal(lstate, "reportCAssertion");            \
  lua_pushboolean(lstate, (ptrA) == (ptrB));            \
  lua_pushstring(lstate, (aMessage));                   \
  lua_pushfstring(lstate,                               \
      "Expected %p to be equal to %p.",                 \
      (ptrA),                                           \
      (ptrB)                                            \
    );                                                  \
  lua_CTestCall(3, sStop)

#define AssertPtrEqualsStop(ptrA, ptrB)    \
  AssertPtrEqualsMsg(ptrA, ptrB, "", TRUE)

#define AssertPtrEquals(ptrA, ptrB)         \
  AssertPtrEqualsMsg(ptrA, ptrB, "", FALSE)
\stopCHeader

\startTestCase[should succeed if two pointers are equal]
\startCTest
  char* aTest = "aTest";
  AssertPtrEquals(aTest, aTest);
\stopCTest
\stopTestCase

\startTestCase[should fail if two pointers are not equal]
\startCTest
StartAssertShouldFail("","","");
  AssertPtrEquals("ptr1", "ptr2");
StopAssertShouldFail();
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertPtrNotEquals]

\startCHeader
#define AssertPtrNotEqualsMsg(ptrA, ptrB, aMessage, sStop) \
  lua_getglobal(lstate, "reportCAssertion");               \
  lua_pushboolean(lstate, (ptrA) != (ptrB));               \
  lua_pushstring(lstate, (aMessage));                      \
  lua_pushfstring(lstate,                                  \
      "Expected %p not to be equal to %p.",                \
      (ptrA),                                              \
      (ptrB)                                               \
    );                                                     \
  lua_CTestCall(3, sStop)

#define AssertPtrNotEqualsStop(ptrA, ptrB)    \
  AssertPtrNotEqualsMsg(ptrA, ptrB, "", TRUE)

#define AssertPtrNotEquals(ptrA, ptrB)         \
  AssertPtrNotEqualsMsg(ptrA, ptrB, "", FALSE)
\stopCHeader

\startTestCase[should succeed if two pointers are not equal]
\startCTest
  AssertPtrNotEquals("ptr1","ptr2");
\stopCTest
\stopTestCase

\startTestCase[should fail if two pointers are equal]
\startCTest
StartAssertShouldFail("","","");
  char* aTest = "aTest";
  AssertPtrNotEquals(aTest, aTest);
StopAssertShouldFail();
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertStrEmpty]

\startCHeader
#define AssertStrEmptyMsg(aStr, aMessage, sStop) \
  lua_getglobal(lstate, "reportCAssertion");     \
  lua_pushboolean(lstate, *(aStr) == 0);         \
  lua_pushstring(lstate, (aMessage));            \
  lua_pushfstring(lstate,                        \
      "Expected [%s] to be empty.",              \
      (aStr)                                     \
    );                                           \
  lua_CTestCall(3, sStop)

#define AssertStrEmptyStop(aStr)    \
  AssertStrEmptyMsg(aStr, "", TRUE)
#define AssertStrEmpty(aStr)         \
  AssertStrEmptyMsg(aStr, "", FALSE)
\stopCHeader

\startTestCase[should succeed if a string is empty]
\startCTest
  AssertStrEmpty("");
\stopCTest
\stopTestCase

\startTestCase[should fail if a string is empty]
\startCTest
StartAssertShouldFail("","","");
  AssertStrEmpty("a non empty string");
StopAssertShouldFail();
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertStrNotEmpty]

\startCHeader
#define AssertStrNotEmptyMsg(aStr, aMessage, sStop) \
  lua_getglobal(lstate, "reportCAssertion");        \
  lua_pushboolean(lstate, *(aStr) != 0);            \
  lua_pushstring(lstate, (aMessage));               \
  lua_pushfstring(lstate,                           \
      "Expected [%s] not to be empty.",             \
      (aStr)                                        \
    );                                              \
  lua_CTestCall(3, sStop)

#define AssertStrNotEmptyStop(aStr)    \
  AssertStrNotEmptyMsg(aStr, "", TRUE)
  
#define AssertStrNotEmpty(aStr)         \
  AssertStrNotEmptyMsg(aStr, "", FALSE)
\stopCHeader

\startTestCase[should succeed if a string is not empty]
\startCTest
  AssertStrNotEmpty("a non empty string");
\stopCTest
\stopTestCase

\startTestCase[should fail is a string is empty]
\startCTest
StartAssertShouldFail("","","");
  AssertStrNotEmpty("");
StopAssertShouldFail();
\stopCTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertStrEquals]

\startCHeader
#define AssertStrEqualsMsg(strA, strB, aMessage, sStop) \
  lua_getglobal(lstate, "reportCAssertion");            \
  lua_pushboolean(lstate, strcmp((strA), (strB)) == 0); \
  lua_pushstring(lstate, (aMessage));                   \
  lua_pushfstring(lstate,                               \
      "Expected [%s] to be equal to [%s].",             \
      (strA),                                           \
      (strB)                                            \
    );                                                  \
  lua_CTestCall(3, sStop)

#define AssertStrEqualsStop(strA, strB)    \
  AssertStrEqualsMsg(strA, strB, "", TRUE)
  
#define AssertStrEquals(strA, strB)         \
  AssertStrEqualsMsg(strA, strB, "", FALSE)
\stopCHeader

\startTestCase[should succeed if two strings are equal]
\startCTest
char* str1 = "aString";
char str2[256];
strncpy(str2, str1, 255);

AssertPtrNotEquals(str1, str2);
AssertStrEquals(str1, str2);
\stopCTest
\stopTestCase

\startTestCase[should fail if two strings are not equal]
\startCTest
StartAssertShouldFail("","","");
  AssertStrEquals("str1", "str2");
StopAssertShouldFail();
\stopCTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertStrNotEquals]

\startCHeader
#define AssertStrNotEqualsMsg(strA, strB, aMessage, sStop) \
  lua_getglobal(lstate, "reportCAssertion");               \
  lua_pushboolean(lstate, strcmp((strA), (strB)) != 0);    \
  lua_pushstring(lstate, (aMessage));                      \
  lua_pushfstring(lstate,                                  \
      "Expected [%s] not to be equal to [%s].",            \
      (strA),                                              \
      (strB)                                               \
    );                                                     \
  lua_CTestCall(3, sStop)

#define AssertStrNotEqualsStop(strA, strB)    \
  AssertStrNotEqualsMsg(strA, strB, "", TRUE)
  
#define AssertStrNotEquals(strA, strB)         \
  AssertStrNotEqualsMsg(strA, strB, "", FALSE)
\stopCHeader

\startTestCase[should succeed if two strings are not equal]
\startCTest
AssertStrNotEquals("str1", "str2");
\stopCTest
\stopTestCase

\startTestCase[should fail if two strings are equal]
\startCTest
char* str1 = "aString";
char str2[256];
strncpy(str2, str1, 255);

AssertPtrNotEquals(str1, str2);
StartAssertShouldFail("","","");
  AssertStrNotEquals(str1, str2);
StopAssertShouldFail();
\stopCTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertStrMatches]

\startCHeader
#define AssertStrMatchesMsg(aStr, aPattern, aMessage, sStop) \
{                                                            \
  lua_getglobal(lstate, "string");                           \
  lua_getfield(lstate, -1, "match");                         \
  lua_remove(lstate, -2);                                    \
  lua_pushstring(lstate, (aStr));                            \
  lua_pushstring(lstate, (aPattern));                        \
  lua_errorCall(2, 1);                                       \
  int matched = !lua_isnil(lstate, -1);                      \
  lua_pop(lstate, 1);                                        \
  lua_getglobal(lstate, "reportCAssertion");                 \
  lua_pushboolean(lstate, matched);                          \
  lua_pushstring(lstate, (aMessage));                        \
  lua_pushfstring(lstate,                                    \
      "Expected [%s] to match pattern [%s].",                \
      (aStr),                                                \
      (aPattern)                                             \
    );                                                       \
  lua_CTestCall(3, sStop);                                   \
}

#define AssertStrMatchesStop(aStr, aPattern)    \
  AssertStrMatchesMsg(aStr, aPattern, "", TRUE)

#define AssertStrMatches(aStr, aPattern)         \
  AssertStrMatchesMsg(aStr, aPattern, "", FALSE)
\stopCHeader

\startTestCase[should succeed if a string mathces a pattern]
\startCTest
AssertStrMatches("a test string", "test");
AssertStrMatches("a test string", "te%a+");
\stopCTest
\stopTestCase

\startTestCase[should fail is a string does not match a pattern]
\startCTest
StartAssertShouldFail("","","");
  AssertStrMatches("a test string", "no match");
StopAssertShouldFail();
\stopCTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertStrNotMatch]

\startCHeader
#define AssertStrDoesNotMatchMsg(aStr, aPattern, aMessage, sStop) \
{                                                                 \
  lua_getglobal(lstate, "string");                                \
  lua_getfield(lstate, -1, "match");                              \
  lua_remove(lstate, -2);                                         \
  lua_pushstring(lstate, (aStr));                                 \
  lua_pushstring(lstate, (aPattern));                             \
  lua_errorCall(2, 1);                                            \
  int matched = !lua_isnil(lstate, -1);                           \
  lua_pop(lstate, 1);                                             \
  lua_getglobal(lstate, "reportCAssertion");                      \
  lua_pushboolean(lstate, !matched);                              \
  lua_pushstring(lstate, (aMessage));                             \
  lua_pushfstring(lstate,                                         \
      "Expected [%s] to not match pattern [%s].",                 \
      (aStr),                                                     \
      (aPattern)                                                  \
    );                                                            \
  lua_CTestCall(3, sStop);                                        \
}

#define AssertStrDoesNotMatchStop(aStr, aPattern)    \
  AssertStrDoesNotMatchMsg(aStr, aPattern, "", TRUE)
  
#define AssertStrDoesNotMatch(aStr, aPattern)         \
  AssertStrDoesNotMatchMsg(aStr, aPattern, "", FALSE)
\stopCHeader

\startTestCase[should succeed if a string does not match a pattern]
\startCTest
AssertStrDoesNotMatch("a test string", "no match");
\stopCTest
\stopTestCase

\startTestCase[should fail if a string does match a pattern]
\startCTest
StartAssertShouldFail("","","");
  AssertStrDoesNotMatch("a test string", "test");
StopAssertShouldFail();
\stopCTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertDblEquals]

\startCHeader
#define AssertDblEqualsMsg(dblA, dblB, tol, aMessage, sStop) \
  lua_getglobal(lstate, "reportCAssertion");                 \
  lua_pushboolean(lstate, fabs((dblA) - (dblB)) < (tol));    \
  lua_pushstring(lstate, (aMessage));                        \
  lua_pushfstring(lstate,                                    \
      "Expected %f to be equal to %f with tolerance of %f.", \
      (dblA),                                                \
      (dblB),                                                \
      (tol)                                                  \
    );                                                       \
  lua_CTestCall(3, sStop)

#define AssertDblEqualsStop(dblA, dblB, tol)    \
  AssertDblEqualsMsg(dblA, dblB, tol, "", TRUE)

#define AssertDblEquals(dblA, dblB, tol)         \
  AssertDblEqualsMsg(dblA, dblB, tol, "", FALSE)
\stopCHeader

\startTestCase[should succeed if two doubles are equal]
\startCTest
AssertDblEquals(0.1, 0.1, 0.1);
AssertDblEquals(0.11, 0.1, 0.2);
\stopCTest
\stopTestCase

\startTestCase[should fail if two doubles are not equal]
\startCTest
StartAssertShouldFail("","","");
  AssertDblEquals(1.1, 2.1, 0.1);
StopAssertShouldFail();
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertDblNotEqals]

\startCHeader
#define AssertDblNotEqualsMsg(dblA, dblB, tol, aMessage, sStop)  \
  lua_getglobal(lstate, "reportCAssertion");                     \
  lua_pushboolean(lstate, (tol) <= fabs((dblA) - (dblB)));       \
  lua_pushstring(lstate, (aMessage));                            \
  lua_pushfstring(lstate,                                        \
      "Expected %f not to be equal to %f with tolerance of %f.", \
      (dblA),                                                    \
      (dblB),                                                    \
      (tol)                                                      \
    );                                                           \
  lua_CTestCall(3, sStop)

#define AssertDblNotEqualsStop(dblA, dblB, tol) \
  AssertDblNotEqualsMsg(dblA, dblB, tol, "", TRUE)

#define AssertDblNotEquals(dblA, dblB, tol)    \
  AssertDblNotEqualsMsg(dblA, dblB, tol, "", FALSE)

// end of t-contests.h
\stopCHeader

\startTestCase[should succeed if two doubles are not equal]
\startCTest
AssertDblNotEquals(1.1, 2.1, 0.1);
\stopCTest
\stopTestCase

\startTestCase[should fail if two doubles are equal]
\startCTest
StartAssertShouldFail("","","");
  AssertDblNotEquals(0.1, 0.1, 0.1);
StopAssertShouldFail();
StartAssertShouldFail("","","");
  AssertDblNotEquals(0.11, 0.1, 0.2);
StopAssertShouldFail();
\stopCTest
\stopTestCase

\stopTestSuite

\CTestsTeardown\
\startCTest
  // this is the CTest teardown
\stopCTest
