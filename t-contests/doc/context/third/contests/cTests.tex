% A ConTeXt document [master document: contests.tex]

\chapter[title=C Unit Testing]

We will eventually include a collection of C unit tests.

\startMkIVCode
\definetyping[CTest]
\setuptyping[CTest][option=cpp]

\let\oldStopCTest=\stopCTest
\def\stopCTest{%
  \oldStopCTest%
  \directlua{thirddata.contests.addCTest('_typing_')}
}

\def\setCTestStream#1{%
  \directlua{
    thirddata.contests.setCTestStream('#1')
  }
}

\def\createCTestFile#1#2#3{%
  \directlua{
    thirddata.contests.createCTestFile('#1', '#2', '#3')
  }
}
\stopMkIVCode

\startLuaCode
local function addCTest(bufferName)
  local bufferContents = buffers.getcontent(bufferName):gsub("\13", "\n")
  local suite          = tests.curSuite
  local case           = suite.curCase
  case.cTests          = case.cTests or { }
  local cTests         = case.cTests
  tests.curCTestStream = tests.curCTestStream or 'default'
  local cTestStream    = tests.curCTestStream
  cTests[cTestStream]  = cTests[cTestStream] or { }
  tInsert(cTests[cTestStream], bufferContents)
end

contests.addCTest = addCTest

local function setCTestStream(aCodeStream)
  if type(aCodeStream) ~= 'string'
    or #aCodeStream < 1 then
    aCodeStream = 'default'
  end
  tests.curCTestStream = aCodeStream
end

contests.setCTestStream = setCTestStream

local function createCTestFile(aCodeStream, aFilePath, aFileHeader)
  if type(aFilePath) ~= 'string'
    or #aFilePath < 1 then
    return
  end

  local outFile = io.open(aFilePath, 'w')
  if not outFile then
    return
  end

  if type(aFileHeader) == 'string'
    and 0 < #aFileHeader then
    outFile:write(aFileHeader)
    outFile:write('\n\n')
  end

  outFile:write('#include "t-contests.h"\n')
  outFile:write('\n\n')

  if type(aCodeStream) ~= 'string'
    or #aCodeStream < 1 then
    aCodeStream = 'default'
  end

  tests.suites = tests.suites or { }

  local suiteNums = { }
  for i, aTestSuite in ipairs(tests.suites) do
    aTestSuite.cases = aTestSuite.cases or { }
    local suiteCaseBuf = { }
    local caseNums     = { }
    for j, aTestCase in ipairs(aTestSuite.cases) do
      aTestCase.cTests = aTestCase.cTests or { }
      local cTests     = aTestCase.cTests
      if cTests[aCodeStream] then
        tInsert(caseNums, j)
        tInsert(suiteCaseBuf, 'void ts'..toStr(i)..'_tc'..toStr(j)..'(lua_State *lstate){\n\n')
        tInsert(suiteCaseBuf, '  StartTestCase(\n')
        tInsert(suiteCaseBuf, '    "'..aTestCase.desc..'",\n')
        tInsert(suiteCaseBuf, '    "'..aTestCase.fileName..'",\n')
        tInsert(suiteCaseBuf, '    '..toStr(aTestCase.startLine)..',\n')
        tInsert(suiteCaseBuf, '    '..toStr(aTestCase.lastLine)..'\n')
        tInsert(suiteCaseBuf, '  );\n\n  ')
        local cTestsCode = tConcat(cTests[aCodeStream], '\n')
        cTestsCode       = litProgs.splitString(cTestsCode)
        tInsert(suiteCaseBuf, tConcat(cTestsCode, '\n\n  '))
        tInsert(suiteCaseBuf, '\n\n  StopTestCase;\n\n')
        tInsert(suiteCaseBuf, '}\n\n')
      end
    end
    if 0 < #suiteCaseBuf then
      tInsert(suiteNums, i)
      outFile:write('//-------------------------------------------------------\n')
      outFile:write(tConcat(suiteCaseBuf))
      outFile:write('void ts'..toStr(i)..'(lua_State *lstate){\n\n')
      outFile:write('  StartTestSuite(\n')
      outFile:write('    "'..aTestSuite.desc..'"\n')
      outFile:write('  );\n\n')
      for j, aCaseNum in ipairs(caseNums) do
        outFile:write('  ts'..toStr(i)..'_tc'..toStr(aCaseNum)..'(lstate);\n\n')
      end
      outFile:write('  StopTestSuite;\n\n')
      outFile:write('}\n\n')
    end
  end

  outFile:write('//-------------------------------------------------------\n')
  outFile:write('int main(){\n\n')
  outFile:write('  lua_State *lstate = luaL_newstate();\n')
  outFile:write('  luaL_openlibs(lstate);\n')
  outFile:write('  if luaL_dofile(lstate, "build/t-contests-cTests.lua") {\n')
  outFile:write('    fprintf(stderr, "Could not load cTests\\n");\n')
  outFile:write('    fprintf(stderr, "%s\\n", lua_tostring(lstate, 1));\n')
  outFile:write('    exit(-1);\n')
  outFile:write('  }\n\n')
  for i, aSuiteNum in ipairs(suiteNums) do
    outFile:write('  ts'..toStr(aSuiteNum)..'(lstate);\n')
  end
  outFile:write('\n  return 0;\n')
  outFile:write('}\n')

  outFile:close()
end

contests.createCTestFile = createCTestFile
\stopLuaCode

\startCHeader
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

#ifndef FALSE
#define FALSE 0
#endif

#ifndef TRUE
#define TRUE 1
#endif

#ifndef NULL
#define NULL 0
#endif

#define lua_errorCall(numArgs, numRtn)             \
  if (lua_pcall(lstate, (numArgs), (numRtn), 0)) { \
    fprintf(stderr,                                \
      "LUA error in file %s at line %d\n",         \
      __FILE__, __LINE__                           \
    );                                             \
  }
  
#define lua_CTestCall(numArgs)        \
  lua_pushstring(lstate, __FILE__);   \
  lua_pushunsigned(lstate, __LINE__); \
  lua_errorCall((numArgs)+2, 0)

#define StartTestSuite(aDesc)              \
  lua_getglobal(lstate, "startTestSuite"); \
  lua_pushstring(lstate, (aDesc));         \
  lua_CTestCall(1)

#define StopTestSuite                     \
  lua_getglobal(lstate, "stopTestSuite"); \
  lua_CTestCall(0)

#define StartTestCase(aDesc, aFileName, startLine, lastLine) \
  lua_getglobal(lstate, "startTestCase");                    \
  lua_pushstring(lstate, (aDesc));                           \
  lua_pushstring(lstate, (aFileName));                       \
  lua_pushunsigned(lstate, (startLine));                     \
  lua_pushunsigned(lstate, (lastLine));                      \
  lua_CTestCall(4)

#define StopTestCase                     \
  lua_getglobal(lstate, "stopTestCase"); \
  lua_CTestCall(0)

\stopCHeader

\setLuaCodeStream{cTests}
\startLuaCode
-- This is the lua code associated with the t-contests-cTests

local cTests  = { }
local tInsert = table.insert
local sFmt    = string.format

function startTestSuite(aDesc, testFileName, testFileLine)
  cTests.curSuite = { }
  local curSuite  = cTests.curSuite
  curSuite.desc   = aDesc
  curSuite.passed = true
  io.stdout:write("\n-------------------------------------\n")
  io.stdout:write(sFmt("TS: %s\n", aDesc))
end

function stopTestSuite(testFileName, testFileLine)
  cTests.suites = cTests.suites or { }
  if cTests.curSuite then
    tInsert(cTests.suites, cTests.curSuite)
  end
  cTests.curSuite = { }
end

function startTestCase(
  aDesc, srcFileName, srcStartLine, srcLastLine,
  testFileName, testFileLine)
  cTests.curSuite   = cTests.curSuite or { }
  local curSuite    = cTests.curSuite
  curSuite.curCase  = { }
  local curCase     = curSuite.curCase
  curCase.desc      = aDesc
  curCase.fileName  = srcFileName
  curCase.startLine = srcStartLine
  curCase.lastLine  = srcLastLine
  curCase.passed    = true
  io.stdout:write(sFmt("  TC: %s\n", aDesc))
end

function stopTestCase(testFileName, testFileLine)
  cTests.curSuite = cTests.curSuite or { }
  local curSuite  = cTests.curSuite
  curSuite.cases  = curSuite.cases or { }
  if curSuite.curCase then
    tInsert(curSuite.cases, curSuite.curCase)
  end
  curSuite.curCase = { }
end
\stopLuaCode

\section[title=Assertions]

\startLuaCode
local function logFailure(reason, suiteDesc, caseDesc,
                          testMsg, errMsg, fileInfo)
  local failure = {}
  failure.reason    = reason
  failure.suiteDesc = suiteDesc
  failure.caseDesc  = caseDesc
  failure.testMsg   = testMsg
  failure.errMsg    = errMsg
  failure.fileInfo  = fileInfo
  io.stdout:write(sFmt('    %s\n', reason))
  io.stdout:write(sFmt('    %s\n', testMsg))
  io.stdout:write(sFmt('    %s\n', errMsg))
  io.stdout:write(sFmt('    %s\n', fileInfo))
  io.stdout:write('\n\n')
  return failure
end

function reportCAssertion(
  theCondition, aMessage, theReason,
  testFileName, testFileLine)
  cTests.curSuite  = cTests.curSuite or { }
  local curSuite   = cTests.curSuite
  curSuite.curCase = curSuite.curCase or { }
  local curCase    = curSuite.curCase
  
  if type(curCase.shouldFail) == 'table' then
    local shouldFail   = curCase.shouldFail
    local innerMessage = aMessage
    local innerReason  = theReason
    theReason          = nil
    theCondition       = not theCondition

    if theReason ~= nil
      and shouldFail.messagePattern ~= nil
      and type(shouldFail.messagePattern) == 'string'
      and 0 < #shouldFail.messagePattern
      and innerMessage:match(shouldFail.messagePattern) then
      -- do nothing
    else
      theReason = sFmt('Expected inner message [%s] to match [%s]',
        innerMessage, shouldFail.messagePattern)
    end

    if theReason ~= nil
      and shouldFail.reasonPattern ~= nil
      and type(shouldFail.reasonPattern) == 'string'
      and 0 < #shouldFail.reasonPattern
      and innerReason:match(shouldFail.reasonPattern) then
      -- do nothing
    else
      theReason = sFmt('Expected inner failure reason [%s] to match [%s]',
        innerReason, shouldFail.reasonPattern)
    end
    
    if theReason ~= nil then
      theReason = sFmt('Expected inner assertion [%s] to fail',
        innerMessage)
    end
    aMessage = shouldFail.message
    curCase.shouldFail = nil
  end
  
  if theCondition then
    -- record stats
  else
    curSuite.passed = false
    curCase.passed  = false
    local failure = logFailure(
      'CTest FAILED',
      curSuite.desc,
      curCase.desc,
      aMessage,
      theReason,
      sFmt('in file: %s between lines %s and %s',
        curCase.fileName,
        toStr(curCase.startLine),
        toStr(curCase.lastLine)
      )
    )
    tInsert(cTests.failures, failure)
  end
end
\stopLuaCode

\startTestSuite[assertShouldFail environment]

\startCHeader
#define StartAssertShouldFail(messagePattern, reasonPattern, aMessage) \
  lua_getglobal(lstate, "startCShouldFail");                           \
  lua_pushstring(lstate, (messagePattern));                            \
  lua_pushstring(lstate, (reasonPattern));                             \
  lua_pushstring(lstate, (aMessage));                                  \
  lua_CTestCall(3)

#define StopAssertShouldFail                \
  lua_getglobal(lstate, "stopCShouldFail"); \
  lua_CTestCall(0)
\stopCHeader

\startLuaCode
function startCShouldFail(
  messagePattern, reasonPattern, aMessage,
  testFileName, testFileLine)
  cTests.curSuite    = cTests.curSuite or { }
  local curSuite     = cTests.curSuite
  curSuite.curCase   = curSuite.curCase or { }
  local curCase      = curSuite.curCase
  curCase.shouldFail = { }
  local shouldFail   = curCase.shouldFail
  shouldFail.messagePattern = messagePattern
  shouldFail.reasonPattern  = reasonPattern
  shouldFail.message        = aMessage
end

function stopCShouldFail(testFileName, testFileLine)
  -- do nothing at the moment
end
\stopLuaCode

\stopTestSuite

\startTestSuite[assertFail]

\startCHeader
#define AssertFailMsg(aMessage)              \
  lua_getglobal(lstate, "reportCAssertion"); \
  lua_pushboolean(lstate, FALSE);            \
  lua_pushstring(lstate, (aMessage));        \
  lua_pushstring(lstate, "Failed");          \
  lua_CTestCall(3)
  
#define AssertFail() \
  AssertFailMsg("")
\stopCHeader

\stopTestSuite

\startTestSuite[assertSucceed]

\startCHeader
#define AssertSucceedMsg(aMessage)           \
  lua_getglobal(lstate, "reportCAssertion"); \
  lua_pushboolean(lstate, TRUE);             \
  lua_pushstring(lstate, (aMessage));        \
  lua_pushstring(lstate, "Succeeded");       \
  lua_CTestCall(3)

#define AssertSucceed() \
  AssertSucceedMsg("")
\stopCHeader

\startTestCase[should always succeed]

\startCTest
  AssertSucceed();
\stopCTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertIntTrue]

\startCHeader
#define AssertIntTrueMsg(anInt, aMessage)    \
  lua_getglobal(lstate, "reportCAssertion"); \
  lua_pushboolean(lstate, (anInt));          \
  lua_pushstring(lstate, (aMessage));        \
  lua_pushfstring(lstate,                    \
      "Expected %d to be TRUE.",             \
      (anInt)                                \
    );                                       \
  lua_CTestCall(3)

#define AssertIntTrue(anInt) \
  AssertIntTrueMsg(anInt, "")
\stopCHeader

\startTestCase[should succeed if true]
\startCTest
  AssertIntTrue(TRUE);
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertIntFalse]

\startCHeader
#define AssertIntFalseMsg(anInt, aMessage)   \
  lua_getglobal(lstate, "reportCAssertion"); \
  lua_pushboolean(lstate, !(anInt));         \
  lua_pushstring(lstate, (aMessage));        \
  lua_pushfstring(lstate,                    \
      "Expected %d to be FALSE.",            \
      (anInt)                                \
    );                                       \
  lua_CTestCall(3)

#define AssertIntFalse(anInt) \
  AssertIntFalseMsg(anInt, "")
\stopCHeader

\stopTestSuite

\startTestSuite[assertIntEquals]

\startCHeader
#define AssertIntEqualsMsg(intA, intB, aMessage) \
  lua_getglobal(lstate, "reportCAssertion");     \
  lua_pushboolean(lstate, (intA) == (intB));     \
  lua_pushstring(lstate, (aMessage));            \
  lua_pushfstring(lstate,                        \
      "Expected %d to be equal to %d.",          \
      (intA),                                    \
      (intB)                                     \
    );                                           \
  lua_CTestCall(3)

#define AssertIntEquals(intA, intB) \
  AssertIntEqualsMsg(intA, intB, "")
\stopCHeader

\stopTestSuite

\startTestSuite[assertIntNotEquals]

\startCHeader
#define AssertIntNotEqualsMsg(intA, intB, aMessage) \
  lua_getglobal(lstate, "reportCAssertion");        \
  lua_pushboolean(lstate, (intA) != (intB));        \
  lua_pushstring(lstate, (aMessage));               \
  lua_pushfstring(lstate,                           \
      "Expected %d not to be equal to %d.",         \
      (intA),                                       \
      (intB)                                        \
    );                                              \
  lua_CTestCall(3)

#define AssertIntNotEquals(intA, intB) \
  AssertIntNotEqualsMsg(intA, intB, "")
\stopCHeader

\stopTestSuite

\startTestSuite[assertPrtNull]

\startCHeader
#define AssertPtrNullMsg(aPtr, aMessage)     \
  lua_getglobal(lstate, "reportCAssertion"); \
  lua_pushboolean(lstate, (aPtr) == (NULL)); \
  lua_pushstring(lstate, (aMessage));        \
  lua_pushfstring(lstate,                    \
      "Expected %p to be NULL.",             \
      (aPtr)                                 \
    );                                       \
  lua_CTestCall(3)

#define AssertPtrNull(aPtr) \
  AssertPtrNullMsg(aPtr, "")
\stopCHeader

\stopTestSuite

\startTestSuite[assertPtrNotNull]

\startCHeader
#define AssertPtrNotNullMsg(aPtr, aMessage)  \
  lua_getglobal(lstate, "reportCAssertion"); \
  lua_pushboolean(lstate, (aPtr) != (NULL)); \
  lua_pushstring(lstate, (aMessage));        \
  lua_pushfstring(lstate,                    \
      "Expected %p not to be NULL.",         \
      (aPtr)                                 \
    );                                       \
  lua_CTestCall(3)

#define AssertPtrNotNull(aPtr) \
  AssertPtrNotNullMsg(aPtr, "")
\stopCHeader

\stopTestSuite

\startTestSuite[assertPtrEquals]

\startCHeader
#define AssertPtrEqualsMsg(ptrA, ptrB, aMessage) \
  lua_getglobal(lstate, "reportCAssertion");     \
  lua_pushboolean(lstate, (ptrA) == (ptrB));     \
  lua_pushstring(lstate, (aMessage));            \
  lua_pushfstring(lstate,                        \
      "Expected %p to be equal to %p.",          \
      (ptrA),                                    \
      (ptrB)                                     \
    );                                           \
  lua_CTestCall(3)

#define AssertPtrEquals(ptrA, ptrB) \
  AssertPtrEqualsMsg(ptrA, ptrB, "")
\stopCHeader

\stopTestSuite

\startTestSuite[assertPtrNotEquals]

\startCHeader
#define AssertPtrNotEqualsMsg(ptrA, ptrB, aMessage) \
  lua_getglobal(lstate, "reportCAssertion");        \
  lua_pushboolean(lstate, (ptrA) != (ptrB));        \
  lua_pushstring(lstate, (aMessage));               \
  lua_pushfstring(lstate,                           \
      "Expected %p not to be equal to %p.",         \
      (ptrA),                                       \
      (ptrB)                                        \
    );                                              \
  lua_CTestCall(3)

#define AssertPtrNotEquals(ptrA, ptrB) \
  AssertPtrNotEqualsMsg(ptrA, ptrB, "")
\stopCHeader

\stopTestSuite

\startTestSuite[assertStrEmpty]

\startCHeader
#define AssertStrEmptyMsg(aStr, aMessage)    \
  lua_getglobal(lstate, "reportCAssertion"); \
  lua_pushboolean(lstate, *(aStr) == 0);     \
  lua_pushstring(lstate, (aMessage));        \
  lua_pushfstring(lstate,                    \
      "Expected [%s] to be empty.",          \
      (aStr)                                 \
    );                                       \
  lua_CTestCall(3)

#define AssertStrEmpty(aStr) \
  AssertStrEmptyMsg(aStr, "")
\stopCHeader

\stopTestSuite

\startTestSuite[assertStrNotEmpty]

\startCHeader
#define AssertStrNotEmptyMsg(aStr, aMessage) \
  lua_getglobal(lstate, "reportCAssertion"); \
  lua_pushboolean(lstate, *(aStr) != 0);     \
  lua_pushstring(lstate, (aMessage));        \
  lua_pushfstring(lstate,                    \
      "Expected [%s] not to be empty.",      \
      (aStr)                                 \
    );                                       \
  lua_CTestCall(3)

#define AssertStrNotEmpty(aStr) \
  AssertStrNotEmptyMsg(aStr, "")
\stopCHeader

\stopTestSuite

\startTestSuite[assertStrEquals]

\startCHeader
#define AssertStrEqualsMsg(strA, strB, aMessage)        \
  lua_getglobal(lstate, "reportCAssertion");            \
  lua_pushboolean(lstate, strcmp((strA), (strB)) == 0); \
  lua_pushstring(lstate, (aMessage));                   \
  lua_pushfstring(lstate,                               \
      "Expected [%s] to be equal to [%s].",             \
      (strA),                                           \
      (strB)                                            \
    );                                                  \
  lua_CTestCall(3)

#define AssertStrEquals(strA, strB) \
  AssertStrEqualsMsg(strA, strB, "")
\stopCHeader

\stopTestSuite

\startTestSuite[assertStrNotEquals]

\startCHeader
#define AssertStrNotEqualsMsg(strA, strB, aMessage)     \
  lua_getglobal(lstate, "reportCAssertion");            \
  lua_pushboolean(lstate, strcmp((strA), (strB)) != 0); \
  lua_pushstring(lstate, (aMessage));                   \
  lua_pushfstring(lstate,                               \
      "Expected [%s] not to be equal to [%s].",         \
      (strA),                                           \
      (strB)                                            \
    );                                                  \
  lua_CTestCall(3)

#define AssertStrNotEquals(strA, strB) \
  AssertStrNotEqualsMsg(strA, strB, "")
\stopCHeader

\stopTestSuite

\startTestSuite[assertStrMatches]

\startCHeader
#define AssertStrMatchesMsg(aStr, aPattern, aMessage) \
{                                                     \
  lua_getglobal(lstate, "string");                    \
  lua_getfield(lstate, -1, "match")                   \
  lua_remove(lstate, -2);                             \
  lua_pushstring(lstate, (aStr));                     \
  lua_pushstring(lstate, (aPattern));                 \
  lua_errorCall(2, 1);                                \
  int matched = lua_isnil(lstate, 1);                 \
  lua_pop(lstate, 1);                                 \
  lua_getglobal(lstate, "reportCAssertion");          \
  lua_pushboolean(lstate, matched);                   \
  lua_pushstring(lstate, (aMessage));                 \
  lua_pushfstring(lstate,                             \
      "Expected [%s] to match pattern [%s].",         \
      (aStr),                                         \
      (aPattern)                                      \
    );                                                \
  lua_CTestCall(3);                                   \
}

#define AssertStrMatches(aStr, aPattern) \
  AssertStrMatchesMsg(aStr, aPattern, "")
\stopCHeader

\stopTestSuite

\startTestSuite[assertStrNotMatch]

\startCHeader
#define AssertStrDoesNotMatchMsg(aStr, aPattern, aMessage) \
{                                                          \
  lua_getglobal(lstate, "string");                         \
  lua_getfield(lstate, -1, "match")                        \
  lua_remove(lstate, -2);                                  \
  lua_pushstring(lstate, (aStr));                          \
  lua_pushstring(lstate, (aPattern));                      \
  lua_errorCall(2, 1);                                     \
  int matched = lua_isnil(lstate, 1);                      \
  lua_pop(lstate, 1);                                      \
  lua_getglobal(lstate, "reportCAssertion");               \
  lua_pushboolean(lstate, ! matched);                      \
  lua_pushstring(lstate, (aMessage));                      \
  lua_pushfstring(lstate,                                  \
      "Expected [%s] to not match pattern [%s].",          \
      (aStr),                                              \
      (aPattern)                                           \
    );                                                     \
  lua_CTestCall(3);                                        \
}

#define AssertStrDoesNotMatch(aStr, aPattern) \
  AssertStrDoesNotMatchMsg(aStr, aPattern, "")
\stopCHeader

\stopTestSuite

\startTestSuite[assertDblEquals]

\startCHeader
#define AssertDblEqualsMsg(dblA, dblB, tol, aMessage)        \
  lua_getglobal(lstate, "reportCAssertion");                 \
  lua_pushboolean(lstate, fabs((dblA) - (dblB)) < (tol));    \
  lua_pushstring(lstate, (aMessage));                        \
  lua_pushfstring(lstate,                                    \
      "Expected %f to be equal to %f with tolerance of %f.", \
      (dblA),                                                \
      (dblB),                                                \
      (tol)                                                  \
    );                                                       \
  lua_CTestCall(3)

#define AssertDblEquals(dblA, dblB, tol) \
  AssertDblEqualsMsg(dblA, dblB, tol, "")
\stopCHeader

\stopTestSuite

\startTestSuite[assertDblNotEqals]

\startCHeader
#define AssertDblNotEqualsMsg(dblA, dblB, tol, aMessage)         \
  lua_getglobal(lstate, "reportCAssertion");                     \
  lua_pushboolean(lstate, (tol) <= fabs((dblA) - (dblB)));       \
  lua_pushstring(lstate, (aMessage));                            \
  lua_pushfstring(lstate,                                        \
      "Expected %f not to be equal to %f with tolerance of %f.", \
      (dblA),                                                    \
      (dblB),                                                    \
      (tol)                                                      \
    );                                                           \
  lua_CTestCall(3)

#define AssertDblNotEquals(dblA, dblB, tol) \
  AssertDblNotEqualsMsg(dblA, dblB, "")

// end of t-contests.h
\stopCHeader

\stopTestSuite
