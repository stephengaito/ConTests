% A ConTeXt document [master document: contests.tex]

\startchapter[title=MkIV Unit Testing]

We will eventually include MkIV unit testing.

\section[title=Test cases]

\def\startConTest{\relax}
\def\stopConTest{\relax}

\startMkIVCode

\def\startConTest{
  \directlua{thirddata.contests.startConTests()}
}

\def\stopConTest{
  \directlua{thriddata.contests.stopConTests()}
}

\stopMkIVCode

\startLuaCode

local function conTestShowErrorHook()
  tests.curSuite.curCase.caughtError = true
  texio.write_nl("Caught error")
end

function contests.startConTests()
  tests.curSuite.curCase.caughtError = false
  -- save logging.... -- alas we can not ;-(
  -- turn logging to no-stop/batch
  callback.register('show_error_hook', conTestShowErrorHook)
end

function contests.stopConTests()
  callback.register('show_error_hook', nil)
  -- turn logging back to original value
end

\stopLuaCode

\section[title=Assertions]

We start by defining two helper functions to declare (to the lua code) 
that an assertion together with its message and reason (for failure) has 
either failed or succeeded. 

\startMkIVCode
\def\assertionFailed#1#2{%
  \directlua{thirddata.contests.reportMkIVAssertion(false, '#1', '#2')}
}

\def\assertionSucceeded#1{%
  \directlua{thirddata.contests.reportMkIVAssertion(true, '#1', '')}
}
\stopMkIVCode

\startLuaCode
function contests.reportMkIVAssertions(thCondition, aMessage, theReason)
  local curSuite  = tests.curSuite
  curSuite.passed = curSuite.passed or true
  local curCase   = curSuite.curCase
  curCase.passed  = curCase.passed or true
  mkivAssertions.attempted = mkivAssertions.attempted + 1

  if theCondition then
    mkivAssertions.passed = mkivAssertions.passed + 1
  else
    curSuite.passed = false
    curCase.passed  = false
    mkivAssertions.failed = mkivAssertions.failed + 1
    local failure = logFailue(
      "ConTest FAILED",
      curSuite.desc,
      curCase.desc,
      aMessage,
      theReason,
      fmt("in file: %s between lines %s and %s",
        curCase.fileName,
        toStr(curCase.startLine),
        toStr(curCase.stopLine)
      )
    )
    reportFailure(failure, false)
    table_insert(tests.failure, failure)
  end
end

\stopLuaCode

As with the implementation of both the LuaTests and CTests, the heart of 
the ConTests is the ability to throw and capture errors. In this case it 
will be \TeX\ errors, when run, a TestCase will capture all \TeX\ errors 
and provide a report of where those errors happened. 

\startTestSuite[assertThrowsError environment]

\startMkIVCode
\def\startAssertThrowsError#1{%
  \def\startAssertionMessage{#1}
  \directlua{thirddata.contests.tests.curSuite.curCase.caughtError = false}
}

\def\stopAssertThrowsError{%
  \directlua{thirddata.contests.reportMkIVAssertion(
    thirddata.contests.tests.curSuite.curCase.caughtError,
    '\startAssertionMessage',
    'Expected an error to be thrown'
  )}
}
\stopMkIVCode

\stopTestSuite

\startTestSuite[assertDoesNotThrowError]

\startMkIVCode
\def\startAssertDoesNotThrowError#1{%
  \def\startAssertionMessage{#1}
  \directlua{thirddata.contests.tests.curSuite.curCase.caughtError = false}
}

\def\stopAssertDoesNotThrowError{%
  \directlua{thirddata.contests.reportMkIVAssertion(
    not thirddata.contests.tests.curSuite.curCase.caughtError,
    '\startAssertionMessage',
    'Expected no error to be thrown'
  )}
}
\stopMkIVCode

\stopTestSuite

\startTestSuite[assertFail]

The \type{\assertFail} assertion always fails.

\startMkIVCode
\def\assertFail#1{\assertionFailed{#1}{(Failed)}}
\stopMkIVCode

\stopTestSuite

\startTestSuite[assertSucceed]

The \type{\assertSucceed} assertion always succeeds.

\startMkIVCode
\def\assertSucceed#1{\assertionSucceeded{#1}}
\stopMkIVCode

\stopTestSuite

\startTestSuite[assertDefined]

The \type{\assertDefined} assertion confirms that the csname provided 
is defined as a \TeX\ command. 

% As another example, one can test whether a control sequence is defined by 

%\def\ifUnDefinedCs#1{\expandafter
%\ifx\csname#1\endcsname\relax}

%\ifUnDefinedCs{parindent} %is not true
%\ifUnDefinedCs{undefined} %is (one hopes) true

% This uses the fact that a \csname...\endcsname command is equivalent to 
% \relax if the control has not been defined before. Unfortunately, this 
% test also turns out true if a control has been \let to \relax. 

% See: 13.2.3 on page 141 of TeXbyTopic v1.4-2013

\startMkIVCode
\def\assertDefined#1#2{%
  \expandafter\ifx\csname#1\endcsname\relax%
    \assertionFailed{#2}{Expected #1 to be defined}%
  \else%
    \assertionSucceeded{#2}{}%
  \fi
}
\stopMkIVCode

\stopTestSuite

\startTestSuite[assertNotDefined]

The \type{\assertNotDefined} assertion confirms that the csname provided 
is not defined as a \TeX\ command. 

\startMkIVCode
\def\assertNotDefined#1#2{%
  \expandafter\ifx\csname#1\endcsname\relax%
    \assertionSucceeded{#2}%
  \else%
    \assertionFailed{#2}{Expected #1 to not be defined}%
  \fi
}
\stopMkIVCode

\stopTestSuite

\startTestSuite[assertStringMatches]

The \type{\assertStringMatches} assertion confirms that the fully expanded 
result, taken as a lua string, matches the associated lua pattern match. 

\startMkIVCode
\def\assertStringMatches#1#2#3{%
  \directlua{
    thirddata.contests.reportMkIVAssertions(
      string.match('#1','#2'),
      '#3',
      'Expected [#1] to match [#2]'
    )
  }
}
\stopMkIVCode

\stopTestSuite

\startTestSuite[assertStringDoesNotMatch]

The \type{\assertStringDoesNotMatch} assertion confirms that the fully expanded 
result, taken as a lua string, does not match the associated lua pattern match. 

\startMkIVCode
\def\assertStringMatches#1#2#3{%
  \directlua{
    thirddata.contests.reportMkIVAssertions(
      not string.match('#1','#2'),
      '#3',
      'Expected [#1] to not match [#2]'
    )
  }
}
\stopMkIVCode

\stopTestSuite

\startTestSuite[assertLua]

The \type{assertLua} environment allows the use of any of the lua 
assertions (defined below) inside a ConTest test case. 

\stopTestSuite

\stopchapter