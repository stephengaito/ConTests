% A ConTeXt document [master document: contests.tex]

\startchapter[title=MkIV Unit Testing]

We provide an evolving collection of unit test assertions in \ConTeXt. 

\section[title=Test cases]

\startMkIVCode

%%%%%%%%%%%%%%%%
% ConTest code %
%%%%%%%%%%%%%%%%

\definetyping[ConTest]
\setuptyping[ConTest][option=context]

\let\oldStopConTest=\stopConTest
\def\stopConTest{%
  \oldStopConTest%
  \directlua{thirddata.contests.addConTest('_typing_')}
}

\def\reportMkIVStats{%
  \directlua{thirddata.contests.reportStats('mkiv')}
}

\stopMkIVCode

\startLuaCode
------------------
-- ConTest code --
------------------

function contests.addConTest(bufferName)
  local bufferContents = buffers.getcontent(bufferName):gsub("\13", "\n")
  local suite = tests.curSuite
  local case  = suite.curCase
  case.mkiv   = case.mkiv or {}
  tInsert(case.mkiv, bufferContents)
end

function contests.runCurMkIVTestCase(suite, case)
  case.passed = case.passed or true
  case.mkiv   = case.mkiv   or { }
  local mkivChunk = tConcat(case.mkiv, '\n')
  if not mkivChunk:match('^%s*$') then
    local caseStats = tests.stats.mkiv.cases
    caseStats.attempted = caseStats.attempted + 1
    tex.print("\\directlua{thirddata.contests.startConTestImplementation()}")
    for i, aChunk in ipairs(case.mkiv) do
      for aLine in string.gmatch(aChunk, '[^\n]*') do
        if 0 < #aLine then
          tex.print(aLine)
        end
      end
    end
    tex.print("\\directlua{thirddata.contests.stopConTestImplementation()}")
  end
end

function contests.startConTestImplementation()
  -- nothing to do at the moment
end

function contests.stopConTestImplementation()
  local curCase  = tests.curSuite.curCase
  local caseStats = mkivStats.cases
  if curCase.passed then
    caseStats.passed = caseStats.passed + 1
  else
    caseStats.failed = caseStats.failed + 1
  end
end

\stopLuaCode

\section[title=Assertions]

We start by defining two helper functions to declare (to the lua code) 
that an assertion together with its message and reason (for failure) has 
either failed or succeeded. 

\startMkIVCode
\def\assertionFailed#1#2{%
  \directlua{thirddata.contests.reportMkIVAssertion(false, '#1', '#2')}
}

\def\assertionSucceeded#1{%
  \directlua{thirddata.contests.reportMkIVAssertion(true, '#1', '')}
}
\stopMkIVCode

\startLuaCode
function contests.reportMkIVAssertion(theCondition, aMessage, theReason)
  local curSuite  = tests.curSuite
  local curCase   = curSuite.curCase
  mkivAssertions.attempted = mkivAssertions.attempted + 1

  if type(curCase.shouldFail) == 'table'  then
    local shouldFail = curCase.shouldFail
    local innerMessage = aMessage
    local innerReason  = theReason
    theReason = nil
    theCondition = not theCondition
    if theReason ~= nil
      and shouldFail.messagePattern ~= nil
      and type(shouldFail.messagePattern) == 'string'
      and 0 < #shouldFail.messagePattern
      and aMessage:match(shouldFail.messagePattern) then
      -- do nothing
    else
      theReason = sFmt('Expected inner message [%s] to match [%s]',
        innerMessage, shouldFail.messagePattern)
    end
    if theReason ~= nil
      and shouldFail.reasonPattern ~= nil
      and type(shouldFail.reasonPattern) == 'string'
      and 0 < #shouldFail.reasonPattern
      and theReason:match(shouldFail.reasonPattern) then
      -- do nothing
    else
      theReason = sFmt('Expected inner failure reason [%s] to match [%s]',
        innerReason, shouldFail.reasonPattern)
    end
    if theReason ~= nil then
      theReason = 'Expected inner assertion ['..aMessage..'] to fail'
    end
    aMessage  = shouldFail.message
    curCase.shouldFail = nil
  end

  if theCondition then
    mkivAssertions.passed = mkivAssertions.passed + 1
    tex.print("\\noindent{\\green PASSED}")
  else
    curSuite.passed = false
    curCase.passed  = false
    mkivAssertions.failed = mkivAssertions.failed + 1
    local failure = logFailure(
      "ConTest FAILED",
      curSuite.desc,
      curCase.desc,
      aMessage,
      theReason,
      sFmt("in file: %s between lines %s and %s",
        curCase.fileName,
        toStr(curCase.startLine),
        toStr(curCase.lastLine)
      )
    )
    reportFailure(failure, false)
    tInsert(tests.failures, failure)
  end
end
\stopLuaCode

\startTestSuite[assertShouldFail environment]

The \type{assertShouldFail} environment provides a way to confirm that 
some \quote{inner} ConTest assertions have failed. The 
\type{\startAssertShouldFaile} command takes three arguments, a lua 
pattern to match against the inner message, a lua pattern to match against 
the inner reason, and an \quote{outer} message to be used by the 
\type{assertShouldFail} commands themselves. Upon successfully detecting 
the inner failure, the inner failure reports are removed. 

\startMkIVCode
\def\startAssertShouldFail#1#2#3{%
  \directlua{thirddata.contests.mkivAssertShouldFail('#1', '#2', '#3')}
}

\def\stopAssertShouldFail{\relax}

\stopMkIVCode

\startLuaCode
function contests.mkivAssertShouldFail(messagePattern, reasonPattern, aMessage)
  local curCase = tests.curSuite.curCase
  curCase.shouldFail = { }
  local shouldFail = curCase.shouldFail
  shouldFail.messagePattern = messagePattern
  shouldFail.reasonPattern  = reasonPattern
  shouldFail.message        = aMessage
end
\stopLuaCode

\startTestCase[should succeed if an inner assertion fails]

\startConTest
\startAssertShouldFail{Inner message}{(Failed)}{Outer message}
  \assertFail{Inner message}
\stopAssertShouldFail
\stopConTest

\stopTestCase

\startTestCase[should fail if an inner assertion does not fail]

\startConTest
\startAssertShouldFail%
  {Inner message}{Expected something}{Outer message}
  \startAssertShouldFail{}{}{Inner message}
    no flies on us.
  \stopAssertShouldFail
\stopAssertShouldFail
\stopConTest

\stopTestCase

\startTestCase[should fail if inner assertion fails with wrong message or reason]

\startConTest
\startAssertShouldFail{First outer message}{}{First outermost message}
\startAssertShouldFail{wrong}{}{First outer message}
  \assertFail{First inner message}
\stopAssertShouldFail
\stopAssertShouldFail

\startAssertShouldFail{Second outer message}{}{Second outermost message}
\startAssertShouldFail{}{wrong}{Second outer message}
  \assertFail{Second inner message}
\stopAssertShouldFail
\stopAssertShouldFail
\stopConTest

\stopTestCase

\stopTestSuite

\startTestSuite[assertFail]

The \type{\assertFail} assertion always fails.

\startMkIVCode
\def\assertFail#1{\assertionFailed{#1}{(Failed)}}
\stopMkIVCode

\startTestCase[should fail]

\startConTest
\startAssertShouldFail{Inner message}{}{Outer message}
  \assertFail{Inner message}
\stopAssertShouldFail
\stopConTest

\stopTestCase

\stopTestSuite

\startTestSuite[assertSucceed]

The \type{\assertSucceed} assertion always succeeds.

\startMkIVCode
\def\assertSucceed#1{\assertionSucceeded{#1}}
\stopMkIVCode

\startTestCase[should succeed]

\startConTest
  \assertSucceed{A message}
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertDefined]

The \type{\assertDefined} assertion confirms that the csname provided 
is defined as a \TeX\ command. 

% As another example, one can test whether a control sequence is defined by 

%\def\ifUnDefinedCs#1{\expandafter
%\ifx\csname#1\endcsname\relax}

%\ifUnDefinedCs{parindent} %is not true
%\ifUnDefinedCs{undefined} %is (one hopes) true

% This uses the fact that a \csname...\endcsname command is equivalent to 
% \relax if the control has not been defined before. Unfortunately, this 
% test also turns out true if a control has been \let to \relax. 

% See: 13.2.3 on page 141 of TeXbyTopic v1.4-2013

\startMkIVCode
\def\assertDefined#1#2{%
  \expandafter\ifx\csname#1\endcsname\relax%
    \assertionFailed{#2}{Expected #1 to be defined}%
  \else%
    \assertionSucceeded{#2}{}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if a csname is defined]

\startConTest
\assertDefined{startMkIVCode}{}
\stopConTest
\stopTestCase

\startTestCase[should file if a csname is not defined]

\startConTest
\startAssertShouldFail{}{}{}
\assertDefined{NotDefined}{}
\stopAssertShouldFail
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertNotDefined]

The \type{\assertNotDefined} assertion confirms that the csname provided 
is not defined as a \TeX\ command. 

\startMkIVCode
\def\assertNotDefined#1#2{%
  \expandafter\ifx\csname#1\endcsname\relax%
    \assertionSucceeded{#2}%
  \else%
    \assertionFailed{#2}{Expected #1 to not be defined}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if a csname is not defined]
\startConTest
\assertNotDefined{NotDefined}{}
\stopConTest
\stopTestCase

\startTestCase[should fail if a csname is defined]

\startConTest
\startAssertShouldFail{}{}{}
\assertNotDefined{stopMkIVCode}
\stopAssertShouldFail
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertStringMatches]

The \type{\assertStringMatches} assertion confirms that the fully expanded 
result, taken as a lua string, matches the associated lua pattern match. 

\startMkIVCode
\def\assertStringMatches#1#2#3{%
  \edef\aString{#1}
  \directlua{
    thirddata.contests.reportMkIVAssertion(
      string.match('\aString','#2'),
      '#3',
      'Expected [\aString] to match [#2]'
    )
  }
}
\stopMkIVCode

\startTestCase[should succeed if a string matches]

\startConTest
\assertStringMatches{a string}{string}{A message}
\stopConTest

\stopTestCase

\startTestCase[should fail if a string does not match]

\startConTest
\startAssertShouldFail{}{}{}
\assertStringMatches{a string}{noMatch}{A message}
\stopAssertShouldFail
\stopConTest

\stopTestCase

\stopTestSuite

\startTestSuite[assertStringDoesNotMatch]

The \type{\assertStringDoesNotMatch} assertion confirms that the fully expanded 
result, taken as a lua string, does not match the associated lua pattern match. 

\startMkIVCode
\def\assertStringDoesNotMatch#1#2#3{%
  \edef\aString{#1}
  \directlua{
    thirddata.contests.reportMkIVAssertion(
      not string.match('\aString','#2'),
      '#3',
      'Expected [\aString] to not match [#2]'
    )
  }
}
\stopMkIVCode

\startTestCase[should succeed if a string does not match ]

\startConTest
\assertStringDoesNotMatch{a string}{noMatch}{A message}
\stopConTest

\stopTestCase

\startTestCase[should fail if a string does match]

\startConTest
\startAssertShouldFail{}{}{}
\assertStringDoesNotMatch{a string}{string}{A message}
\stopAssertShouldFail
\stopConTest

\stopTestCase
\stopTestSuite

\startTestSuite[assertFirstArgument]

The \type{\assertFirstArgument} assertion confirms that any previous 
\ConTeXt\ multiple optional argument macro had a first argument. 

\startMkIVCode
\def\assertFirstArgument#1{%
  \iffirstargument%
    \assertionSucceeded{#1}%
  \else%
    \assertionFailed{#1}{Expected a first argument}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if there is a first argument]

\startConTest
\begingroup
  \def\oneArgument[#1]{\relax}
  \dosingleempty\oneArgument[an argument]
  \assertFirstArgument{A message}
\endgroup
\stopConTest
\stopTestCase

\startTestCase[should fail if there is no first argument]

\startConTest
\begingroup
  \def\oneArgument[#1]{\relax}
  \dosingleempty\oneArgument
  \startAssertShouldFail{}{}{}
    \assertFirstArgument{A message}
  \stopAssertShouldFail
\endgroup
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertNoFirstArgument]

The \type{\assertNoFirstArgument} assertion confirms that any previous 
\ConTeXt\ multiple optional argument macro did not have a first argument. 

\startMkIVCode
\def\assertNoFirstArgument#1{%
  \iffirstargument%
    \assertionFailed{#1}{Expected no first argument}%
  \else%
    \assertionSucceeded{#1}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if there is no first argument]

\startConTest
\begingroup
  \def\oneArgument[#1]{\relax}
  \dosingleempty\oneArgument
  \assertNoFirstArgument{A message}
\endgroup
\stopConTest
\stopTestCase

\startTestCase[should fail if there is a first argument]

\startConTest
\begingroup
  \def\oneArgument[#1]{\relax}
  \dosingleempty\oneArgument[an argument]
  \startAssertShouldFail{}{}{}
    \assertNoFirstArgument{A message}
  \stopAssertShouldFail
\endgroup
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertSecondArgument]

The \type{\assertSecondArgument} assertion confirms that any previous 
\ConTeXt\ multiple optional argument macro had a second argument. 

\startMkIVCode
\def\assertSecondArgument#1{%
  \ifsecondargument%
    \assertionSucceeded{#1}%
  \else%
    \assertionFailed{#1}{Expected a second argument}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if there is a second argument]

\startConTest
\begingroup
  \def\twoArguments[#1][#2]{\relax}
  \dodoubleempty\twoArguments[firstArgument][secondArgument]
  \assertSecondArgument{A message}
\endgroup
\stopConTest
\stopTestCase

\startTestCase[should fail if there is no second argument]

\startConTest
\begingroup
  \def\twoArguments[#1][#2]{\relax}
  \dodoubleempty\twoArguments[firstArgument]
  \startAssertShouldFail{}{}{}
    \assertSecondArgument{A message}
  \stopAssertShouldFail
\endgroup
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertNoSecondArgument]

The \type{\assertNoSecondArgument} assertion confirms that any previous 
\ConTeXt\ multiple optional argument macro did not have a second argument. 

\startMkIVCode
\def\assertNoSecondArgument#1{%
  \ifsecondargument%
    \assertionFailed{#1}{Expected no second argument}%
  \else%
    \assertionSucceeded{#1}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if there is no second argument]

\startConTest
\begingroup
  \def\twoArguments[#1][#2]{\relax}
  \dodoubleempty\twoArguments[firstArgument]
  \assertNoSecondArgument{A message}
\endgroup
\stopConTest
\stopTestCase

\startTestCase[should fail if there is a second argument]

\startConTest
\begingroup
  \def\twoArguments[#1][#2]{\relax}
  \dosingleempty\twoArguments[firstArgument][secondArgument]
  \startAssertShouldFail{}{}{}
    \assertNoSecondArgument{A message}
  \stopAssertShouldFail
\endgroup
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertThirdArgument]

The \type{\assertThirdArgument} assertion confirms that any previous 
\ConTeXt\ multiple optional argument macro had a third argument. 

\startMkIVCode
\def\assertThirdArgument#1{%
  \ifthirdargument%
    \assertionSucceeded{#1}%
  \else%
    \assertionFailed{#1}{Expected a third argument}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if there is a third argument]

\startConTest
\begingroup
  \def\threeArguments[#1][#2][#3]{\relax}
  \dotripleempty\threeArguments%
    [firstArgument][secondArgument][thirdArgument]
  \assertThirdArgument{A message}
\endgroup
\stopConTest
\stopTestCase

\startTestCase[should fail if there is no third argument]

\startConTest
\begingroup
  \def\threeArguments[#1][#2][#3]{\relax}
  \dotripleempty\threeArguments[firstArgument][secondArgument]
  \startAssertShouldFail{}{}{}
    \assertThirdArgument{A message}
  \stopAssertShouldFail
\endgroup
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertNoThirdArgument]


The \type{\assertNoThirdArgument} assertion confirms that any previous 
\ConTeXt\ multiple optional argument macro did not have a third argument. 

\startMkIVCode
\def\assertNoThirdArgument#1{%
  \ifthirdargument%
    \assertionFailed{#1}{Expected no third argument}%
  \else%
    \assertionSucceeded{#1}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if there is no third argument]

\startConTest
\begingroup
  \def\threeArguments[#1][#2][#3]{\relax}
  \dotripleempty\threeArguments[firstArgument][secondArgument]
  \assertNoThirdArgument{A message}
\endgroup
\stopConTest
\stopTestCase

\startTestCase[should fail if there is a third argument]

\startConTest
\begingroup
  \def\threeArguments[#1][#2][#3]{\relax}
  \dotripleempty\threeArguments%
    [firstArgument][secondArgument][thirdArgument]
  \startAssertShouldFail{}{}{}
    \assertNoThirdArgument{A message}
  \stopAssertShouldFail
\endgroup
\stopConTest
\stopTestCase
\stopTestSuite


\section[title=Tracing \ConTeXt]

\startTestSuite[createTraceMacro]

\startMkIVCode
\def\traceTexMacro#1#2{%
  \directlua{%
    thirddata.contests.createTraceMacro('#1', #2, 'tex')
  }
}
\def\traceContextMacro#1#2{%
  \directlua{%
    thirddata.contests.createTraceMacro('#1', #2, 'context')
  }
}

\stopMkIVCode

\startLuaTemplate
addTemplate(
  'ctmTexFormalArgs',
  { 'anArg' },
  '[#{{= anArg}}]'
)

addTemplate(
  'ctmContextFormalArgs',
  { 'anArg' },
  '#{{= anArg}}'
)

addTemplate(
  'ctmArgUse',
  { 'anArg' },
[=[
        '#{{= anArg}}'
]=]
)

addTemplate(
  'ctmFormalArgs',
  { 'anArg', 'argTemplate' },
  [=[{{! *argTemplate, anArg }}]=]
)

addTemplate(
  'ctmMain',
  { 'macroName', 'argList', 'argType', 'argTemplate' },
  [=[
\let\old{{= macroName}}=\{{= macroName}}
\def\{{= macroName}}{{| argList, '', ctmFormalArgs, anArg, argTemplate }}{%
  \directlua{%
    thirddata.contests.traceMacro(
      '{{= macroName}}',
      '{{= argType}}',
      { 
        {{| argList, ',\n', ctmArgUse }}
      }
    )
  }
}
  ]=]
)

local pp = require('pl/pretty')
texio.write_nl('t-contests-templates.lua')
texio.write_nl('-----------------------------------')
texio.write_nl(pp.write(thirddata))
texio.write_nl('-----------------------------------')
\stopLuaTemplate

\startLuaCode
function contests.createTraceMacro(theMacroName, numArgs, theArgType)
  local theArgList = { }
  for argNum = 1, numArgs, 1 do
    tInsert(theArgList, argNum)
  end
  local theArgTemplate = 'ctmTexFormalArgs'
  if theArgType == 'context' then
    theArgTemplate = 'ctmContextFormalArgs'
  end
  local theEnv  = {
    macroName   = theMacroName,
    argList     = theArgList,
    argType     = theArgType,
    argTemplate = theArgTemplate
  }
  texio.write_nl(litProgs.prettyPrint(theEnv))
  local ctmMainPath = litProgs.parseTemplatePath('ctmMain', theEnv)
  texio.write_nl(litProgs.prettyPrint(ctmMainPath))
  texio.write_nl(litProgs.prettyPrint(litProgs.templates))
  local ctmMain     = litProgs.navigateToTemplate(ctmMainPath)
  texio.write_nl(litProgs.prettyPrint(ctmMain))
  local result      = litProgs.renderer(ctmMain, theEnv)
  texio.write_nl(result)
  --result = templates.splitLines(result)
  --tex.print(result)
end
\stopLuaCode

\startTestCase[createTraceMacro should ...]
\startLuaTest
local createTraceMacro = thirddata.contests.createTraceMacro
local macroBody = createTraceMacro('test', 3, 'context')
showValue(macroBody)
macroBody = createTraceMacro('test', 3, 'tex')
showValue(macroBody)
\stopLuaTest
\showLuaTest
\skipTestCase

\stopTestSuite

\section[title=Mocking \ConTeXt]

We sometimes need to assert that a given macro has been used with given 
arguments. For example we might want to assert that a macro does or does 
not \quote{throw} an \type{\errmessage}. Equally sometimes we need a given 
macro to return a mock result for the overall \ConTeXt\ process to work. 
We solve both of these use cases by making use of \TeX's 
\type{\begingroup}, \type{\endgroup} environment to provide local 
namespaces in which we can temporarily redefine a macro to ensure the 
mocked macro interacts with the assertion system. 

We begin by defining \type{\startMocking} and \type{\stopMocking} commands.

\startMkIVCode
\def\startMocking{%
  \directlua{thirddata.contests.startMocking()}%
  \begingroup%
}
\def\stopMocking{%
  \endgroup%
  \directlua{thirddata.contests.stopMocking()}
}
\stopMkIVCode

\startMkIVCode
\def\startTracingMockExpansions{%
  \directlua{thirddata.contests.traceMockCalls(true)}
}
\def\stopTracingMockExpansions{%
  \directlua{thirddata.contests.traceMockCalls(false)}
}
\stopMkIVCode

On the lua side, both \type{startMocking} and \type{stopMocking} simply 
empty the mocks table so that any previous mocking data is cleared. 

\startLuaCode
function contests.startMocking()
  contests.mocks = { }
  mocks          = contests.mocks
end

function contests.stopMocking()
  contests.mocks   = { }
  mocks            = contests.mocks
  mocks.traceCalls = false
end
\stopLuaCode

We next define the lua code which will capture the information used to 
eventually test the mocked macros. 

\startLuaCode
function contests.traceMockCalls(traceCalls)
  mocks.traceCalls = traceCalls
  texio.write_nl('-----------------------------------------------------')
end

function contests.callMock(mockedMacro, mockedArguments, callType)
  if mocks.traceCalls then
    texio.write_nl('MOCKED '..callType..' macro expanded ['..mockedMacro..']')
    for i, anArg in ipairs(mockedArguments) do
      texio.write_nl('  args['..toStr(i)..'] = ['..toStr(anArg)..']')
    end
  end
  mockedMacro = mockedMacro:gsub('^%s+', ''):gsub('%s+$', '')
  mocks[mockedMacro] = mocks[mockedMacro] or { }
  mockedMacro = mocks[mockedMacro]
  mockedMacro.calls = mockedMacro.calls or { }
  tInsert(mockedMacro.calls, { callType, mockedArguments})
  mockedMacro.returns = mockedMacro.returns or { }
  local result = tRemove(mockedMacro.returns, 1)
  if result and type(result) == 'string' and not result:match('^%s*$') then
    tex.print(result)
  end
end

function contests.defMock(mockedMacro)
  mockedMacro = mockedMacro:gsub('^%s+', ''):gsub('%s+$', '')
  mocks[mockedMacro] = { }
end

function contests.addMockResult(mockedMacro, returnValue)
  mockedMacro = mockedMacro:gsub('^%s+', ''):gsub('%s+$', '')
  mocks[mockedMacro] = mocks[mockedMacro] or { }
  mockedMacro = mocks[mockedMacro]
  mockedMacro.returns = mockedMacro.returns or { }
  tInsert(mockedMacro.returns, returnValue)
end
\stopLuaCode

\startTestSuite[Defining TeX mock macros]

There are two classes of macros to mock, those which use \quote{normal} 
\TeX\ arguments delimited by \quote{\{} and \quote{\}}, and those which 
use \ConTeXt\ \quote{variable} arguments delimited by \quote{\[} and 
\quote{\]}. 

We begin by defining the \TeX\ argument pattern first. At the moment, to 
do this we define four separate macros corresponding to the calling 
pattern of zero, one, two, and three required arguments. In each case the 
\type{\defTexMockXXX} macro defines a macro expecting the appropriate 
number of argument using the name provided by the \type{\defTexMockXXX} 
marco's first argument. 

\startMkIVCode
\def\callTexMockZero#1{%
  \directlua{%
    thirddata.contests.callMock('#1', { }, 'tex')
  }
}
\def\defTexMockZeroArgs#1{%
  \directlua{thirddata.contests.defMock('#1')}%
  \setevalue{#1}{\noexpand\callTexMockZero{#1}}%
}

\def\callTexMockOne#1#2{%
  \directlua{%
    thirddata.contests.callMock('#1', { '#2' }, 'tex')
  }
}
\def\defTexMockOneArg#1{%
  \directlua{thirddata.contests.defMock('#1')}%
  \setevalue{#1}{\noexpand\callTexMockOne{#1}}%
}

\def\callTexMockTwo#1#2#3{%
  \directlua{%
    thirddata.contests.callMock('#1', { '#2', '#3' }, 'tex')
  }
}
\def\defTexMockTwoArgs#1{%
  \directlua{thirddata.contests.defMock('#1')}%
  \setevalue{#1}{\noexpand\callTexMockTwo{#1}}%
}

\def\callTexMockThree#1#2#3#4{%
  \directlua{%
    thirddata.contests.callMock('#1', { '#2', '#3', '#4' }, 'tex')
  }
}
\def\defTexMockThreeArgs#1{%
  \directlua{thirddata.contests.defMock('#1')}%
  \setevalue{#1}{\noexpand\callTexMockThree{#1}}%
}
\stopMkIVCode

\startTestCase[should define macros]

\startConTest
\startMocking
  \defTexMockZeroArgs{aTexMockZeroArgs}
  \assertDefined{aTexMockZeroArgs}{}
  \defTexMockOneArg{aTexMockOneArg}
  \assertDefined{aTexMockOneArg}{}
  \defTexMockTwoArgs{aTexMockTwoArgs}
  \assertDefined{aTexMockTwoArgs}{}
  \defTexMockThreeArgs{aTexMockThreeArgs}
  \assertDefined{aTexMockThreeArgs}{}
\stopMocking
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[Defining ConTeXt mock macros]

We now define the \ConTeXt\ argument (\quote{optional}) calling patterns. 

\startMkIVCode
\def\callContextMockNone#1[#2][#3][#4]{%
    \directlua{%
      thirddata.contests.callMock('#1', { }, 'context')
    }
}
\def\callContextMockSingle#1[#2][#3][#4]{%
    \directlua{%
      thirddata.contests.callMock('#1', { '#2' }, 'context')
    }
}
\def\callContextMockDouble#1[#2][#3][#4]{%
    \directlua{%
      thirddata.contests.callMock('#1', { '#2', '#3' }, 'context')
    }
}
\def\callContextMockTriple#1[#2][#3][#4]{%
    \directlua{%
      thirddata.contests.callMock('#1', { '#2', '#3', '#4' }, 'context')
    }
}
\def\defContextMock#1{%
  \directlua{thirddata.contests.defMock('#1')}
  \setuevalue{#1}{%
    \noexpand\dotripleempty\getvalue{#1Direct}%
  }
  \setuevalue{#1Direct}{%
    \noexpand\ifthirdargument%
      \noexpand\expandafter\getvalue{#1Triple}
    \noexpand\else\noexpand\ifsecondargument%
      \noexpand\expandafter\getvalue{#1Double}
    \noexpand\else\noexpand\iffirstargument%
      \noexpand\expandafter\getvalue{#1Single}
    \noexpand\else%
      \noexpand\expandafter\getvalue{#1None}
    \noexpand\fi\noexpand\fi\noexpand\fi%
  }
  \setuevalue{#1Triple}{\noexpand\callContextMockTriple #1}%
  \setuevalue{#1Double}{\noexpand\callContextMockDouble #1}%
  \setuevalue{#1Single}{\noexpand\callContextMockSingle #1}%
  \setuevalue{#1None}  {\noexpand\callContextMockNone #1}%
}
\stopMkIVCode

\startTestCase[should define macros]

\startConTest
\startMocking
  \defContextMock{aContextMock}
  \assertDefined{aContextMock}{}
  \assertDefined{aContextMockNone}{}
  \assertDefined{aContextMockSingle}{}
  \assertDefined{aContextMockDouble}{}
  \assertDefined{aContextMockTriple}{}
  \assertDefined{startTracingMockExpansions}{}
  \assertDefined{stopTracingMockExpansions}{}
\stopMocking
\stopConTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertMockExpanded assertMockNeverExpanded and assertMockExpandedNTimes]

\startMkIVCode
\def\assertMockExpanded#1#2{%
  \directlua{%
    thirddata.contests.assertMockExpanded('#1', 1, '#2')
  }
}
\def\assertMockNeverExpanded#1#2{%
  \directlua{%
    thirddata.contests.assertMockNeverExpanded('#1', '#2')
  }
}
\def\assertMockExpandedNTimes#1#2#3{%
  \directlua{%
    thirddata.contests.assertMockExpanded('#1', #2, '#3')
  }
}
\stopMkIVCode

\startLuaCode
function contests.assertMockExpanded(mockedMacro, callNum, aMessage)
  local expectedMsg = 'Expected ['..mockedMacro..']'
  mockedMacro = mocks[mockedMacro]
  contests.reportMkIVAssertion(
    mockedMacro ~= nil
    and mockedMacro.calls ~= nil
    and mockedMacro.calls[callNum] ~= nil,
    aMessage,
    expectedMsg..'to have been expanded at least '..
      toStr(callNum)..' times'
  )
end

function contests.assertMockNeverExpanded(mockedMacro, aMessage)
  local expectedMsg = 'Expected ['..mockedMacro..']'
  mockedMacro = mocks[mockedMacro]
  contests.reportMkIVAssertion(
    mockedMacro ~= nil
    and mockedMacro.calls == nil,
    aMessage,
    expectedMsg..'to have been expanded at least '..
      toStr(callNum)..' times'
  )
end
\stopLuaCode

\startTestCase[mocked macro expanded]

The \type{\assertMockExpanded} assertion should succeed if the mocked 
macro has ever been expanded. The \type{\assertMockExpandedNTimes} should 
succeed if it has been expanded the specified number of times. The 
\type{\assertMockNeverExpanded} assertion should succeed if the mocked 
macros has never been expanded. 

\startConTest
\startMocking
  \defTexMockZeroArgs{aTexMockZeroArgs}
  \aTexMockZeroArgs
  \assertMockExpanded{aTexMockZeroArgs}{}
  \startAssertShouldFail{}{}{}
    \assertMockNeverExpanded{aTexMockZeroArgs}{}
  \stopAssertShouldFail
  \assertMockExpandedNTimes{aTexMockZeroArgs}{1}{}
\stopMocking
\stopConTest

\stopTestCase

\startTestCase[mocked macro never expanded]
\startConTest
\startMocking
  \defContextMock{aContextMock}
  \startAssertShouldFail{}{}{}
    \assertMockExpanded{aContextMock}{}
  \stopAssertShouldFail
  \assertMockNeverExpanded{aContextMock}{}
  \aContextMock
  \assertMockExpandedNTimes{aContextMock}{1}{}
  \startAssertShouldFail{}{}{}
    \assertMockNeverExpanded{aContextMock}{}
  \stopAssertShouldFail
  \startAssertShouldFail{}{}{}
    \assertMockExpandedNTimes{aContextMock}{2}{}
  \stopAssertShouldFail
\stopMocking
\stopConTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertMockNthArgumentOnMthExpansionMatches]

\startMkIVCode
\def\assertMockNthArgumentOnMthExpansionMatches#1#2#3#4#5{%
  \directlua{%
    thirddata.contests.assertMockArguments(
      '#1', #3, #2, '#4', '#5'
    )
  }
}
\stopMkIVCode

\startLuaCode
function contests.assertMockArguments(mockedMacro,
                                      callNum,
                                      argNum,
                                      aPattern,
                                      aMessage)
  local expectedMsg = 'Expected ['..mockedMacro..'] '
  mockedMacro = mocks[mockedMacro]
  if mockedMacro then
    local calls = mockedMacro.calls
    if calls then
      local aCall = calls[callNum]
      if aCall then
        local anArg = aCall[2][argNum]
        if anArg then
          if sMatch(anArg, aPattern) then
            contests.reportMkIVAssertion(true, aMessage, '')
          else
            contests.reportMkIVAssertion(false, aMessage,
              expectedMsg..'the '..
              toStr(argNum)..' argument on the '..
              toStr(callNum)..' expansion to match ['..
              aPattern..']')
          end
        else
          contests.reportMkIVAssertion(false, aMessage,
            expectedMsg..'to have supplied '..
            toStr(argNum)..' arguments on the '..
            toStr(callNum)..' expansion')
        end
      else
        contests.reportMkIVAssertion(false, aMessage,
          expectedMsg..'to have been expanded '..
          toStr(callNum)..' times')
      end
    else
      contests.reportMkIVAssertion(false, aMessage,
        expectedMsg..'to have been expanded')
    end
  else
    contests.reportMkIVAssertion(false, aMessage,
      expectedMsg..'to be defined')
  end
end
\stopLuaCode

\startTestCase[should succeed if mocked macro expanded]

The \type{\assertMockNthArgumentOnMthExpansionMatches} assertion should 
succeed if $\text{n}^{\text{th}}$ argument of the $\text{m}^{\text{th}}$ 
of the mocked macro has been expanded with arguments which match the given 
pattern. 

\startConTest
\startMocking
  \defTexMockTwoArgs{aTexMockTwoArgs}
  \aTexMockTwoArgs%
    {first arg first expansion}{second arg first expansion}
  \aTexMockTwoArgs%
    {first arg second expansion}{second arg second expansion}
  \assertMockNthArgumentOnMthExpansionMatches%
    {aTexMockTwoArgs}{1}{1}{first arg first expansion}{}
  \assertMockNthArgumentOnMthExpansionMatches%
    {aTexMockTwoArgs}{1}{2}{first arg second expansion}{}
  \assertMockNthArgumentOnMthExpansionMatches%
    {aTexMockTwoArgs}{2}{1}{second arg first expansion}{}
  \assertMockNthArgumentOnMthExpansionMatches%
    {aTexMockTwoArgs}{2}{2}{second arg second expansion}{}
\stopMocking
\stopConTest

\stopTestCase

\startTestCase[should fail if mocked macro never expanded]
\startConTest
\startMocking
  \defContextMock{aContextMock}
  \aContextMock%
    [only arg first expansion]
  \aContextMock%
    [first arg second expansion]%
    [second arg second expansion]
  \assertMockNthArgumentOnMthExpansionMatches%
    {aContextMock}{1}{1}{only arg first expansion}{}
  \assertMockNthArgumentOnMthExpansionMatches%
    {aContextMock}{1}{2}{first arg second expansion}{}
  \startAssertShouldFail{}%
    {Expected [aContextMock] to have supplied}%
    {}
    \assertMockNthArgumentOnMthExpansionMatches%
      {aContextMock}{2}{1}{second arg first expansion}{}
  \stopAssertShouldFail
  \assertMockNthArgumentOnMthExpansionMatches%
    {aContextMock}{2}{2}{second arg second expansion}{}
\stopMocking
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[Adding mock results]

Finally we define the \type{\addMockResult} macro which adds a return 
value to the appropriate mocked macro. 

\startMkIVCode
\def\addMockResult#1#2{%
  \directlua{%
    thirddata.contests.addMockResult('#1', '#2')
  }
}
\stopMkIVCode

\startTestCase[should return result provided]

Note that since the \type{\defContextMock} family of macros are all 
protected, there is no easy way of capturing the results of the macro 
expansion in any way that can be transfered to the lua back-end. This is 
why we explicitly expand the \type{\aContextMock[anArg]} into 
\type{\callContextMockSingle{aConTexMock}[anArg][][]}. 

% see https://tex.stackexchange.com/a/60302
% a “… doesn't match its definition” problem, that I don't understand

\startConTest
\startMocking
  \defTexMockZeroArgs{aTexMockZeroArgs}
  \addMockResult{aTexMockZeroArgs}{aResult}
  \assertStringMatches{\aTexMockZeroArgs}{aResult}{}
  \defContextMock{aContextMock}
  \addMockResult{aContextMock}{anotherResult}
  \assertStringMatches%
    {\callContextMockSingle{aContextMock}[anArg][][]}%
    {anotherResult}{}
\stopMocking
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertErrorThrown]

One of the primary uses of the above mocking assertions is to provide 
assertions for macros which \quote{throw} \type{\errmessage}s. We do this 
explicitly mocking \type{\errmessage}. 

\startMkIVCode
\def\mockErrMessage{%
  \defTexMockOneArg{errmessage}
}
\def\assertErrorThrown#1{%
  \assertMockExpanded{errmessage}{#1}
}
\stopMkIVCode

\startTestCase[should succeed if error thrown]

We want to show that if a command throws a \TeX\ \type{\errmessage}, then 
the associated test case fails. 

\startConTest
\startMocking
  \mockErrMessage
  \errmessage{Throw this message}
  \assertErrorThrown{aMessage}
\stopMocking
\stopConTest
\stopTestCase

\startTestCase[should fail is no error thrown]

Conversely we need to show that the \type{\assertErrorThrown} assertion 
fails if not error is thrown. 

\startConTest
\startMocking
  \mockErrMessage
  \startAssertShouldFail{aMessage}{}{}
    \assertErrorThrown{aMessage}
  \stopAssertShouldFail
\stopMocking
\stopConTest

\stopTestCase

\stopTestSuite

\section{Test case results}

\reportMkIVStats

\reportFailures

\stopchapter
