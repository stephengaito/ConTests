% A ConTeXt document [master document: contests.tex]

\startchapter[title=MkIV Unit Testing]

We will eventually include MkIV unit testing.

\section[title=Test cases]

\def\startConTest{\relax}
\def\stopConTest{\relax}

\startMkIVCode

\def\startConTest{
  \directlua{thirddata.contests.startConTests()}
}

\def\stopConTest{
  \directlua{thriddata.contests.stopConTests()}
}

\stopMkIVCode

\startLuaCode

function contests.startConTestTestCase()
  -- save logging.... -- alas we can not ;-(
  -- turn logging to no-stop/batch
end

function contests.stopConTestTestCase()
  -- turn logging back to original value
end

local function conTestShowErrorHook()
  if not mkivAssertions.shouldFail then
    mkivAssertions.failed = mkivAssertions.failed + 1
    local curCase = tests.curSuite.curCase
    curCase.failed = true
    
  end
end

function contests.preAssertConTest(shouldFail)
  mkivAssertions.attempted  = mkivAssertions.attempted + 1
  mkivAssertions.shouldFail = shouldFail
end

function contests.postAssertConTest()
  mkivAssertions.shouldFail = false
end

function contests.startConTests()
  local id, err =
    callback.register('show_error_hook', conTestShowErrorHook)
end

function contests.stopConTests()
  local id, err = callback.register('show_error_hook', nil)
end

\stopLuaCode

\section[title=Assertions]

As with the implementation of both the LuaTests and CTests, the heart of 
the ConTests is the ability to throw and capture errors. In this case it 
will be \TeX\ errors, when run, a TestCase will capture all \TeX\ errors 
and provide a report of where those errors happened. 

\startTestSuite[assertThrowsError environment]

\startMkIVCode
\def\startAssertThrowsError{%
  \directlua{thirddata.contests.preAsserConTest(true)}
}

\def\stopAssertThrowsError{%
  \directlua{thirddata.contests.postAssertConTest()}
}
\stopMkIVCode

\stopTestSuite

\startTestSuite[assertDoesNotThrowError]

\stopTestSuite

\startTestSuite[assertFail]

The \type{\assertFail} assertion always fails.

\startMkIVCode
\def\assertFail#1{\errmessage{(Failure) #1}}
\stopMkIVCode

\stopTestSuite

\startTestSuite[assertSucceed]

The \type{\assertSucceed} assertion always succeeds.

\stopTestSuite

\startTestSuite[assertDefined]

The \type{\assertDefined} assertion confirms that the csname provided 
is defined as a \TeX\ command. 

% As another example, one can test whether a control sequence is defined by 

%\def\ifUnDefinedCs#1{\expandafter
%\ifx\csname#1\endcsname\relax}

%\ifUnDefinedCs{parindent} %is not true
%\ifUnDefinedCs{undefined} %is (one hopes) true

% This uses the fact that a \csname...\endcsname command is equivalent to 
% \relax if the control has not been defined before. Unfortunately, this 
% test also turns out true if a control has been \let to \relax. 

% See: 13.2.3 on page 141 of TeXbyTopic v1.4-2013

\stopTestSuite

\startTestSuite[assertNotDefined]

The \type{\assertNotDefined} assertion confirms that the csname provided 
is not defined as a \TeX\ command. 

\stopTestSuite

\startTestSuite[assertStringMatches]

The \type{\assertStringMatches} assertion confirms that the fully expanded 
result, taken as a lua string, matches the associated lua pattern match. 

\stopTestSuite

\startTestSuite[assertStringDoesNotMatch]

The \type{\assertStringDoesNotMatch} assertion confirms that the fully expanded 
result, taken as a lua string, does not match the associated lua pattern match. 

\stopTestSuite

\startTestSuite[assertLua]

The \type{assertLua} environment allows the use of any of the lua 
assertions (defined below) inside a ConTest test case. 

\stopTestSuite

\stopchapter