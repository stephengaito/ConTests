% A ConTeXt document [master document: contests.tex]

\startchapter[title=MkIV Unit Testing]

We provide an evolving collection of unit test assertions in \ConTeXt. 

\nonstopmode

\section[title=Test cases]

%\definetyping[ConTest]
%\setuptyping[ConTest][option=context]

\startMkIVCode

%%%%%%%%%%%%%%%%
% ConTest code %
%%%%%%%%%%%%%%%%

\definetyping[ConTest]
\setuptyping[ConTest][option=context]

\let\oldStopConTest=\stopConTest
\def\stopConTest{%
  \oldStopConTest%
  \directlua{thirddata.contests.addConTest('_typing_')}
}

\def\reportMkIVStats{%
  \directlua{thirddata.contests.reportStats('mkiv')}
}

\stopMkIVCode

\startLuaCode
------------------
-- ConTest code --
------------------

function contests.addConTest(bufferName)
  local bufferContents = buffers.getcontent(bufferName):gsub("\13", "\n")
  local suite = tests.curSuite
  local case  = suite.curCase
  case.mkiv   = case.mkiv or {}
  table_insert(case.mkiv, bufferContents)
end

function contests.runCurMkIVTestCase(suite, case)
  case.passed = case.passed or true
  case.mkiv   = case.mkiv   or { }
  local mkivChunk = table_concat(case.mkiv, '\n')
  if not mkivChunk:match('^%s*$') then
    local caseStats = tests.stats.mkiv.cases
    caseStats.attempted = caseStats.attempted + 1
    tex.print("\\directlua{thirddata.contests.startConTestImplementation()}")
    for i, aChunk in ipairs(case.mkiv) do
      for aLine in string.gmatch(aChunk, '[^\n]*') do
        if 0 < #aLine then
          tex.print(aLine)
        end
      end
    end
    tex.print("\\directlua{thirddata.contests.stopConTestImplementation()}")
  end
end

function contests.startConTestImplementation()
  -- nothing to do at the moment
end

function contests.stopConTestImplementation()
  local curCase  = tests.curSuite.curCase
  local caseStats = mkivStats.cases
  if curCase.passed then
    caseStats.passed = caseStats.passed + 1
  else
    caseStats.failed = caseStats.failed + 1
  end
end

\stopLuaCode

\section[title=Assertions]

We start by defining two helper functions to declare (to the lua code) 
that an assertion together with its message and reason (for failure) has 
either failed or succeeded. 

\startMkIVCode
\def\assertionFailed#1#2{%
  \directlua{thirddata.contests.reportMkIVAssertion(false, '#1', '#2')}
}

\def\assertionSucceeded#1{%
  \directlua{thirddata.contests.reportMkIVAssertion(true, '#1', '')}
}
\stopMkIVCode

\startLuaCode
function contests.reportMkIVAssertion(theCondition, aMessage, theReason)
  local curSuite  = tests.curSuite
  local curCase   = curSuite.curCase
  mkivAssertions.attempted = mkivAssertions.attempted + 1

  if type(curCase.shouldFail) == 'table'  then
    local shouldFail = curCase.shouldFail
    local innerMessage = aMessage
    local innerReason  = theReason
    theReason = nil
    theCondition = not theCondition
    if theReason ~= nil
      and shouldFail.messagePattern ~= nil
      and type(shouldFail.messagePattern) == 'string'
      and 0 < #shouldFail.messagePattern
      and aMessage:match(shouldFail.messagePattern) then
      -- do nothing
    else
      theReason = fmt('Expected inner message [%s] to match [%s]',
        innerMessage, shouldFail.messagePattern)
    end
    if theReason ~= nil
      and shouldFail.reasonPattern ~= nil
      and type(shouldFail.reasonPattern) == 'string'
      and 0 < #shouldFail.reasonPattern
      and theReason:match(shouldFail.reasonPattern) then
      -- do nothing
    else
      theReason = fmt('Expected inner failure reason [%s] to match [%s]',
        innerReason, shouldFail.reasonPattern)
    end
    if theReason ~= nil then
      theReason = 'Expected inner assertion ['..aMessage..'] to fail'
    end
    aMessage  = shouldFail.message
    curCase.shouldFail = nil
  end

  if theCondition then
    mkivAssertions.passed = mkivAssertions.passed + 1
    tex.print("\\noindent{\\green PASSED}")
  else
    curSuite.passed = false
    curCase.passed  = false
    mkivAssertions.failed = mkivAssertions.failed + 1
    local failure = logFailure(
      "ConTest FAILED",
      curSuite.desc,
      curCase.desc,
      aMessage,
      theReason,
      fmt("in file: %s between lines %s and %s",
        curCase.fileName,
        toStr(curCase.startLine),
        toStr(curCase.lastLine)
      )
    )
    reportFailure(failure, false)
    table_insert(tests.failures, failure)
  end
end
\stopLuaCode

\startTestSuite[assertShouldFail environment]

The \type{assertShouldFail} environment provides a way to confirm that 
some \quote{inner} ConTest assertions have failed. The 
\type{\startAssertShouldFaile} command takes three arguments, a lua 
pattern to match against the inner message, a lua pattern to match against 
the inner reason, and an \quote{outer} message to be used by the 
\type{assertShouldFail} commands themselves. Upon successfully detecting 
the inner failure, the inner failure reports are removed. 

\startMkIVCode
\def\startAssertShouldFail#1#2#3{%
  \directlua{thirddata.contests.mkivAssertShouldFail('#1', '#2', '#3')}
}

\def\stopAssertShouldFail{\relax}

\stopMkIVCode

\startLuaCode
function contests.mkivAssertShouldFail(messagePattern, reasonPattern, aMessage)
  local curCase = tests.curSuite.curCase
  curCase.shouldFail = { }
  local shouldFail = curCase.shouldFail
  shouldFail.messagePattern = messagePattern
  shouldFail.reasonPattern  = reasonPattern
  shouldFail.message        = aMessage
end
\stopLuaCode

\startTestCase[should succeed if an inner assertion fails]

\startConTest
\startAssertShouldFail{Inner message}{(Failed)}{Outer message}
  \assertFail{Inner message}
\stopAssertShouldFail
\stopConTest

\stopTestCase

\startTestCase[should fail if an inner assertion does not fail]

\startConTest
\startAssertShouldFail%
  {Inner message}{Expected something}{Outer message}
  \startAssertShouldFail{}{}{Inner message}
    no flies on us.
  \stopAssertShouldFail
\stopAssertShouldFail
\stopConTest

\stopTestCase

\startTestCase[should fail if inner assertion fails with wrong message or reason]

\startConTest
\startAssertShouldFail{First outer message}{}{First outermost message}
\startAssertShouldFail{wrong}{}{First outer message}
  \assertFail{First inner message}
\stopAssertShouldFail
\stopAssertShouldFail

\startAssertShouldFail{Second outer message}{}{Second outermost message}
\startAssertShouldFail{}{wrong}{Second outer message}
  \assertFail{Second inner message}
\stopAssertShouldFail
\stopAssertShouldFail
\stopConTest

\stopTestCase

\stopTestSuite

\startTestSuite[assertFail]

The \type{\assertFail} assertion always fails.

\startMkIVCode
\def\assertFail#1{\assertionFailed{#1}{(Failed)}}
\stopMkIVCode

\startTestCase[should fail]

\startConTest
\startAssertShouldFail{Inner message}{}{Outer message}
  \assertFail{Inner message}
\stopAssertShouldFail
\stopConTest

\stopTestCase

\stopTestSuite

\startTestSuite[assertSucceed]

The \type{\assertSucceed} assertion always succeeds.

\startMkIVCode
\def\assertSucceed#1{\assertionSucceeded{#1}}
\stopMkIVCode

\startTestCase[should succeed]

\startConTest
  \assertSucceed{A message}
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertDefined]

The \type{\assertDefined} assertion confirms that the csname provided 
is defined as a \TeX\ command. 

% As another example, one can test whether a control sequence is defined by 

%\def\ifUnDefinedCs#1{\expandafter
%\ifx\csname#1\endcsname\relax}

%\ifUnDefinedCs{parindent} %is not true
%\ifUnDefinedCs{undefined} %is (one hopes) true

% This uses the fact that a \csname...\endcsname command is equivalent to 
% \relax if the control has not been defined before. Unfortunately, this 
% test also turns out true if a control has been \let to \relax. 

% See: 13.2.3 on page 141 of TeXbyTopic v1.4-2013

\startMkIVCode
\def\assertDefined#1#2{%
  \expandafter\ifx\csname#1\endcsname\relax%
    \assertionFailed{#2}{Expected #1 to be defined}%
  \else%
    \assertionSucceeded{#2}{}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if a csname is defined]

\startConTest
\assertDefined{startMkIVCode}{}
\stopConTest
\stopTestCase

\startTestCase[should file if a csname is not defined]

\startConTest
\startAssertShouldFail{}{}{}
\assertDefined{NotDefined}{}
\stopAssertShouldFail
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertNotDefined]

The \type{\assertNotDefined} assertion confirms that the csname provided 
is not defined as a \TeX\ command. 

\startMkIVCode
\def\assertNotDefined#1#2{%
  \expandafter\ifx\csname#1\endcsname\relax%
    \assertionSucceeded{#2}%
  \else%
    \assertionFailed{#2}{Expected #1 to not be defined}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if a csname is not defined]
\startConTest
\assertNotDefined{NotDefined}{}
\stopConTest
\stopTestCase

\startTestCase[should fail if a csname is defined]

\startConTest
\startAssertShouldFail{}{}{}
\assertNotDefined{stopMkIVCode}
\stopAssertShouldFail
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertStringMatches]

The \type{\assertStringMatches} assertion confirms that the fully expanded 
result, taken as a lua string, matches the associated lua pattern match. 

\startMkIVCode
\def\assertStringMatches#1#2#3{%
  \directlua{
    thirddata.contests.reportMkIVAssertion(
      string.match('#1','#2'),
      '#3',
      'Expected [#1] to match [#2]'
    )
  }
}
\stopMkIVCode

\startTestCase[should succeed if a string matches]

\startConTest
\assertStringMatches{a string}{string}{A message}
\stopConTest

\stopTestCase

\startTestCase[should fail if a string does not match]

\startConTest
\startAssertShouldFail{}{}{}
\assertStringMatches{a string}{noMatch}{A message}
\stopAssertShouldFail
\stopConTest

\stopTestCase

\stopTestSuite

\startTestSuite[assertStringDoesNotMatch]

The \type{\assertStringDoesNotMatch} assertion confirms that the fully expanded 
result, taken as a lua string, does not match the associated lua pattern match. 

\startMkIVCode
\def\assertStringDoesNotMatch#1#2#3{%
  \directlua{
    thirddata.contests.reportMkIVAssertion(
      not string.match('#1','#2'),
      '#3',
      'Expected [#1] to not match [#2]'
    )
  }
}
\stopMkIVCode

\startTestCase[should succeed if a string does not match ]

\startConTest
\assertStringDoesNotMatch{a string}{noMatch}{A message}
\stopConTest

\stopTestCase

\startTestCase[should fail if a string does match]

\startConTest
\startAssertShouldFail{}{}{}
\assertStringDoesNotMatch{a string}{string}{A message}
\stopAssertShouldFail
\stopConTest

\stopTestCase
\stopTestSuite

\section[title=Mocking \ConTeXt]

We sometimes need to assert that a given macro has been used with given 
arguments. For example we might want to assert that a macro does or does 
not \quote{throw} an \type{\errmessage}. Equally sometimes we need a given 
macro to return a mock result for the overall \ConTeXt\ process to work. 
We solve both of these use cases by making use of \TeX's 
\type{\begingroup}, \type{\endgroup} environment to provide local 
namespaces in which we can temporarily redefine a macro to ensure the 
mocked macro interacts with the assertion system. 

We begin by defining \type{\startMocking} and \type{\stopMocking} commands.

\startMkIVCode
\def\startMocking{%
  \directlua{thirddata.contests.startMocking()}%
  \begingroup%
}
\def\stopMocking{%
  \endgroup%
  \directlua{thirddata.contests.stopMocking()}
}
\stopMkIVCode

There are two classes of macros to mock, those which use \quote{normal} 
\TeX\ arguments delimited by \quote{\{} and \quote{\}}, and those which 
use \ConTeXt\ \quote{variable} arguments delimited by \quote{\[} and 
\quote{\]}. 

We begin by defining the \TeX\ argument pattern first. At the moment, to 
do this we define four separate macros corresponding to the calling 
pattern of zero, one, two, and three required arguments. These macros come 
in pairs, a \quote{define} and a \quote{call} variant. The first argument 
of all variants is the name of the macro to mock. The second argument for 
all of the \quote{define} macros, is the result that should be returned on 
the next use of the macro. Any subsequent arguments for the \quote{call} 
variants are the collection of required arguments. 

\startMkIVCode
\def\defTexMockZero#1#2{%
  \directlua{thirddata.contests.defMock('#1', '#2')}%
  \setvalue{#1}{%
    \directlua{%
      thirddata.contests.callMock('#1', { }, 'tex')
    }
  }
}

\def\defTexMockOne#1#2{%
  \directlua{thirddata.contests.defMock('#1', '#2')}%
  \setvalue{#1}#2{%
    \directlua{%
      thirddata.contests.callMock('#1', { '#2' }, 'tex')
    }
  }
}

\def\defTexMockTwo#1#2{%
  \directlua{thirddata.contests.defMock('#1', '#2')}%
  \setvalue{#1}#2#3{%
    \directlua{%
      thirddata.contests.callMock('#1', { '#2', '#3' }, 'tex')
    }
  }
}

\def\defTexMockThree#1#2{%
  \directlua{thriddata.contests.defMock('#1', '#2')}
  \setvalue{#1}#2#3#4{%
    \directlua{%
      thirddata.contests.callMock('#1', { '#2', '#3', '#4' }, 'tex')
    }
  }
}
\stopMkIVCode

We now define the \ConTeXt\ argument (\quote{optional}) calling patterns. 

\startMkIVCode
\def\defContextMock#1#2{%
  \directlua{thirddata.contests.defMock('#1', '#2')}
  \setuvalue{#1}{%
    \dotripleempty\getvalue{#1Direct}%
  }
  \setuvalue{#1Direct}{%
    \ifthirdargument%
      \expandafter\getvalue{#1Triple}
    \else\ifsecondargument%
      \expandafter\getvalue{#1Double}
    \else\iffirstargument%
      \expandafter\getvalue{#1Single}
    \else%
      \expandafter\getvalue{#1None}
    \fi\fi\fi%
  }
  \setuvalue{#1Triple}[#3][#4][#5]{
    \directlua{%
      thirddata.contests.callMock('#1', { '#3', '#4', '#5' }, 'context')
    }
  }
  \setuvalue{#1Double}[#3][#4]{
    \directlua{%
      thirddata.contests.callMock('#1', { '#3', '#3' }, 'context')
    }
  }
  \setuvalue{#1Single}[#3]{
    \directlua{%
      thirddata.contests.callMock('#1', { '#3' }, 'context')
    }
  }
  \setuvalue{#1None}{
    \directlua{%
      thirddata.contests.callMock('#1', { }, 'context')
    }
  }
}
\stopMkIVCode

We now need to define the corresponding lua code.

\startLuaCode
function contests.callMock(mockedMacro, mockedArguments, callType)
  mocks[mockedMacro] = mocks[mockedMacro] or { }
  mockedMacro = mocks[mockedMacro]
  mockedMacro.calls = mockedMacro.calls or { }
  table_insert(mockedMacros.calls, { callType, mockedArguments})
  return table_remove(mockedMacros.returns, 1)
end

function contests.defMock(mockedMacro, returnValue)
  mocks[mockedMacro] = mocks[mockedMacro] or { }
  mockedMacro = mocks[mockedMacro]
  mockedMacro.returns = mockedMacro.returns or { }
  table_insert(mockedMacro.returns, returnValue)
end
\stopLuaCode

\startTestSuite[assertThrowsError environment]

It might be useful to determine if some \ConTeXt\ code has thrown a \TeX\ 
error. To do this the \type{assertThrowsError} environment needs to 
capture all \TeX\ errors and provide a report of where those errors 
happened. 

While \LuaTeX\ does provide the ability to interact with the underlying 
\TeX\ error reporting system, this interaction proves to have subtle 
reprecussions for understanding general \TeX\ errors. So at the moment we 
only sketch this code. 

%\startMkIVCode
\starttyping[option=context]
\def\startAssertThrowsError#1{%
  \def\startAssertionMessage{#1}
  \directlua{thirddata.contests.startAssertThrowsError()}
}

\def\stopAssertThrowsError{%
  \directlua{thirddata.contests.stopAssertThrowsError()}
}
\stoptyping
%\stopMkIVCode

%\startLuaCode
\starttyping[option=lua]
local function conTestShowErrorHook()
  --tests.curSuite.curCase.caughtError = true
  --texio.write_nl('==========================')
  --texio.write_nl("Caught error")
  --texio.write_nl(status.lasterrorstring)
  --texio.write_nl(status.lasterrorcontext)
  --texio.write_nl('==========================')
end

function contests.startAssertThrowsError()
  tests.curSuite.curCase.caughtError = false
  -- save logging.... -- alas we can not ;-(
  -- turn logging to no-stop/batch
  --callback.register('show_error_hook', conTestShowErrorHook)
end

function contests.stopAssertThrowsError()
  --callback.register('show_error_hook', nil)
  -- turn logging back to original value
  contests.reportMkIVAssertion(
    thirddata.contests.tests.curSuite.curCase.caughtError,
    '\startAssertionMessage',
    'Expected an error to be thrown'
  )
end

\stoptyping
%\stopLuaCode

\startTestCase[should succeed if error thrown]

We want to show that if a command throws a \TeX\ \type{\errmessage}, then 
the associated test case fails. 

%\startConTest
\starttyping[option=context]
\startAssertThrowsError{A Message}
  \errmessage{Throw this message}
\stopAssertThrowsError
\stoptyping
%\stopConTest
\stopTestCase

\startTestCase[should fail if no error thrown]

%\startConTest
\starttyping[option=context]
\startAssertShouldFail%
  {Inner message}{Expected an error to be thrown}{Outer message}
\startAssertThrowsError{Inner message}
No error is thrown
\stopAssertThrowsError
\stopAssertShouldFail
\stoptyping
%\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertDoesNotThrowError]

%\startMkIVCode
\starttyping[option=context]
\def\startAssertDoesNotThrowError#1{%
  \def\startAssertionMessage{#1}
  \directlua{thirddata.contests.startAssertDoesNotThrowError()}
}

\def\stopAssertDoesNotThrowError{%
  \directlua{thirddata.contests.stopAssertDoesNotThrowError()}
}
\stoptyping
%\stopMkIVCode

%\startLuaCode
\starttyping[option=lua]
function contests.startAssertDoesNotThrowError()
  tests.curSuite.curCase.caughtError = false
  -- save logging.... -- alas we can not ;-(
  -- turn logging to no-stop/batch
  --callback.register('show_error_hook', conTestShowErrorHook)
end

function contests.stopAssertDoesNotThrowError()
  --callback.register('show_error_hook', nil)
  -- turn logging back to original value
  contests.reportMkIVAssertion(
    not thirddata.contests.tests.curSuite.curCase.caughtError,
    '\startAssertionMessage',
    'Expected no error to be thrown'
  )
end

\stoptyping
%\stopLuaCode
\startTestCase[should succeed if no error thrown]

%\startConTest
\starttyping[option=context]
\startAssertDoesNotThrowError{A message}
No error is thrown.
\stopAssertDoesNotThrowError
\stoptyping
%\stopConTest

\stopTestCase

\startTestCase[should fail if an error is thrown]

%\startConTest
\starttyping[option=context]
\startAssertShouldFail%
  {Inner message}{Expected no error to be thrown}{Outer message}
\startAssertDoesNotThrowError{Inner message}
  \errmessage{Throw this error message}
\stopAssertDoesNotThrowError
\stopAssertShouldFail
\stoptyping
%\stopConTest

\stopTestCase

\stopTestSuite

\section{Test case results}

\reportMkIVStats

\reportFailures

\stopchapter