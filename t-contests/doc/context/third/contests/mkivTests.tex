% A ConTeXt document [master document: contests.tex]

\startchapter[title=MkIV Unit Testing]

We provide an evolving collection of unit test assertions in \ConTeXt. 

\section[title=Test cases]

We base our ConTest unit tests on the \ConTeXt\ typing environment, so we 
begin by defining a new typing environment using \type{\definetyping}. 
Typing environments, use Lua code to capture the contents of the 
environment and place them into a Lua string variable called a 
\quote{buffer}. At the end of our ConTest environment, we use the Lua 
method \type{addConTest} to capture the contents of the \type{_tying_} 
buffer for execution at the end of the test case which contains the 
current ConTest environment. To do this we need to wrap the 
\type{\stopConTest} macro which was created by the \type{\definetyping} 
macro. Our wrapped \type{\stopConTest} macro expands the old version of 
the \type{\stopConTest} \TeX\ macro and then calls the Lua 
\type{addConTest} method with the \type{bufferName} set to 
\type{_typing_}. 

\startMkIVCode
\definetyping[ConTest]
\setuptyping[ConTest][option=context]

\let\oldStopConTest=\stopConTest
\def\stopConTest{%
  \oldStopConTest%
  \directlua{thirddata.contests.addConTest('_typing_')}
}
\stopMkIVCode

The \type{addConTest} Lua method starts by ensuring that the contents of 
the \type{bufferName} buffer has \TeX\ friendly end of line characters. 
The method then appends the buffer string to the end of the 
\type{case.mkiv} array for the current test case in the current test 
suite. 

\startLuaCode
function contests.addConTest(bufferName)
  local bufferContents = buffers.getcontent(bufferName):gsub("\13", "\n")
  local suite = tests.curSuite
  local case  = suite.curCase
  case.mkiv   = case.mkiv or {}
  tInsert(case.mkiv, bufferContents)
end
\stopLuaCode

TODO discuss \type{runCurMkIVTestCase}.

\startLuaCode
function contests.runCurMkIVTestCase(suite, case)
  case.passed = case.passed or true
  case.mkiv   = case.mkiv   or { }
  local mkivChunk = tConcat(case.mkiv, '\n')
  if not mkivChunk:match('^%s*$') then
    local caseStats = tests.stats.mkiv.cases
    caseStats.attempted = caseStats.attempted + 1
    tex.print("\\directlua{thirddata.contests.startConTestImplementation()}")
    for i, aChunk in ipairs(case.mkiv) do
      for aLine in string.gmatch(aChunk, '[^\n]*') do
        if 0 < #aLine then
          tex.print(aLine)
        end
      end
    end
    tex.print("\\directlua{thirddata.contests.stopConTestImplementation()}")
  end
end

function contests.startConTestImplementation()
  -- nothing to do at the moment
end

function contests.stopConTestImplementation()
  local curCase  = tests.curSuite.curCase
  local caseStats = mkivStats.cases
  if curCase.passed then
    caseStats.passed = caseStats.passed + 1
  else
    caseStats.failed = caseStats.failed + 1
  end
end

\stopLuaCode

\section[title=Assertions]

We start by defining two helper functions to declare (to the lua code) 
that an assertion together with its message and reason (for failure) has 
either failed or succeeded. 

\startMkIVCode
\def\assertionFailed#1#2{%
  \directlua{thirddata.contests.reportMkIVAssertion(false, '#1', '#2')}
}

\def\assertionSucceeded#1{%
  \directlua{thirddata.contests.reportMkIVAssertion(true, '#1', '')}
}
\stopMkIVCode

\startLuaCode
function reportMkIVAssertion(theCondition, aMessage, theReason)
  local curSuite  = tests.curSuite
  local curCase   = curSuite.curCase
  mkivAssertions.attempted = mkivAssertions.attempted + 1

  if type(curCase.shouldFail) == 'table'  then
    local shouldFail = curCase.shouldFail
    local innerMessage = aMessage
    local innerReason  = theReason
    theReason = nil
    theCondition = not theCondition
    if theReason ~= nil
      and shouldFail.messagePattern ~= nil
      and type(shouldFail.messagePattern) == 'string'
      and 0 < #shouldFail.messagePattern
      and aMessage:match(shouldFail.messagePattern) then
      -- do nothing
    else
      theReason = sFmt('Expected inner message [%s] to match [%s]',
        innerMessage, shouldFail.messagePattern)
    end
    if theReason ~= nil
      and shouldFail.reasonPattern ~= nil
      and type(shouldFail.reasonPattern) == 'string'
      and 0 < #shouldFail.reasonPattern
      and theReason:match(shouldFail.reasonPattern) then
      -- do nothing
    else
      theReason = sFmt('Expected inner failure reason [%s] to match [%s]',
        innerReason, shouldFail.reasonPattern)
    end
    if theReason ~= nil then
      theReason = 'Expected inner assertion ['..aMessage..'] to fail'
    end
    aMessage  = shouldFail.message
    curCase.shouldFail = nil
  end

  if theCondition then
    mkivAssertions.passed = mkivAssertions.passed + 1
    tex.print("\\noindent{\\green PASSED}")
  else
    curSuite.passed = false
    curCase.passed  = false
    mkivAssertions.failed = mkivAssertions.failed + 1
    local failure = logFailure(
      "ConTest FAILED",
      curSuite.desc,
      curCase.desc,
      aMessage,
      theReason,
      sFmt("in file: %s between lines %s and %s",
        curCase.fileName,
        toStr(curCase.startLine),
        toStr(curCase.lastLine)
      )
    )
    reportFailure(failure, false)
    tInsert(tests.failures, failure)
  end
end

contests.reportMkIVAssertion = reportMkIVAssertion
\stopLuaCode

\startTestSuite[assertShouldFail environment]

The \type{assertShouldFail} environment provides a way to confirm that 
some ConTest assertions located inside the \type{assertShouldFail} 
environment, have failed. The \type{\startAssertShouldFail} command takes 
three arguments, a lua pattern to match against the inner message, a lua 
pattern to match against the inner reason, and an \quote{outer} message to 
be used by the \type{assertShouldFail} commands themselves. Upon 
successfully detecting the inner failure, the inner failure reports are 
removed. 

The primary purpose of the \type{assertShouldFail} environment, is to 
provide a way to test that various assertions fail, without those failures 
representing failures of the overall test suite. 

\startMkIVCode
\def\startAssertShouldFail#1#2#3{%
  \directlua{thirddata.contests.mkivAssertShouldFail('#1', '#2', '#3')}
}

\def\stopAssertShouldFail{\relax}

\stopMkIVCode

\startLuaCode
function contests.mkivAssertShouldFail(messagePattern, reasonPattern, aMessage)
  local curCase = tests.curSuite.curCase
  curCase.shouldFail = { }
  local shouldFail = curCase.shouldFail
  shouldFail.messagePattern = messagePattern
  shouldFail.reasonPattern  = reasonPattern
  shouldFail.message        = aMessage
end
\stopLuaCode

\startTestCase[should succeed if an inner assertion fails]

\startConTest
\startAssertShouldFail{Inner message}{(Failed)}{Outer message}
  \assertFail{Inner message}
\stopAssertShouldFail
\stopConTest

\stopTestCase

\startTestCase[should fail if an inner assertion does not fail]

\startConTest
\startAssertShouldFail%
  {Inner message}{Expected something}{Outer message}
  \startAssertShouldFail{}{}{Inner message}
    no flies on us.
  \stopAssertShouldFail
\stopAssertShouldFail
\stopConTest

\stopTestCase

\startTestCase[should fail if inner assertion fails with wrong message or reason]

\startConTest
\startAssertShouldFail{First outer message}{}{First outermost message}
\startAssertShouldFail{wrong}{}{First outer message}
  \assertFail{First inner message}
\stopAssertShouldFail
\stopAssertShouldFail

\startAssertShouldFail{Second outer message}{}{Second outermost message}
\startAssertShouldFail{}{wrong}{Second outer message}
  \assertFail{Second inner message}
\stopAssertShouldFail
\stopAssertShouldFail
\stopConTest

\stopTestCase

\stopTestSuite

\startTestSuite[assertFail]

The \type{\assertFail} assertion always fails.

\startMkIVCode
\def\assertFail#1{\assertionFailed{#1}{(Failed)}}
\stopMkIVCode

\startTestCase[should fail]

\startConTest
\startAssertShouldFail{Inner message}{}{Outer message}
  \assertFail{Inner message}
\stopAssertShouldFail
\stopConTest

\stopTestCase

\stopTestSuite

\startTestSuite[assertSucceed]

The \type{\assertSucceed} assertion always succeeds.

\startMkIVCode
\def\assertSucceed#1{\assertionSucceeded{#1}}
\stopMkIVCode

\startTestCase[should succeed]

\startConTest
  \assertSucceed{A message}
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertDefined]

The \type{\assertDefined} assertion confirms that the csname provided 
is defined as a \TeX\ command. 

% As another example, one can test whether a control sequence is defined by 

%\def\ifUnDefinedCs#1{\expandafter
%\ifx\csname#1\endcsname\relax}

%\ifUnDefinedCs{parindent} %is not true
%\ifUnDefinedCs{undefined} %is (one hopes) true

% This uses the fact that a \csname...\endcsname command is equivalent to 
% \relax if the control has not been defined before. Unfortunately, this 
% test also turns out true if a control has been \let to \relax. 

% See: 13.2.3 on page 141 of TeXbyTopic v1.4-2013

\startMkIVCode
\def\assertDefined#1#2{%
  \expandafter\ifx\csname#1\endcsname\relax%
    \assertionFailed{#2}{Expected #1 to be defined}%
  \else%
    \assertionSucceeded{#2}{}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if a csname is defined]

\startConTest
\assertDefined{startMkIVCode}{}
\stopConTest
\stopTestCase

\startTestCase[should file if a csname is not defined]

\startConTest
\startAssertShouldFail{}{}{}
\assertDefined{NotDefined}{}
\stopAssertShouldFail
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertNotDefined]

The \type{\assertNotDefined} assertion confirms that the csname provided 
is not defined as a \TeX\ command. 

\startMkIVCode
\def\assertNotDefined#1#2{%
  \expandafter\ifx\csname#1\endcsname\relax%
    \assertionSucceeded{#2}%
  \else%
    \assertionFailed{#2}{Expected #1 to not be defined}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if a csname is not defined]
\startConTest
\assertNotDefined{NotDefined}{}
\stopConTest
\stopTestCase

\startTestCase[should fail if a csname is defined]

\startConTest
\startAssertShouldFail{}{}{}
\assertNotDefined{stopMkIVCode}
\stopAssertShouldFail
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertStringMatches]

The \type{\assertStringMatches} assertion confirms that the fully expanded 
result, taken as a lua string, matches the associated lua pattern match. 

\startMkIVCode
\def\assertStringMatches#1#2#3{%
  \edef\aString{#1}
  \directlua{
    thirddata.contests.reportMkIVAssertion(
      string.match('\aString','#2'),
      '#3',
      'Expected [\aString] to match [#2]'
    )
  }
}
\stopMkIVCode

\startTestCase[should succeed if a string matches]

\startConTest
\assertStringMatches{a string}{string}{A message}
\stopConTest

\stopTestCase

\startTestCase[should fail if a string does not match]

\startConTest
\startAssertShouldFail{}{}{}
\assertStringMatches{a string}{noMatch}{A message}
\stopAssertShouldFail
\stopConTest

\stopTestCase

\stopTestSuite

\startTestSuite[assertStringDoesNotMatch]

The \type{\assertStringDoesNotMatch} assertion confirms that the fully expanded 
result, taken as a lua string, does not match the associated lua pattern match. 

\startMkIVCode
\def\assertStringDoesNotMatch#1#2#3{%
  \edef\aString{#1}
  \directlua{
    thirddata.contests.reportMkIVAssertion(
      not string.match('\aString','#2'),
      '#3',
      'Expected [\aString] to not match [#2]'
    )
  }
}
\stopMkIVCode

\startTestCase[should succeed if a string does not match ]

\startConTest
\assertStringDoesNotMatch{a string}{noMatch}{A message}
\stopConTest

\stopTestCase

\startTestCase[should fail if a string does match]

\startConTest
\startAssertShouldFail{}{}{}
\assertStringDoesNotMatch{a string}{string}{A message}
\stopAssertShouldFail
\stopConTest

\stopTestCase
\stopTestSuite

\startTestSuite[assertFirstArgument]

The \type{\assertFirstArgument} assertion confirms that any previous 
\ConTeXt\ multiple optional argument macro had a first argument. 

\startMkIVCode
\def\assertFirstArgument#1{%
  \iffirstargument%
    \assertionSucceeded{#1}%
  \else%
    \assertionFailed{#1}{Expected a first argument}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if there is a first argument]

\startConTest
\begingroup
  \def\oneArgument[#1]{\relax}
  \dosingleempty\oneArgument[an argument]
  \assertFirstArgument{A message}
\endgroup
\stopConTest
\stopTestCase

\startTestCase[should fail if there is no first argument]

\startConTest
\begingroup
  \def\oneArgument[#1]{\relax}
  \dosingleempty\oneArgument
  \startAssertShouldFail{}{}{}
    \assertFirstArgument{A message}
  \stopAssertShouldFail
\endgroup
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertNoFirstArgument]

The \type{\assertNoFirstArgument} assertion confirms that any previous 
\ConTeXt\ multiple optional argument macro did not have a first argument. 

\startMkIVCode
\def\assertNoFirstArgument#1{%
  \iffirstargument%
    \assertionFailed{#1}{Expected no first argument}%
  \else%
    \assertionSucceeded{#1}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if there is no first argument]

\startConTest
\begingroup
  \def\oneArgument[#1]{\relax}
  \dosingleempty\oneArgument
  \assertNoFirstArgument{A message}
\endgroup
\stopConTest
\stopTestCase

\startTestCase[should fail if there is a first argument]

\startConTest
\begingroup
  \def\oneArgument[#1]{\relax}
  \dosingleempty\oneArgument[an argument]
  \startAssertShouldFail{}{}{}
    \assertNoFirstArgument{A message}
  \stopAssertShouldFail
\endgroup
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertSecondArgument]

The \type{\assertSecondArgument} assertion confirms that any previous 
\ConTeXt\ multiple optional argument macro had a second argument. 

\startMkIVCode
\def\assertSecondArgument#1{%
  \ifsecondargument%
    \assertionSucceeded{#1}%
  \else%
    \assertionFailed{#1}{Expected a second argument}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if there is a second argument]

\startConTest
\begingroup
  \def\twoArguments[#1][#2]{\relax}
  \dodoubleempty\twoArguments[firstArgument][secondArgument]
  \assertSecondArgument{A message}
\endgroup
\stopConTest
\stopTestCase

\startTestCase[should fail if there is no second argument]

\startConTest
\begingroup
  \def\twoArguments[#1][#2]{\relax}
  \dodoubleempty\twoArguments[firstArgument]
  \startAssertShouldFail{}{}{}
    \assertSecondArgument{A message}
  \stopAssertShouldFail
\endgroup
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertNoSecondArgument]

The \type{\assertNoSecondArgument} assertion confirms that any previous 
\ConTeXt\ multiple optional argument macro did not have a second argument. 

\startMkIVCode
\def\assertNoSecondArgument#1{%
  \ifsecondargument%
    \assertionFailed{#1}{Expected no second argument}%
  \else%
    \assertionSucceeded{#1}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if there is no second argument]

\startConTest
\begingroup
  \def\twoArguments[#1][#2]{\relax}
  \dodoubleempty\twoArguments[firstArgument]
  \assertNoSecondArgument{A message}
\endgroup
\stopConTest
\stopTestCase

\startTestCase[should fail if there is a second argument]

\startConTest
\begingroup
  \def\twoArguments[#1][#2]{\relax}
  \dosingleempty\twoArguments[firstArgument][secondArgument]
  \startAssertShouldFail{}{}{}
    \assertNoSecondArgument{A message}
  \stopAssertShouldFail
\endgroup
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertThirdArgument]

The \type{\assertThirdArgument} assertion confirms that any previous 
\ConTeXt\ multiple optional argument macro had a third argument. 

\startMkIVCode
\def\assertThirdArgument#1{%
  \ifthirdargument%
    \assertionSucceeded{#1}%
  \else%
    \assertionFailed{#1}{Expected a third argument}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if there is a third argument]

\startConTest
\begingroup
  \def\threeArguments[#1][#2][#3]{\relax}
  \dotripleempty\threeArguments%
    [firstArgument][secondArgument][thirdArgument]
  \assertThirdArgument{A message}
\endgroup
\stopConTest
\stopTestCase

\startTestCase[should fail if there is no third argument]

\startConTest
\begingroup
  \def\threeArguments[#1][#2][#3]{\relax}
  \dotripleempty\threeArguments[firstArgument][secondArgument]
  \startAssertShouldFail{}{}{}
    \assertThirdArgument{A message}
  \stopAssertShouldFail
\endgroup
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertNoThirdArgument]


The \type{\assertNoThirdArgument} assertion confirms that any previous 
\ConTeXt\ multiple optional argument macro did not have a third argument. 

\startMkIVCode
\def\assertNoThirdArgument#1{%
  \ifthirdargument%
    \assertionFailed{#1}{Expected no third argument}%
  \else%
    \assertionSucceeded{#1}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if there is no third argument]

\startConTest
\begingroup
  \def\threeArguments[#1][#2][#3]{\relax}
  \dotripleempty\threeArguments[firstArgument][secondArgument]
  \assertNoThirdArgument{A message}
\endgroup
\stopConTest
\stopTestCase

\startTestCase[should fail if there is a third argument]

\startConTest
\begingroup
  \def\threeArguments[#1][#2][#3]{\relax}
  \dotripleempty\threeArguments%
    [firstArgument][secondArgument][thirdArgument]
  \startAssertShouldFail{}{}{}
    \assertNoThirdArgument{A message}
  \stopAssertShouldFail
\endgroup
\stopConTest
\stopTestCase
\stopTestSuite


\section[title=Tracing and Mocking \ConTeXt]

While trying to understand what \TeX\ and \ConTeXt\ are doing while 
expanding complex macros, it is useful to trace the expansion of 
particular macros. We can do this by either directly wrapping a given 
macro with our own marco or indirectly by providing a \quote{mock} version 
of the macro. Often in unit testing scenarios it is important that 
interactions between complex sub-parts of a system be isolated. We use 
\quote{mocked} versions of macros to provide this isolation for testing 
purposes. 

We will build this tracing and mocking capability over the following 
collection of test suites. In the first test suite we define the Lua 
methods which implement both the tracing and mocking. In the next two 
test suites we use meta-programming to define either tracing existing 
macros or mocking macros. In both cases the key distinction is between 
whether or not the traced or mock macro has a fixed or optional number of 
arguments. The subsequent test suites provide detailed assertions that 
traced or mocked macros were expanded a given number of times with 
particular arguments. Finally the last test suite provides an important 
example of the use of mocked macros by mocking the standard \TeX\ 
\type{\errmessage} macro. 

\startTestSuite[Lua tracing and mocking methods]

In this test suite we specify the Lua methods used by the \TeX\ and 
\ConTeXt\ tracing and mocking macros. We begin by clearing the current 
expansion information for \emph{all} traced or mocked macros. 

\startLuaCode
local function clearAllExpansionInfo()
  contests.expansionInfo = { }
  expInfo                = contests.expansionInfo
  expInfo.logginOn       = false
end

contests.clearAllExpansionInfo = clearAllExpansionInfo
\stopLuaCode

\startMkIVCode
\def\clearAllExpansionInfo{%
  \directlua{%
    thirddata.contests.clearAllExpansionInfo()
  }
}
\stopMkIVCode

Sometimes we want to clear the expansion information for a particular 
traced or mocked macro. 

\startLuaCode
local function clearExpansionInfoFor(expandedMacro)
  expandedMacro = expandedMacro:gsub('^%s+', ''):gsub('%s+$', '')
  expInfo[expandedMacro] = { }
end

contests.clearExpansionInfoFor = clearExpansionInfoFor
\stopLuaCode

\startMkIVCode
\def\clearExpansionInfoFor#1{%
  \directlua{%
    thirddata.contests.clearExpansionInfoFor('#1')
  }
}
\stopMkIVCode

By default traced or mocked macro expansions are not reported to the 
\LuaTeX\ \type{texio} log. The \type{setExpansionLogging} method starts or 
stops the expansion logging. 

\startLuaCode
local function setExpansionLogging(logExpansion)
  expInfo.loggingOn = logExpansion
  if logExpansion then
    texio.write_nl('>>---------------------------------------->>')
    texio.write_nl('AT: '..status.filename..'::'..status.linenumber)
    texio.write_nl('>>---------------------------------------->>')
  else
    texio.write_nl('<<----------------------------------------<<')
    texio.write_nl('AT: '..status.filename..'::'..status.linenumber)
    texio.write_nl('<<----------------------------------------<<')
  end
end

contests.setExpansionLogging = setExpansionLogging
\stopLuaCode

We provide the following \TeX\ convenience macros to start and stop 
logging: 

\startMkIVCode
\def\startLoggingExpansions{%
  \directlua{thirddata.contests.setExpansionLogging(true)}
}

\def\stopLoggingExpansions{%
  \directlua{thirddata.contests.setExpansionLogging(false)}
}

\def\logMessage#1{%
  \writestatus{contests}{#1}#1\\
}
\stopMkIVCode

We next define the Lua code which will capture the information used to 
eventually test the expansion patterns of traced or mocked macros. Note 
that we use a lazy initialization strategy for any particular traced or 
mocked macro. 

\startLuaCode
local function recordExpansion(macroName,
                               callType,
                               macroArguments)
  if expInfo.loggingOn then
    texio.write_nl(
      'EXPANSION '..callType..
      ' macro expanded ['..macroName..']'
    )
    for i, anArg in ipairs(macroArguments) do
      texio.write_nl(
        '  args['..toStr(i)..'] = ['..toStr(anArg)..']'
      )
    end
    texio.write_nl('AT: '..status.filename..'::'..status.linenumber)
  end
  macroName = macroName:gsub('^%s+', ''):gsub('%s+$', '')
  expInfo[macroName] = expInfo[macroName] or { }
  local macroInfo    = expInfo[macroName]
  macroInfo.calls    = macroInfo.calls or { }
  tInsert(macroInfo.calls, { callType, macroArguments})
  return macroInfo
end

contests.recordExpansion = recordExpansion
\stopLuaCode

Unlike traced macros, to simulate existing complex macros, some mocked 
macros will need to return \quote{canned} results. To do this we call the 
\type{returnMockedResults} Lua method. \type{returnMockedResult}'s only 
argument is the expansion info table associated with the given 
expandedMacro's name as returned by \type{recordExpansion} method defined 
above. 

\startLuaCode
local function returnMockedResults(expandedMacro)
  expandedMacro.returns = expandedMacro.returns or { }
  local result = tRemove(expandedMacro.returns, 1)
  if result and 
     type(result) == 'string' and
     not result:match('^%s*$') then
    tex.print(result)
  end
end

contests.returnMockedResults = returnMockedResults
\stopLuaCode

Before any mocked results will be returned, the \quote{canned} results 
must be added to the mocked macro's expansion info table. 

\startLuaCode
local function addMockResult(mockedMacro, returnValue)
  mockedMacro = mockedMacro:gsub('^%s+', ''):gsub('%s+$', '')
  expInfo[mockedMacro] = expInfo[mockedMacro] or { }
  mockedMacro          = expInfo[mockedMacro]
  mockedMacro.returns  = mockedMacro.returns or { }
  tInsert(mockedMacro.returns, returnValue)
end

contests.addMockResult = addMockResult
\stopLuaCode

We define the \type{\addMockResult} macro which adds a return 
value to the appropriate mocked macro. 

\startMkIVCode
\def\addMockResult#1#2{%
  \directlua{%
    thirddata.contests.addMockResult('#1', '#2')
  }
}
\stopMkIVCode

Lastly we provide a convenience method which both records a given 
expansion and then returns any mocked results. 

\startLuaCode
local function mockExpansion(expandedMacro,
                               macroArguments,
                               callType)
  expandedMacro = recordExpansion(expandedMacro,
                               macroArguments,
                               callType)
  returnMockedResults(expandedMacro)
end

contests.mockExpansion = mockExpansion
\stopLuaCode

At the moment, we actually only implicitly test these Lua methods via the 
test suites defined below. 

\stopTestSuite

\startTestSuite[Macros with a fixed number of arguments]

There are two classes of macros which we might want to trace or mock. 
Those macros which have a fixed number of arguments, and those which have 
an optional number of arguments. In this section we deal with tracing or 
mocking macros which have a fixed number of arguments. We deal with the 
\ConTeXt\ idiom of optional arguments in the next test suite. 

In this section we provide the ability to either trace or mock a macro 
with a fixed number of arguments. While we could do all of this in native 
\TeX\ or \ConTeXt, we find it easier to make use of the Lua based template 
renderer provided by the Literate Programming \ConTeXt\ module. To do this 
we we define the \type{\traceTexMacro}, \type{\traceContextMacro}, 
\type{\mockTexMacro} and \type{\mockContextMacro} to make use of 
\type{\directlua} to call the Lua function \type{createMacro}. The Lua 
\type{createMacro} method takes four arguments, the macro name, the 
number of arguments expected by the macro, and the type of macro (either 
\quote{tex} or \quote{context}) and whether we are tracing or mocking. 

\startMkIVCode
\def\traceTexMacro#1#2{%
  \directlua{%
    thirddata.contests.createMacro('#1', #2, 'tex', 'trace')
  }
}

\def\traceContextMacro#1#2{%
  \directlua{%
    thirddata.contests.createMacro('#1', #2, 'context', 'trace')
  }
}

\def\mockTexMacro#1#2{%
  \directlua{%
    thirddata.contests.createMacro('#1', #2, 'tex', 'mock')
  }
}

\def\mockContextMacro#1#2{%
  \directlua{%
    thirddata.contests.createMacro('#1', #2, 'context', 'mock')
  }
}
\stopMkIVCode

We now develop the Lua template which represents the \TeX\ macro used to 
define the traced or mocked \TeX\ or \ConTeXt\ macro. By using a Lua 
template approach, we are following a \emph{meta-programming} approach. 
Using this approach a simple call to the Lua method \type{createMacro} 
expands into the rather more complex \TeX\ macros required to trace or 
mock the macro into one that uses either the Lua method 
\type{recordExpansion} or \type{mockExpansion} to make a record of the 
fact that the original macro was expanded with a particular collection of 
arguments. 

When we \emph{trace} an existing macro we \emph{wrap} it in order to 
record its pattern of expansion through time. We do this by 
\type{\let}'ing an existing macro to a different name and then redefining 
the existing macro to call into Lua to record a trace of what has been 
expanded together with what arguments were provided. Once this has been 
done, the original macro with its arguments are expanded as normal. 

When we \emph{mock} a macro in order to both simulate its action as well 
as to record its pattern of expansion, we define the mocked macro to call 
into Lua to record a trace of what has been expanded together with what 
arguments were provided. If the user has provided mock results for the 
macro, the Lua call then returns those results, in order, to \TeX. 

These two distinct patterns of use are provided by the two templates, 
\type{ctmMain} and \type{cmmMain} respectively. In both cases, we have two 
distinct argument delimiting patterns to deal with depending on the 
different ways the \quote{standard} native \TeX\ macro and a 
\quote{standard} \ConTeXt\ macros delimit their arguments. We begin 
developing the required templates by providing simple Lua templates to 
deal with the \TeX\ and \ConTeXt\ argument patterns. In particular, the 
\quote{standard} \ConTeXt\ macros wrap their \emph{optional} arguments in 
pairs of \quote{[} and \quote{]} symbols. These two patterns are dealt 
with in the two templates \type{cmTexFormalArgs} and 
\type{cmContextFormalArgs} respectively. 

\startLuaTemplate
addTemplate(
  'cmTexFormalArgs',
  { 'anArg' },
  '#{{= anArg}}'
)

addTemplate(
  'cmTexUseArgs',
  { 'anArg' },
  '{#{{= anArg}}}'
)

addTemplate(
  'cmContextFormalArgs',
  { 'anArg' },
  '[#{{= anArg}}]'
)
\stopLuaTemplate

The \type{cmFormalArgs} template determines which of the above two 
templates will be used to define the wrapper macro. Using Parr's 
\quote{push semantics}, \cite{parr2004templateMVC}, we do this by using an 
indirect template reference, using the template argument 
\type{argTemplate} which was previously computed by the Lua 
\type{createMacro} before attempting to expand the templates. 

\startLuaTemplate
addTemplate(
  'cmFormalArgs',
  { 'anArg', 'argTemplate' },
  '{{! *argTemplate, anArg }}'
)
\stopLuaTemplate

Having defined how to deal with the two types of formal arguments, we now 
define a simple template \type{cmLuaArgUse} which expands into the text 
required to pass the actual arguments provided into the Lua 
\type{recordExpansion} method. Note that all of the original macro's 
arguments are passed into Lua as Lua strings. 

\startLuaTemplate
addTemplate(
  'cmLuaArgUse',
  { 'anArg' },
  "        '#{{= anArg}}'"
)
\stopLuaTemplate

We can now provide the main template, \type{ctmMain}, which is used to 
create a \TeX\ macro which \emph{wraps} an existing \TeX\ macro. 

\startLuaTemplate
addTemplate(
  'ctmMain',
  { 'macroName', 'argList', 'argType',
    'argTemplate', 'argUseTemplate',
    'emptyStr', 'commaNewLine' },
  [=[
\let\old{{= macroName}}=\{{= macroName}}
\clearExpansionInfoFor{ {{= macroName}} }
\def\{{= macroName}}{{| argList, emptyStr, cmFormalArgs,
                        anArg, argTemplate }}{%
  \directlua{%
    thirddata.contests.recordExpansion(
      '{{= macroName}}',
      '{{= argType}}',
      { 
{{| argList, commaNewLine, cmLuaArgUse, anArg }}
      }
    )
  }
  \old{{= macroName}}{{| argList, emptyStr, cmFormalArgs,
                         anArg, argUseTemplate }}
}
]=]
)
\stopLuaTemplate

Having dealt with the tracing case, we can now deal with the mocking case. 
To do this we provide the main template, \type{cmmMain}, which is used to 
create a \TeX\ macro which \emph{mocks} a \TeX\ macro. 

\startLuaTemplate
addTemplate(
  'cmmMain',
  { 'macroName', 'argList', 'argType',
    'argTemplate', 'argUseTemplate',
    'emptyStr', 'commaNewLine' },
  [=[
\let\old{{= macroName}}=\{{= macroName}}
\clearExpansionInfoFor{ {{= macroName}} }
\def\{{= macroName}}{{| argList, emptyStr, cmFormalArgs,
                        anArg, argTemplate }}{%
  \directlua{%
    thirddata.contests.mockExpansion(
      '{{= macroName}}',
      '{{= argType}}',
      { 
{{| argList, commaNewLine, cmLuaArgUse, anArg }}
      }
    )
  }
}
]=]
)
\stopLuaTemplate

Finally, we provide the Lua \type{createMacro} method itself. this method 
has four principle sections. 

Since we are using Parr's \emph{push semantics}, 
\cite{parr2004templateMVC}, the first section precomputes all of the 
template arguments required for the full template expansion. In particular 
this means we must build the \type{argList} which is a list of the \TeX\ 
argument numbers corresponding to the number of arguments the original 
\TeX\ or \ConTeXt\ macro is defined to consume. We must also determine 
which of the two formal argument templates will be used to render the 
formal arguments required to re-define the wrapped macro. 

The last three sections then build the template environment, find and 
render the \type{ctmMain} ot \type{cmmMain} template as appropriate and 
then split the resulting rendered text into single lines to be fed back to 
\TeX\ to process. Finally we return the rendered text split into 
individual lines to allow for ConTest testing. 

When true, the \type{aTracingOn} argument to the \type{createTraceMacro} 
provides a trace, using \type{texio.write_nl} of the template expansion 
itself. When true, this allows the template developer to visual verify 
that the template has expanded as expected. By default the 
\type{createMacro} is called with \type{aTracingOn} as false. 

\startLuaCode
local function createMacro(theMacroName,
                           numArgs,
                           theArgType,
                           theActionType,
                           aTracingOn)
  local theArgList = { }
  for argNum = 1, numArgs, 1 do
    tInsert(theArgList, argNum)
  end
  local theArgTemplate = 'cmTexFormalArgs'
  if theArgType == 'context' then
    theArgTemplate = 'cmContextFormalArgs'
  end
  local theArgUseTemplate = 'cmTexUseArgs'
  if theArgType == 'context' then
    theArgUseTemplate = 'cmContextFormalArgs'
  end
  --
  local theEnv     = {
    tracingOn      = aTracingOn,
    macroName      = theMacroName,
    argList        = theArgList,
    argType        = theArgType,
    argTemplate    = theArgTemplate,
    argUseTemplate = theArgUseTemplate,
    emptyStr       = '',
    commaNewLine   = ',\n'
  }
  --
  local mainName   = 'ctmMain'
  if theActionType == 'mock' then
    mainName = 'cmmMain'
  end
  local mainPath     = litProgs.parseTemplatePath(mainName, theEnv)
  local mainTemplate = litProgs.navigateToTemplate(mainPath)
  local result       = litProgs.renderer(mainTemplate, theEnv, true)
  --
  result            = litProgs.splitString(result)
  tex.print(result)
  return result
end

contests.createMacro = createMacro
\stopLuaCode

\startTestCase[createMacro should create the required TeX or ConTeXt macros]

\startLuaTest
local createMacro = thirddata.contests.createMacro

local macroBody = createMacro('test', 3, 'context', 'trace')
assert.isTable(macroBody)
assert.length(macroBody, 16)
assert.isEqual(macroBody[1],  "\\let\\oldtest=\\test")
assert.isEqual(macroBody[2],  "\\clearExpansionInfoFor{ test }")
assert.isEqual(macroBody[3],  "\\def\\test[#1][#2][#3]{%")
assert.isEqual(macroBody[4],  "  \\directlua{%")
assert.isEqual(macroBody[5],  "    thirddata.contests.recordExpansion(")
assert.isEqual(macroBody[6],  "      'test',")
assert.isEqual(macroBody[7],  "      'context',")
assert.isEqual(macroBody[8],  "      {")
assert.isEqual(macroBody[9],  "        '#1',")
assert.isEqual(macroBody[10], "        '#2',")
assert.isEqual(macroBody[11], "        '#3'")
assert.isEqual(macroBody[12], "      }")
assert.isEqual(macroBody[13], "    )")
assert.isEqual(macroBody[14], "  }")
assert.isEqual(macroBody[15], "  \\oldtest[#1][#2][#3]")
assert.isEqual(macroBody[16], "}")
--
macroBody = createMacro('test', 3, 'tex', 'trace')
assert.isTable(macroBody)
assert.length(macroBody, 16)
assert.isEqual(macroBody[1],  "\\let\\oldtest=\\test")
assert.isEqual(macroBody[2],  "\\clearExpansionInfoFor{ test }")
assert.isEqual(macroBody[3],  "\\def\\test#1#2#3{%")
assert.isEqual(macroBody[4],  "  \\directlua{%")
assert.isEqual(macroBody[5],  "    thirddata.contests.recordExpansion(")
assert.isEqual(macroBody[6],  "      'test',")
assert.isEqual(macroBody[7],  "      'tex',")
assert.isEqual(macroBody[8],  "      {")
assert.isEqual(macroBody[9],  "        '#1',")
assert.isEqual(macroBody[10], "        '#2',")
assert.isEqual(macroBody[11], "        '#3'")
assert.isEqual(macroBody[12], "      }")
assert.isEqual(macroBody[13], "    )")
assert.isEqual(macroBody[14], "  }")
assert.isEqual(macroBody[15], "  \\oldtest{#1}{#2}{#3}")
assert.isEqual(macroBody[16], "}")
--
macroBody = createMacro('test', 3, 'context', 'mock')
assert.isTable(macroBody)
assert.length(macroBody, 15)
assert.isEqual(macroBody[1],  "\\let\\oldtest=\\test")
assert.isEqual(macroBody[2],  "\\clearExpansionInfoFor{ test }")
assert.isEqual(macroBody[3],  "\\def\\test[#1][#2][#3]{%")
assert.isEqual(macroBody[4],  "  \\directlua{%")
assert.isEqual(macroBody[5],  "    thirddata.contests.mockExpansion(")
assert.isEqual(macroBody[6],  "      'test',")
assert.isEqual(macroBody[7],  "      'context',")
assert.isEqual(macroBody[8],  "      {")
assert.isEqual(macroBody[9],  "        '#1',")
assert.isEqual(macroBody[10], "        '#2',")
assert.isEqual(macroBody[11], "        '#3'")
assert.isEqual(macroBody[12], "      }")
assert.isEqual(macroBody[13], "    )")
assert.isEqual(macroBody[14], "  }")
assert.isEqual(macroBody[15], "}")
--
macroBody = createMacro('test', 3, 'tex', 'mock')
assert.isTable(macroBody)
assert.length(macroBody, 15)
assert.isEqual(macroBody[1],  "\\let\\oldtest=\\test")
assert.isEqual(macroBody[2],  "\\clearExpansionInfoFor{ test }")
assert.isEqual(macroBody[3],  "\\def\\test#1#2#3{%")
assert.isEqual(macroBody[4],  "  \\directlua{%")
assert.isEqual(macroBody[5],  "    thirddata.contests.mockExpansion(")
assert.isEqual(macroBody[6],  "      'test',")
assert.isEqual(macroBody[7],  "      'tex',")
assert.isEqual(macroBody[8],  "      {")
assert.isEqual(macroBody[9],  "        '#1',")
assert.isEqual(macroBody[10], "        '#2',")
assert.isEqual(macroBody[11], "        '#3'")
assert.isEqual(macroBody[12], "      }")
assert.isEqual(macroBody[13], "    )")
assert.isEqual(macroBody[14], "  }")
assert.isEqual(macroBody[15], "}")
\stopLuaTest
\stopTestCase

\stopTestSuite

\startTestSuite[Macros with optional number of arguments]

At the moment we do not need to deal with either tracing or mocking macros 
with an optional number of arguments, so we postpone developing this 
capability until sometime in the future. 

\stopTestSuite

\startTestSuite[assertMockExpanded assertMockNeverExpanded and assertMockExpandedNTimes]

We sometimes need to assert that a given macro has been used with given 
arguments. For example we might want to assert that a macro does or does 
not \quote{throw} an \type{\errmessage}.

\startMkIVCode
\def\assertMacroExpanded#1#2{%
  \directlua{%
    thirddata.contests.assertMacroExpanded('#1', 1, '#2')
  }
}

\def\assertMacroNeverExpanded#1#2{%
  \directlua{%
    thirddata.contests.assertMacroNeverExpanded('#1', 1, '#2')
  }
}

\def\assertMacroExpandedNTimes#1#2#3{%
  \directlua{%
    thirddata.contests.assertMacroExpanded('#1', #2, '#3')
  }
}

\def\assertMacroNeverExpandedNTimes#1#2#3{%
  \directlua{%
    thirddata.contests.assertMacroNeverExpanded('#1', #2, '#3')
  }
}
\stopMkIVCode

\startLuaCode
function assertMacroExpanded(macroName, callNum, aMessage)
  local expectedMsg = 'Expected ['..macroName..']'
  local macroInfo   = expInfo[macroName]
  contests.reportMkIVAssertion(
    macroInfo ~= nil
    and macroInfo.calls ~= nil
    and macroInfo.calls[callNum] ~= nil,
    aMessage,
    expectedMsg..' to have been expanded at least '..
      toStr(callNum)..' times.'
  )
end

contests.assertMacroExpanded = assertMacroExpanded

function assertMacroNeverExpanded(macroName, callNum, aMessage)
  local expectedMsg = 'Expected ['..macroName..']'
  local macroInfo   = expInfo[macroName]
  contests.reportMkIVAssertion(
    macroInfo == nil
    or macroInfo.calls == nil
    or macroInfo.calls[callNum] == nil,
    aMessage,
    expectedMsg..' to have never been expanded '..
      toStr(callNum)..' times.'
  )
end

contests.assertMacroNeverExpanded = assertMacroNeverExpanded
\stopLuaCode

\startTestCase[Mocked tex macro]

The \type{\assertMacroExpanded} assertion should succeed if the traced or 
mocked macro has ever been expanded. The \type{\assertMacroExpandedNTimes} 
should succeed if it has been expanded the specified number of times. The 
\type{\assertMacroeverExpanded} assertion should succeed if the traced or 
mocked macros have never been expanded. 

\startConTest
\begingroup
  \mockTexMacro{aTexMockZeroArgs}{0}
  \aTexMockZeroArgs
  \assertMacroExpanded{aTexMockZeroArgs}{}
  \startAssertShouldFail{}{}{}
    \assertMacroNeverExpanded{aTexMockZeroArgs}{}
  \stopAssertShouldFail
  \assertMacroExpandedNTimes{aTexMockZeroArgs}{1}{}
\endgroup
\stopConTest

\stopTestCase

\startTestCase[Mocked context macro]
\startConTest
\begingroup
  \mockContextMacro{aContextMock}{0}
  \startAssertShouldFail{}{}{}
    \assertMacroExpanded{aContextMock}{}
  \stopAssertShouldFail
  \assertMacroNeverExpanded{aContextMock}{}
  \aContextMock
  \assertMacroExpandedNTimes{aContextMock}{1}{}
  \startAssertShouldFail{}{}{}
    \assertMacroNeverExpanded{aContextMock}{}
  \stopAssertShouldFail
  \startAssertShouldFail{}{}{}
    \assertMacroExpandedNTimes{aContextMock}{2}{}
  \stopAssertShouldFail
  \assertMacroNeverExpandedNTimes{aContextMock}{2}{}
\endgroup
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertMacroNthArgumentOnMthExpansionMatches]

\startMkIVCode
\def\assertMacroNthArgumentOnMthExpansionMatches#1#2#3#4#5{%
  \directlua{%
    thirddata.contests.assertMacroArguments(
      '#1', #3, #2, '#4', '#5'
    )
  }
}
\stopMkIVCode

\startLuaCode
function assertMacroArguments(macroName,
                              callNum,
                              argNum,
                              aPattern,
                              aMessage)
  local expectedMsg = 'Expected ['..macroName..'] '
  local macroInfo = expInfo[macroName]
  if macroInfo then
    local calls = macroInfo.calls
    if calls then
      local aCall = calls[callNum]
      if aCall then
        local anArg = aCall[2][argNum]
        if anArg then
          if sMatch(anArg, aPattern) then
            reportMkIVAssertion(true, aMessage, '')
          else
            reportMkIVAssertion(false, aMessage,
              expectedMsg..'the '..
              toStr(argNum)..' argument on the '..
              toStr(callNum)..' expansion to match ['..
              aPattern..']')
          end
        else
          reportMkIVAssertion(false, aMessage,
            expectedMsg..'to have supplied '..
            toStr(argNum)..' arguments on the '..
            toStr(callNum)..' expansion')
        end
      else
        reportMkIVAssertion(false, aMessage,
          expectedMsg..'to have been expanded '..
          toStr(callNum)..' times')
      end
    else
      reportMkIVAssertion(false, aMessage,
        expectedMsg..'to have been expanded')
    end
  else
    reportMkIVAssertion(false, aMessage,
      expectedMsg..'to be defined')
  end
end

contests.assertMacroArguments = assertMacroArguments
\stopLuaCode

\startTestCase[should succeed if mocked macro expanded]

The \type{\assertMacroNthArgumentOnMthExpansionMatches} assertion should 
succeed if $\text{n}^{\text{th}}$ argument of the $\text{m}^{\text{th}}$ 
of the mocked macro has been expanded with arguments which match the given 
pattern. 

\startConTest
\begingroup
  \mockTexMacro{aTexMockTwoArgs}{2}
  \aTexMockTwoArgs%
    {first arg first expansion}{second arg first expansion}
  \aTexMockTwoArgs%
    {first arg second expansion}{second arg second expansion}
  \assertMacroNthArgumentOnMthExpansionMatches%
    {aTexMockTwoArgs}{1}{1}{first arg first expansion}{}
  \assertMacroNthArgumentOnMthExpansionMatches%
    {aTexMockTwoArgs}{1}{2}{first arg second expansion}{}
  \assertMacroNthArgumentOnMthExpansionMatches%
    {aTexMockTwoArgs}{2}{1}{second arg first expansion}{}
  \assertMacroNthArgumentOnMthExpansionMatches%
    {aTexMockTwoArgs}{2}{2}{second arg second expansion}{}
\endgroup
\stopConTest
\stopTestCase

\startTestCase[should fail if mocked macro never expanded]
\startConTest
\begingroup
  \mockContextMacro{aContextMock}{2}
  \aContextMock%
    [only arg first expansion][]
  \aContextMock%
    [first arg second expansion]%
    [second arg second expansion]
  \assertMacroNthArgumentOnMthExpansionMatches%
    {aContextMock}{1}{1}{only arg first expansion}{}
  \assertMacroNthArgumentOnMthExpansionMatches%
    {aContextMock}{1}{2}{first arg second expansion}{}
  \startAssertShouldFail{}%
    {Expected [aContextMock] to have supplied}%
    {}
    \assertMacroNthArgumentOnMthExpansionMatches%
      {aContextMock}{2}{1}{second arg first expansion}{}
  \stopAssertShouldFail
  \assertMacroNthArgumentOnMthExpansionMatches%
    {aContextMock}{2}{2}{second arg second expansion}{}
\endgroup
\stopConTest
\stopTestCase

\startTestCase[Traced inner and outer tex macros]

\startConTest
\begingroup
  \mockTexMacro{innerTexMacro}{1}
  \def\aTexMacro#1{\innerTexMacro{#1}}
  \traceTexMacro{aTexMacro}{1}
  \aTexMacro{anArgument}
  \assertMacroNthArgumentOnMthExpansionMatches%
    {innerTexMacro}{1}{1}{anArgument}{}
  \assertMacroNthArgumentOnMthExpansionMatches%
    {aTexMacro}{1}{1}{anArgument}{}
\endgroup
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[Adding mock results]

\startTestCase[should return result provided]

Note that since the \type{\defContextMock} family of macros are all 
protected, there is no easy way of capturing the results of the macro 
expansion in any way that can be transfered to the lua back-end. This is 
why we explicitly expand the \type{\aContextMock[anArg]} into 
\type{\callContextMockSingle{aConTexMock}[anArg][][]}. 

% see https://tex.stackexchange.com/a/60302
% a “… doesn't match its definition” problem, that I don't understand

\startConTest
\begingroup
  \mockTexMacro{aTexMockZeroArgs}{0}
  \addMockResult{aTexMockZeroArgs}{aResult}
  \assertStringMatches{\aTexMockZeroArgs}{aResult}{}
\endgroup
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertErrorThrown]

One of the primary uses of the above mocking assertions is to provide 
assertions for macros which \quote{throw} \type{\errmessage}s. We do this 
explicitly mocking \type{\errmessage}. 

\startMkIVCode
\def\mockErrMessage{%
  \mockTexMacro{errmessage}{1}
}
\def\assertErrorThrown#1{%
  \assertMacroExpanded{errmessage}{#1}
}
\stopMkIVCode

\startTestCase[should succeed if error thrown]

We want to show that if a command throws a \TeX\ \type{\errmessage}, then 
the associated test case fails. 

\startConTest
\begingroup
  \mockErrMessage
  \errmessage{Throw this message}
  \assertErrorThrown{aMessage}
\endgroup
\stopConTest
\stopTestCase

\startTestCase[should fail is no error thrown]

Conversely we need to show that the \type{\assertErrorThrown} assertion 
fails if not error is thrown. 

\startConTest
\begingroup
  \mockErrMessage
  \startAssertShouldFail{aMessage}{}{}
    \assertErrorThrown{aMessage}
  \stopAssertShouldFail
\endgroup
\stopConTest
\stopTestCase

\stopTestSuite

\section{Test case results}

\reportMkIVStats

\reportFailures

\stopchapter
