% A ConTeXt document [master document: contests.tex]

\startchapter[title=MkIV Unit Testing]

We provide an evolving collection of unit test assertions in \ConTeXt. 

\nonstopmode

\section[title=Test cases]

%\definetyping[ConTest]
%\setuptyping[ConTest][option=context]

\startMkIVCode

%%%%%%%%%%%%%%%%
% ConTest code %
%%%%%%%%%%%%%%%%

\definetyping[ConTest]
\setuptyping[ConTest][option=context]

\let\oldStopConTest=\stopConTest
\def\stopConTest{%
  \oldStopConTest%
  \directlua{thirddata.contests.addConTest('_typing_')}
}

\def\reportMkIVStats{%
  \directlua{thirddata.contests.reportStats('mkiv')}
}

\stopMkIVCode

\startLuaCode
------------------
-- ConTest code --
------------------

function contests.addConTest(bufferName)
  local bufferContents = buffers.getcontent(bufferName):gsub("\13", "\n")
  local suite = tests.curSuite
  local case  = suite.curCase
  case.mkiv   = case.mkiv or {}
  table_insert(case.mkiv, bufferContents)
end

function contests.runCurMkIVTestCase(suite, case)
  case.passed = case.passed or true
  case.mkiv   = case.mkiv   or { }
  local mkivChunk = table_concat(case.mkiv, '\n')
  if not mkivChunk:match('^%s*$') then
    local caseStats = tests.stats.mkiv.cases
    caseStats.attempted = caseStats.attempted + 1
    tex.print("\\directlua{thirddata.contests.startConTestImplementation()}")
    for i, aChunk in ipairs(case.mkiv) do
      for aLine in string.gmatch(aChunk, '[^\n]*') do
        if 0 < #aLine then
          tex.print(aLine)
        end
      end
    end
    tex.print("\\directlua{thirddata.contests.stopConTestImplementation()}")
  end
end

local function conTestShowErrorHook()
  --tests.curSuite.curCase.caughtError = true
  --texio.write_nl('================================================================')
  --texio.write_nl("Caught error")
  --texio.write_nl(status.lasterrorstring)
  --texio.write_nl(status.lasterrorcontext)
  --texio.write_nl('================================================================')
end

function contests.startConTestImplementation()
  --tests.curSuite.curCase.caughtError = false
  -- save logging.... -- alas we can not ;-(
  -- turn logging to no-stop/batch
  --callback.register('show_error_hook', conTestShowErrorHook)
end

function contests.stopConTestImplementation()
  --callback.register('show_error_hook', nil)
  -- turn logging back to original value
  local curCase  = tests.curSuite.curCase
  local caseStats = mkivStats.cases
  if curCase.passed then
    caseStats.passed = caseStats.passed + 1
  else
    caseStats.failed = caseStats.failed + 1
  end
end

\stopLuaCode

\section[title=Assertions]

We start by defining two helper functions to declare (to the lua code) 
that an assertion together with its message and reason (for failure) has 
either failed or succeeded. 

\startMkIVCode
\def\assertionFailed#1#2{%
  \directlua{thirddata.contests.reportMkIVAssertion(false, '#1', '#2')}
}

\def\assertionSucceeded#1{%
  \directlua{thirddata.contests.reportMkIVAssertion(true, '#1', '')}
}
\stopMkIVCode

\startLuaCode
function contests.reportMkIVAssertion(theCondition, aMessage, theReason)
  local curSuite  = tests.curSuite
  local curCase   = curSuite.curCase
  mkivAssertions.attempted = mkivAssertions.attempted + 1

  if type(curCase.shouldFail) == 'table'  then
    local shouldFail = curCase.shouldFail
    local innerMessage = aMessage
    local innerReason  = theReason
    theReason = nil
    theCondition = not theCondition
    if theReason ~= nil
      and shouldFail.messagePattern ~= nil
      and type(shouldFail.messagePattern) == 'string'
      and 0 < #shouldFail.messagePattern
      and aMessage:match(shouldFail.messagePattern) then
      -- do nothing
    else
      theReason = fmt('Expected inner message [%s] to match [%s]',
        innerMessage, shouldFail.messagePattern)
    end
    if theReason ~= nil
      and shouldFail.reasonPattern ~= nil
      and type(shouldFail.reasonPattern) == 'string'
      and 0 < #shouldFail.reasonPattern
      and theReason:match(shouldFail.reasonPattern) then
      -- do nothing
    else
      theReason = fmt('Expected inner failure reason [%s] to match [%s]',
        innerReason, shouldFail.reasonPattern)
    end
    if theReason ~= nil then
      theReason = 'Expected inner assertion ['..aMessage..'] to fail'
    end
    aMessage  = shouldFail.message
    curCase.shouldFail = nil
  end

  if theCondition then
    mkivAssertions.passed = mkivAssertions.passed + 1
  else
    curSuite.passed = false
    curCase.passed  = false
    mkivAssertions.failed = mkivAssertions.failed + 1
    local failure = logFailure(
      "ConTest FAILED",
      curSuite.desc,
      curCase.desc,
      aMessage,
      theReason,
      fmt("in file: %s between lines %s and %s",
        curCase.fileName,
        toStr(curCase.startLine),
        toStr(curCase.lastLine)
      )
    )
    reportFailure(failure, false)
    table_insert(tests.failures, failure)
  end
end
\stopLuaCode

As with the implementation of both the LuaTests and CTests, the heart of 
the ConTests is the ability to throw and capture errors. In this case it 
will be \TeX\ errors, when run, a TestCase will capture all \TeX\ errors 
and provide a report of where those errors happened. 

%\startTestSuite[assertThrowsError environment]
%
%\startMkIVCode
%\def\startAssertThrowsError#1{%
%  \def\startAssertionMessage{#1}
%  \directlua{thirddata.contests.tests.curSuite.curCase.caughtError = false}
%}
%
%\def\stopAssertThrowsError{%
%  \directlua{thirddata.contests.reportMkIVAssertion(
%    thirddata.contests.tests.curSuite.curCase.caughtError,
%    '\startAssertionMessage',
%    'Expected an error to be thrown'
%  )}
%}
%\stopMkIVCode
%
%\startTestCase[should succeed if error thrown]
%
%We want to show that if a command throws a \TeX\ \type{\errmessage}, then 
%the associated test case fails. 
%
%\startConTest
%\startAssertThrowsError{A Message}
%  \errmessage{Throw this message}
%\stopAssertThrowsError
%\stopConTest
%\stopTestCase
%
%\startTestCase[should fail if no error thrown]
%\startConTest
%\startAssertShouldFail%
%  {Inner message}{Expected an error to be thrown}{Outer message}
%\startAssertThrowsError{Inner message}
%No error is thrown
%\stopAssertThrowsError
%\stopAssertShouldFail
%\stopConTest
%\stopTestCase
%
%\stopTestSuite

%\startTestSuite[assertDoesNotThrowError]
%
%\startMkIVCode
%\def\startAssertDoesNotThrowError#1{%
%  \def\startAssertionMessage{#1}
%  \directlua{thirddata.contests.tests.curSuite.curCase.caughtError = false}
%}
%
%\def\stopAssertDoesNotThrowError{%
%  \directlua{thirddata.contests.reportMkIVAssertion(
%    not thirddata.contests.tests.curSuite.curCase.caughtError,
%    '\startAssertionMessage',
%    'Expected no error to be thrown'
%  )}
%}
%\stopMkIVCode
%
%\startTestCase[should succeed if no error thrown]
%
%\startConTest
%\startAssertDoesNotThrowError{A message}
%No error is thrown.
%\stopAssertDoesNotThrowError
%\stopConTest
%
%\stopTestCase
%
%\startTestCase[should fail if an error is thrown]
%
%\startConTest
%\startAssertShouldFail%
%  {Inner message}{Expected no error to be thrown}{Outer message}
%\startAssertDoesNotThrowError{Inner message}
%  \errmessage{Throw this error message}
%\stopAssertDoesNotThrowError
%\stopAssertShouldFail
%\stopConTest
%
%\stopTestCase
%
%\stopTestSuite

\startTestSuite[assertShouldFail environment]

The \type{assertShouldFail} environment provides a way to confirm that 
some \quote{inner} ConTest assertions have failed. The 
\type{\startAssertShouldFaile} command takes three arguments, a lua 
pattern to match against the inner message, a lua pattern to match against 
the inner reason, and an \quote{outer} message to be used by the 
\type{assertShouldFail} commands themselves. Upon successfully detecting 
the inner failure, the inner failure reports are removed. 

\startMkIVCode
\def\startAssertShouldFail#1#2#3{%
  \directlua{thirddata.contests.mkivAssertShouldFail('#1', '#2', '#3')}
}

\def\stopAssertShouldFail{\relax}

\stopMkIVCode

\startLuaCode
function contests.mkivAssertShouldFail(messagePattern, reasonPattern, aMessage)
  local curCase = tests.curSuite.curCase
  curCase.shouldFail = { }
  local shouldFail = curCase.shouldFail
  shouldFail.messagePattern = messagePattern
  shouldFail.reasonPattern  = reasonPattern
  shouldFail.message        = aMessage
end
\stopLuaCode

\startTestCase[should succeed if an inner assertion fails]

\startConTest
\startAssertShouldFail{Inner message}{(Failed)}{Outer message}
  \assertFail{Inner message}
\stopAssertShouldFail
\stopConTest

\stopTestCase

\startTestCase[should fail if an inner assertion does not fail]

\startConTest
\startAssertShouldFail%
  {Inner message}{Expected something}{Outer message}
  \startAssertShouldFail{}{}{Inner message}
    no flies on us.
  \stopAssertShouldFail
\stopAssertShouldFail
\stopConTest

\stopTestCase

\startTestCase[should fail if inner assertion fails with wrong message or reason]

\startConTest
\startAssertShouldFail{First outer message}{}{First outermost message}
\startAssertShouldFail{wrong}{}{First outer message}
  \assertFail{First inner message}
\stopAssertShouldFail
\stopAssertShouldFail

\startAssertShouldFail{Second outer message}{}{Second outermost message}
\startAssertShouldFail{}{wrong}{Second outer message}
  \assertFail{Second inner message}
\stopAssertShouldFail
\stopAssertShouldFail
\stopConTest

\stopTestCase

\stopTestSuite

\startTestSuite[assertFail]

The \type{\assertFail} assertion always fails.

\startMkIVCode
\def\assertFail#1{\assertionFailed{#1}{(Failed)}}
\stopMkIVCode

\startTestCase[should fail]

\startConTest
\startAssertShouldFail{Inner message}{}{Outer message}
  \assertFail{Inner message}
\stopAssertShouldFail
\stopConTest

\stopTestCase

\stopTestSuite

\startTestSuite[assertSucceed]

The \type{\assertSucceed} assertion always succeeds.

\startMkIVCode
\def\assertSucceed#1{\assertionSucceeded{#1}}
\stopMkIVCode

\startTestCase[should succeed]

\startConTest
  \assertSucceed{A message}
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertDefined]

The \type{\assertDefined} assertion confirms that the csname provided 
is defined as a \TeX\ command. 

% As another example, one can test whether a control sequence is defined by 

%\def\ifUnDefinedCs#1{\expandafter
%\ifx\csname#1\endcsname\relax}

%\ifUnDefinedCs{parindent} %is not true
%\ifUnDefinedCs{undefined} %is (one hopes) true

% This uses the fact that a \csname...\endcsname command is equivalent to 
% \relax if the control has not been defined before. Unfortunately, this 
% test also turns out true if a control has been \let to \relax. 

% See: 13.2.3 on page 141 of TeXbyTopic v1.4-2013

\startMkIVCode
\def\assertDefined#1#2{%
  \expandafter\ifx\csname#1\endcsname\relax%
    \assertionFailed{#2}{Expected #1 to be defined}%
  \else%
    \assertionSucceeded{#2}{}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if a csname is defined]

\startConTest
\assertDefined{startMkIVCode}{}
\stopConTest
\stopTestCase

\startTestCase[should file if a csname is not defined]

\startConTest
\startAssertShouldFail{}{}{}
\assertDefined{NotDefined}{}
\stopAssertShouldFail
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertNotDefined]

The \type{\assertNotDefined} assertion confirms that the csname provided 
is not defined as a \TeX\ command. 

\startMkIVCode
\def\assertNotDefined#1#2{%
  \expandafter\ifx\csname#1\endcsname\relax%
    \assertionSucceeded{#2}%
  \else%
    \assertionFailed{#2}{Expected #1 to not be defined}%
  \fi
}
\stopMkIVCode

\startTestCase[should succeed if a csname is not defined]
\startConTest
\assertNotDefined{NotDefined}{}
\stopConTest
\stopTestCase

\startTestCase[should fail if a csname is defined]

\startConTest
\startAssertShouldFail{}{}{}
\assertNotDefined{stopMkIVCode}
\stopAssertShouldFail
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[assertStringMatches]

The \type{\assertStringMatches} assertion confirms that the fully expanded 
result, taken as a lua string, matches the associated lua pattern match. 

\startMkIVCode
\def\assertStringMatches#1#2#3{%
  \directlua{
    thirddata.contests.reportMkIVAssertions(
      string.match('#1','#2'),
      '#3',
      'Expected [#1] to match [#2]'
    )
  }
}
\stopMkIVCode

\startTestCase[should succeed if a string matches]

\startConTest
%\assertStringMatches{a string}{string}
\stopConTest

\stopTestCase

\startTestCase[should fail is a string does not match]

\startConTest
\startAssertShouldFail{}{}{}
%\assertStringMatches{a string}{noMatch}
\stopAssertShouldFail
\stopConTest

\stopTestCase

\stopTestSuite

\startTestSuite[assertStringDoesNotMatch]

The \type{\assertStringDoesNotMatch} assertion confirms that the fully expanded 
result, taken as a lua string, does not match the associated lua pattern match. 

\startMkIVCode
\def\assertStringMatches#1#2#3{%
  \directlua{
    thirddata.contests.reportMkIVAssertions(
      not string.match('#1','#2'),
      '#3',
      'Expected [#1] to not match [#2]'
    )
  }
}
\stopMkIVCode

\startTestCase[should succeed if a string does not match ]

\startConTest
%\assertStringDoesNotMatch{a string}{noMatch}
\stopConTest

\stopTestCase

\startTestCase[should fail if a string does match]

\startConTest
\startAssertShouldFail{}{}{}
%\assertStringDoesNotMatch{a string}{string}
\stopAssertShouldFail
\stopConTest

\stopTestCase
\stopTestSuite

\section{Test case results}

\reportMkIVStats

\reportFailures

\stopchapter